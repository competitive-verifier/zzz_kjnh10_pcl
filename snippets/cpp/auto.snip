snippet bsearch
      ll left = 0, right = 1e9 + 1;
      auto isright = [&](ll y) {
          bool is_r = true;
  
          return is_r;
      };
      while (right - left > 1) {/*{{{*/
          ll mid = (right + left) / 2;
          if (isright(mid)) right = mid;
          else left = mid;
      }/*}}}*/
  
      dump(right);


snippet syakutori
      ll sum = 0;
  
      auto isok = [&](ll next_r) {  // check [l, next_r) is ok?
          if (sum + x[next_r - 1] <= k)
              return true;
          else
              return false;
      };
  
      ll res = 0;
      ll r = 0;
      for (ll l = 0; l < n; ++l) {
          // [l, r)を限界まで広げる。
          while (r < n && isok(r + 1)) {
              sum += x[r];
              ++r;
          }
          chmax(res, (r - l));
  
          // leftをincrementする準備
          if (r == l){
              ++r;  // 空区間から空区間への変動なので何もしない。
          }
          else{
              sum -= x[l];
          }
      }


snippet tsearch
  ll l = 0;
  ll r = 1000000001;
  
  // ll num = 100;
  // while(num--){
  while(r-l>2){
      ll d = (r-l)/3;
      ll ml = l + d;
      ll mr = l + 2*d;
      if ((score(ml) < score(mr))){
          r = mr;
      }
      else{
          l = ml;
      }
  }
  dump(l, r);
  ll ans = INF;
  rep(i, l, r+1) chmin(ans, score(i));


snippet slide_min
  template <typename T>  //{{{
  vector<T> slide_min(const vector<T> &v, int k) {
      deque<int> deq;
      vector<T> ret;
      int m = sz(v);
      rep(i, m) {
          while (!deq.empty() && v[deq.back()] >= v[i]) {
              deq.pop_back();
          }
          deq.push_back(i);
          if (i - k + 1 >= 0) {
              ret.emplace_back(v[deq.front()]);
              if (deq.front() == i - k + 1) deq.pop_front();
          }
      }
      return ret;  // sz(res) == m-k+1, last index is m-k
  }  //}}}


snippet SegmentTree2DRMQ
alias 2drmq
  struct segtree {
      int H, W;
      vector<vector<int>> dat;
      segtree() {}
      segtree(vector<vector<int>> &f) {
          H = W = 1;
          while (H < (int)f.size()) H <<= 1;
          while (W < (int)f[0].size()) W <<= 1;
          dat.assign(2 * H - 1, vector<int>(2 * W - 1, INF));
          init(f);
      }
      void init(vector<vector<int>> &f) {
          for (int i = 0; i < (int)f.size(); i++)
              for (int j = 0; j < (int)f[0].size(); j++)
                  dat[i + H - 1][j + W - 1] = f[i][j];
          dump("hello");
          for (int i = 2 * H - 2; i > H - 2; i--)
              for (int j = W - 2; j >= 0; j--)
                  dat[i][j] = min(dat[i][2 * j + 1], dat[i][2 * j + 2]);
          dump("hello1");
          for (int i = H - 2; i >= 0; i--)
              for (int j = 0; j < 2 * W - 1; j++)
                  dat[i][j] = min(dat[2 * i + 1][j], dat[2 * i + 2][j]);
          dump("hello2");
      }
      int minimum(int li, int lj, int ri, int rj) {
          return minimum_h(li, lj, ri, rj, 0, H, 0);
      }
      int minimum_h(int li, int lj, int ri, int rj, int si, int ti, int k) {
          if (ri <= si or ti <= li) return INF;
          if (li <= si and ti <= ri) return minimum_w(lj, rj, 0, W, k, 0);
          const int mi = (si + ti) / 2;
          return min(minimum_h(li, lj, ri, rj, si, mi, 2 * k + 1),
                     minimum_h(li, lj, ri, rj, mi, ti, 2 * k + 2));
      }
      int minimum_w(int lj, int rj, int sj, int tj, int i, int k) {
          if (rj <= sj or tj <= lj) return INF;
          if (lj <= sj and tj <= rj) return dat[i][k];
          const int mj = (sj + tj) / 2;
          return min(minimum_w(lj, rj, sj, mj, i, 2 * k + 1),
                     minimum_w(lj, rj, mj, tj, i, 2 * k + 2));
      }
  };


snippet event_sort
  struct Event {
      Event(int t_, int s_, int e_, int isIn_)
          : t(t_), s(s_), e(e_), isIn(isIn_) {}
      int t;
      int s, e;
      int isIn;
  
      bool operator<(const Event& rhs) {
          if (t == rhs.t) return isIn < rhs.isIn;
  
          return t < rhs.t;
      }
  };
  
  void event_sort(vector<int>& s, vector<int>& e) {
      // 回収はl, rは掃除するversion
      multiset<int> e_set;
      int n = sz(s);
  
      vector<Event> events;
      for (int i = 0; i < n; i++) {
          events.emplace_back(s[i], s[i], e[i], 1);
          events.emplace_back(e[i] + 1, s[i], e[i], 0);
      }
  
      sort(all(events));
  
      for (int i = 0; i < 2 * n; i++) {
          if (events[i].isIn) {
              e_set.insert(events[i].e);
          } else {
              e_set.erase(e_set.find(events[i].e));
          }
      }
  }


snippet RectangleSum
  template <typename T>
  struct RectangleSum {
      vector<vector<T>> sum;
      T GetSum(int top, int bottom, int left, int right){ // {{{
          // [left, right), [top, bottom)
          T res = sum[bottom-1][right-1];
          if (left > 0) res -= sum[bottom-1][left - 1];
          if (top > 0) res -= sum[top - 1][right-1];
          if (left > 0 && top > 0) res += sum[top - 1][left - 1];
          return res;
      } /*}}}*/
  
      RectangleSum(const vector<vector<T>> &s) { /*{{{*/
          int h = s.size();
          int w = s[0].size();
          sum.resize(h);
          for (int i = 0; i < h; i++) sum[i].resize(w, 0);
          for (int y = 0; y < h; y++) {
              for (int x = 0; x < w; x++) {
                  sum[y][x] = s[y][x];
                  if (y > 0) sum[y][x] += sum[y - 1][x];
                  if (x > 0) sum[y][x] += sum[y][x - 1];
                  if (y > 0 && x > 0) sum[y][x] -= sum[y - 1][x - 1];
              }
          }
      } /*}}}*/
  };


snippet napsack
      int n, h;
      cin >> h >> n;
      vector<int> v(n), w(n);
      rep(i, n) cin >> v[i] >> w[i];
  
      vector<int> dp(h + 1, INF);
      dp[0] = 0;
      rep(i, n) rep(j, h + 1) {  // 個数制限なし
                                 // rep(i,n) r_rep(j,h+1){ // 01 napsack
          chmin(dp[min(j + v[i], h)], dp[j] + w[i]);  // jから配る
      }
      cout << dp[h] << endl;


snippet cout
  cout << ${0} << endl;


snippet couts
  rep(i, sz(${1:x})) cout << $1[i] << (i!=sz($1)-1 ? " " : "\n");


snippet ?
  (${1} ? ${2} : ${3})


snippet inv
  vector<ll> ${1}(n);
  rep(i, n) {
      cin>>$1[i];
  }
  dump($1);${0}


snippet invv
  vector<vector<ll>> ${1}(h, vector<ll>(w));
  rep(i, h){
      rep(j,w){
          cin>>$1[i][j];
      }
  }


snippet invvs
  vector<vector<ll>> ${1}(h, vector<ll>(w));
  rep(i, h){
      string tmp;cin>>tmp;
      rep(j,w){
          if (tmp[j]=='#') $1[i][j]=1;
          else             $1[i][j]=0; 
      }
  }


snippet rep
  rep(${0}){
  }


snippet r_rep
  r_rep(${0}){
  }


snippet for
  for(ll i=0; i<n; i++){${0}
  }


snippet for_iter
  for(auto iter=begin(${1}); iter!=end($1); ++iter){${0}
  }


snippet for_riter
  for(auto riter=rbegin(${1}); riter!=rend($1); ++riter){${0}
  }


snippet if
  if (${0}) {
  }


snippet else
  else{${0}
  }


snippet elif
  else if(${0}){
  }


snippet while
  while(${0}){
  }


snippet reprep
  rep(${1}) rep(${2}){${0}
  }


snippet d
  dump(${0});


snippet af
  assert(false);


snippet sortkey
  sort(all(${0}), [&](auto &l, auto &r){return l.second < r.second;});


snippet perm
  vector<ll> p(n);
  iota(all(p), 0LL);
  do{
      dump(p);
      vector<ll> ma(a);
      rep(i, n) ma[i] = a[p[i]];
      dump(ma);
  } while (next_permutation(all(p)));


snippet to_bin
  // snippet:to_bin {{{
  string to_bin(ll n, ll d = 10){
      // nをd桁の2進数で表示する。
      stringstream ss;
      ss << bitset<64>(n);
      return ss.str().substr(64-d, d);
  }
  // ll d = (32 - __builtin_clz(n));  // 最大桁のd: (2^d)
  // ll f = N - d; to_bin()で返ってきた文字列で最初に1が立っているindex
  // snippet:to_bin }}}


snippet warsharll
  // init
  vector<vector<ll>> d(n, vector<ll>(n, INF));
  rep(i, n)rep(j, n){
      if (i==j) d[i][j] = 0;
  }
  
  // input
  ${0};
  
  // calc
  rep(k, n){
      rep(i, n){
          rep(j, n){
              chmin(d[i][j], d[i][k]+d[k][j]);
          }
      }
  }
  dump_2d(d, n, n);


snippet digitdp
  ll n = sz(s);
  vector<vector<ll>> dp(2, vector<ll>(n));
  dp[0][0] = 1;
  rep(i, 1, n+1){  //桁数
      rep(leq, 2){  //未満確定フラグ
          ll lim = leq ? 9 : s[i-1]-'0';
          rep(d, lim+1){
              dp[leq || d<lim][i] += dp[leq][i-1];
          }
      }
  }


snippet asv
  // acumulative sum vector {{{
  template<typename T>
  struct asvector {
      vector<T> cum; //accumulative sum
      asvector(vector<T> a): cum(a){  // {{{  // constructor
          rep(i, 1, sz(a))  cum[i]+=cum[i-1];
      }
      asvector(){};
      // }}}
  
      T sum(int l, int r) {  // return sum of [l, r) of data.  {{{
          l = max(0, l);
          r = min(r, sz(cum));
          if (l<r){
              return cum[r-1] - (l-1>=0 ? cum[l-1] : 0);
          }
          else{
              return 0;
          }
      } // }}}
  
      T& operator[](int i) { // {{{
          return cum[i]; 
      } // }}}
  
      friend ostream& operator<<(ostream &os, asvector<T>& as){//{{{
          os << as.cum; return os;
      } //}}}
  };
  //}}}


snippet remove_leading_zeros
  str.erase(0, min(str.find_first_not_of('0'), str.size()-1));


snippet lambda
alias f
  auto f = [&](){
  };


snippet dfs_lambda_graph
  vector<ll> used(n);
  auto dfs = [&](const auto& dfs, ll u) -> void {
      used[u] = 1;
      each(e, g[u]){
          if (used[e.to]) continue;
          dfs(dfs, e.to);
      }
  };
  dfs(dfs, 0);


snippet dfs_lambda
  auto dfs = [&](const auto& dfs, ll u) -> ll {
  };


snippet dxdy
  ll dx[]={1, -1, 0, 0};
  ll dy[]={0, 0, 1, -1};


snippet ostream
  ostream& operator<<(ostream& os, const ${1:type}& ${2}){
      os << ${3};
      return os;
  }


snippet query
  ll query(){
      cerrendl;
  
      return 0;
  }
  
  int main(){/*{{{*/
      ll Q;cin>>Q;
      rep(_, Q){
          query();
      }
      check_input();
      return 0;
  }/*}}}*/


snippet random_generator
  uint64_t rng() {
      static mt19937 x(chrono::steady_clock::now().time_since_epoch().count());
      return uniform_int_distribution<uint64_t>(0, -1)(x);
  }


snippet bitall
  rep(s, 1<<n){
      rep(i, n){
          if(s>>i&1){
          }
          else{
          }
      }
  }


snippet print_float
  printf("%.12f\n", ${1});


snippet sep
alias <<
  << " " << ${1}


snippet interactive
  ll counter = 0;
  ll query(ll u, ll v){/*{{{*/
      dump('q', u+1, v+1);
      counter++;
      if (counter>n/2) assert(false);
  
      cout << "?" << " " << u << " " << v << endl;
      fflush(stdout);
  
      // ll res = tr.lca(u, v);
      ll res; cin>>res;
  
      return res;
  }/*}}}*/
  
  void ans(ll u){/*{{{*/
      cout << "!" << " " << u+1 << endl;
  }/*}}}*/


snippet pairsort
  // snippet:pairsort {{{
  template<class T>
  void pairsort(vector<T>& x, vector<T>& y){
      ll n = sz(x);
      vector<tuple<T, T>> t(n);
      rep(i, n){
          t[i] = make_tuple(x[i], y[i]);
      }
      sort(all(t));
      rep(i, n){
          x[i] = get<0>(t[i]);
          y[i] = get<1>(t[i]);
      }
  }
  // snippet:pairsort }}}


snippet make_vector
  template<class T> vector<vector<vector<T>>> make_vector_2d(ll n1, ll n2, T init_value){
      return vector<vector<T>>(n1, vector<T>(n2, init_value));
  }
  
  
  template<class T> vector<vector<vector<T>>> make_vector_3d(ll n1, ll n2, ll n3, T init_value){
      return vector<vector<vector<T>>>(n1, vector<vector<T>>(n2, vector<T>(n3, init_value)));
  }
  // auto dp = make_vector_2d<mint>(n, k, 0);  // like ll dp[n][k];
  // auto dp = make_vector_3d<mint>(n, k, m, 0);  // like ll dp[n][k][m];


snippet erase_loop
  for(auto iter=begin(s); iter!=end(s);){
      // 処理
  
      // 終了処理
      if (*iter%3==0 || *iter==1) {  // delete
          iter = s.erase(iter);
      }
      else{  // non-delete
          ++iter;
      }
  }


snippet erase_loop_reverse
  for(auto riter=rbegin(s); riter!=rend(s);){
      // 処理
  
      // 終了処理
      if (*riter%3==0 || *riter==1) {
          auto iter = riter.base(); --iter; // iterに変換
          iter = s.erase(iter); // 要素を削除。これが終了した時点ではiterは削除要素の右を指している。
          riter = reverse_iterator(iter); // reverseすると左に１個進むのでちょうどよい。
      }
      else{
          riter++;
      }
  }


snippet get_rank
alias rank
  vector<ll> get_rank(vector<ll>& score){
      ll n = sz(score);
      vector<pair<ll, ll>> tmp(n);
      rep(i, n) tmp[i] = mp(score[i], i);
      sort(all(tmp));
  
      vector<ll> rank(n);
      ll now = -1, last = -1;
      rep(i, n){
          auto [dist, idx] = tmp[i];
          if (last < dist) now = i;
          rank[idx] = now;
          last = dist;
      }
      return rank;
  }


snippet encode
alias nid
  auto nid = [&](int i, int j){return (i*w + j);}; // int u = nid(i, j);
  auto pos = [&](int idx) -> pair<int, int> { return {idx/w, idx%w}; }; // auto [i,j] = pos(u);
  // auto nid = [&](int i, int j, int k){return (i*(y*z) + j*(z) + k);};
  // auto pos = [&](int idx) -> pair<int, int> { return {idx/(y*z), (idx/z)%y, idx%z}; };


snippet atcoder
alias acl
  // {{{ include acl-library
  // #include <atcoder/fenwicktree>
  // #include <atcoder/segtree>
  // #include <atcoder/lazysegtree>
  // #include <atcoder/string>
  // #include <atcoder/math>
  // #include <atcoder/convolution>
  // #include <atcoder/modint>
  // #include <atcoder/dsu>
  // #include <atcoder/maxflow>
  // #include <atcoder/mincostflow>
  // #include <atcoder/scc>
  // #include <atcoder/twosat>
  // using namespace atcoder;
  // }}}


snippet dfs
  stack<int> st;
  vector<int> used(n);
  
  st.push(0);
  while (!st.empty()) {
      auto u = st.top();
      st.pop();
      if (used[u]) continue;
      used[u] = 1;
  
      each(v, g[u]) {
          if (used[v]) continue;
          // if (d[u]+cost>=d[v]) continue;
          // d[v] = d[u]+cost;
          st.push(v);
      }
  }


snippet bfs
  queue<int> q;
  vector<int> used(n);
  
  q.push(0);
  while (!q.empty()) {
      auto u = q.front();
      q.pop();
      if (used[u]) continue;
      used[u] = 1;
  
      each(v, g[u]) {
          // process
          q.push(v);
      }
  }


snippet 01bfs
  deque<int> dq;
  vector<int> used(n);
  
  dq.push_back(0);
  while (!dq.empty()) {
      auto u = dq.front();
      dq.pop_front();
      if (used[u]) continue;
      used[u] = 1;
  
      each(v, g[u]) {
          // process
          q.push_back(v);
      }
  }


snippet gcd
  ll gcd(ll a, ll b) {
      if (b > a) swap(a, b);
      if (b == 0) return a;
      return gcd(b, a % b);
  }


snippet lcm
  ll gcd(ll a, ll b) {
      if (b > a) swap(a, b);
      if (b == 0) return a;
      return gcd(b, a % b);
  }
  
  ll lcm(ll a, ll b) {
      return (a / gcd(a, b)) * b;  // overflowしにくいように最初に割り算をする。
  }


snippet reverse_int
  ll gcd(ll a, ll b) {
      if (b > a) swap(a, b);
      if (b == 0) return a;
      return gcd(b, a % b);
  }
  
  ll lcm(ll a, ll b) {
      return (a / gcd(a, b)) * b;  // overflowしにくいように最初に割り算をする。
  }
  
  ll reverse_int(ll number) {
      ll reverse = 0;
      while (number > 0) {
          reverse = reverse * 10 + number % 10;
          number /= 10;
      }
      return reverse;
  }


snippet digitSum
  int digitSum(ll x) { /*{{{*/
      int res = 0;
      while (true) {
          res += x % 10;
          x /= 10;
          if (x == 0) {
              break;
          }
      }
      return res;
  } /*}}}*/


snippet is_prime
  bool is_prime(ll n) { /*{{{*/
      for (ll i = 2; i * i <= n; i++) {
          if (n % i == 0) return false;
      }
      return n != 1;
  } /*}}}*/


snippet prime_factor
  map<ll, ll> prime_factor(ll n) {  // 素因数分解 (o(√N)){{{
      map<ll, ll> res;  // vectorで持つことも考えられる。
      for (ll i = 2; i * i <= n; i++) {
          while (n % i == 0) {
              ++res[i];
              n /= i;
          }
      }
      if (n != 1) res[n] += 1;
      return res;
  }
  // (参考)http://pakapa104.hatenablog.com/entry/2016/02/09/230443
  //}}}


snippet divisor
  vector<ll> divisor(ll n) {  // 約数全列挙{{{
      vector<ll> p, q;
      for (ll i = 1; i * i <= n; i++) {
          if (n % i == 0) {
              p.pb(i);
              if (i * i != n) q.pb(n / i);
          }
      }
      reverse(all(q));
      p.insert(p.end(), all(q));
      return p;
  }  //}}}


snippet pascal
  template <class T>
  vector<vector<T>> pascal(int N) {  // {{{
      vector<vector<T>> com(N + 1, vector<T>(N + 1));
      com[0][0] = 1;
      rep(i, 1, N + 1) {
          // パスカルの三角形は0-indexdで段を数えるとよい。
          // com[i]を計算。
          rep(j, 0, i + 1) {
              if (j - 1 >= 0) com[i][j] += com[i - 1][j - 1];
              com[i][j] += com[i - 1][j];
              // com[i][j] /= 2.0;  // probability version
          }
      }
      return com;
  }  // }}}


snippet generalized_baybe_step_giant_step
alias gbsgs
  int mod = 1e9 + 7;
  // int mod = 998244353;
  struct mint {  //{{{
      ll x;
      mint(ll x = 0) : x((x % mod + mod) % mod) {}
  
      // ?= operator
      mint& operator+=(const mint a) {
          (x += a.x) %= mod;
          return *this;
      }
      mint& operator-=(const mint a) {
          (x += mod - a.x) %= mod;
          return *this;
      }
      mint& operator*=(const mint a) {
          (x *= a.x) %= mod;
          return *this;
      }
      mint& operator/=(const mint& rhs) {
          if (rhs.x == 0) throw runtime_error("mint zero division");
          return *this *= rhs.inv();
      }
  
      mint operator+(const mint a) const {
          mint res(*this);
          return res += a;
      }
      mint operator-(const mint a) const {
          mint res(*this);
          return res -= a;
      }
      mint operator*(const mint a) const {
          mint res(*this);
          return res *= a;
      }
      mint operator/(const mint a) const {
          mint res(*this);
          return res /= a;
      }
  
      mint pow(ll n) const {
          mint res(1), x(*this);
          if (n < 0) {
              n = -n;
              x = (*this).inv();
          }
          while (n) {
              if (n & 1) res *= x;
              x *= x;
              n >>= 1;
          }
          return res;
      }
  
      mint inv() const {
          if (x == 0) throw runtime_error("inv does not exist");
          return pow(mod - 2);
      }
      // mint inv()const{
      //     int x,y;
      //     int g=extgcd(v,mod,x,y);
      //     assert(g==1);
      //     if(x<0)x+=mod;
      //     return mint(x);
      // }
  
      bool operator<(const mint& r) const { return x < r.x; }
      bool operator==(const mint& r) const { return x == r.x; }
  };
  istream& operator>>(istream& is, const mint& a) { return is >> a.x; }
  ostream& operator<<(ostream& os, const mint& a) { return os << a.x; }
  //}}}
  
  int bsgs(int a, int b) {  //{{{
      // find x s.t a^x = b in (mod)
  
      if (b >= mod) return -1;
      if (1 % mod == b) return 0;
  
      int h = (int)sqrt(mod) + 1;  // h s.t x = p*h-r (0<=r<h and 0<=p<=h)
  
      unordered_map<int, vector<int>> rs;  // rs[v]: vector of r s.t b*a^r==v
      mint bar = b;
      rep(r, 0, h) {
          rs[bar.x].pb(r);
          bar *= a;
      }
      bool looped = false;
      each(el, rs) if (sz(el.second) > 1) looped = true;
  
      mint ah = mint(a).pow(h);
      rep(p, 1, h + 1) {
          int aph = ah.pow(p).x;
          if (rs.find(aph) != rs.end()) {
              reverse(all(rs[aph]));
              each(r, rs[aph]) {
                  if ((p * h - r) >= 0 && mint(a).pow(p * h - r) == b)
                      return p * h - r;
              }
          }
          if (looped) return -1;
      }
  
      return -1;
  }  //}}}


snippet dist
  template<class T> T dist(T x1, T y1, T x2, T y2){ return sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2)); }


snippet rad
  template<class T> T rad(T x){ return x * M_PI / 180.0; }


snippet degree
alias deg
  template<class T> T deg(T r){ return r / M_PI * 180.0; }


snippet baybe_step_giant_step
alias bsgs
  int mod = 1e9 + 7;
  // int mod = 998244353;
  struct mint {  //{{{
      ll x;
      mint(ll x = 0) : x((x % mod + mod) % mod) {}
  
      // ?= operator
      mint& operator+=(const mint a) {
          (x += a.x) %= mod;
          return *this;
      }
      mint& operator-=(const mint a) {
          (x += mod - a.x) %= mod;
          return *this;
      }
      mint& operator*=(const mint a) {
          (x *= a.x) %= mod;
          return *this;
      }
      mint& operator/=(const mint& rhs) {
          if (rhs.x == 0) throw runtime_error("mint zero division");
          return *this *= rhs.inv();
      }
  
      mint operator+(const mint a) const {
          mint res(*this);
          return res += a;
      }
      mint operator-(const mint a) const {
          mint res(*this);
          return res -= a;
      }
      mint operator*(const mint a) const {
          mint res(*this);
          return res *= a;
      }
      mint operator/(const mint a) const {
          mint res(*this);
          return res /= a;
      }
  
      mint pow(ll n) const {
          mint res(1), x(*this);
          if (n < 0) {
              n = -n;
              x = (*this).inv();
          }
          while (n) {
              if (n & 1) res *= x;
              x *= x;
              n >>= 1;
          }
          return res;
      }
  
      mint inv() const {
          if (x == 0) throw runtime_error("inv does not exist");
          return pow(mod - 2);
      }
      // mint inv()const{
      //     int x,y;
      //     int g=extgcd(v,mod,x,y);
      //     assert(g==1);
      //     if(x<0)x+=mod;
      //     return mint(x);
      // }
  
      bool operator<(const mint& r) const { return x < r.x; }
      bool operator==(const mint& r) const { return x == r.x; }
  };
  istream& operator>>(istream& is, const mint& a) { return is >> a.x; }
  ostream& operator<<(ostream& os, const mint& a) { return os << a.x; }
  //}}}
  
  int bsgs(int a, int b) {  //{{{
      if (b >= mod) {
          return -1;
      }
  
      // find x s.t a^x = b in (mod)
      mint x;
      int sq = sqrt(mod);
      // x = p*sq + r  (0<=r<sq and 0<=p<=sq)
  
      map<int, int> minr;  // minr[v]: min(r s.t a^r=v)
      mint ar = 1;
      rep(r, 0, sq) {
          if (minr.find(ar.x) == minr.end()) minr[ar.x] = r;
          ar *= a;
      }
  
      mint A = mint(a).pow(-sq);
      rep(p, 0, sq + 1) {
          int Ab = (A.pow(p) * b).x;
          if (minr.find(Ab) != minr.end()) {
              int r = minr[Ab];
              return p * sq + r;
          }
      }
  
      return -1;
  }  //}}}


snippet gridgraph
      // grid graphを通常のグラフに格納する。
      int h, w;
      cin >> h >> w;
      int n = h * w;  // 頂点数
      vector<vector<ll>> block(h, vector<ll>(w));
      rep(i, h) {
          string s;
          cin >> s;
          rep(j, w) { block[i][j] = (s[j] == '#' ? 1 : 0); }
      }
  
      Graph g(n);
  
      auto nid = [&](int i, int j){return (i*w + j);};
      // int u = nid(i, j);
      auto pos = [&](int u) -> pair<int, int> { return {u/w, u%w}; };
      // auto [i,j] = pos(u);
  
      int dx[] = {1, -1, 0, 0};
      int dy[] = {0, 0, 1, -1};
  
      // 下と右のみ. rep(k, 4)をrep(k, 2)に変更するのも忘れない。
      // int dx[] = {1, 0};
      // int dy[] = {0, 1};
      rep(i, h) rep(j, w) {
          if (block[i][j]) continue;  // blockから出る辺はない
          rep(dir, 4) {
              int ni = i + dx[dir];
              int nj = j + dy[dir];
              if (is_in(ni, 0, h) && is_in(nj, 0, w)) {
                  if (block[ni][nj]) continue;  // blockに入る辺はない
                  g.add_edge(nid(i, j), nid(ni, nj));
                  // 自分から生える辺だけでよい。そうしないと二重辺になってしまう。
              }
          }
      }


snippet reroot
      tree tr(n);
      rep(i, n - 1) {
          int u, v;
          cin >> u >> v;
          u--;
          v--;
          tr.add_edge(u, v);
      }
      tr.build(0);
  
      vector<map<int, int>> dp(n);
      // dp[u][v]: uの親をvとするような向きで木を見た時のuを頂点とする部分木の情報
  
      // first dfs
      r_rep(i, 1, n) {
          // 葉からdp
          int u = tr.dfstrv[i];
          dp[u][tr.par[u]] = col[u];  // TODO: update: 子供がいない場合
          each(ch, tr.children[u]) {
              dp[u][tr.par[u]] += max(0LL, dp[ch][u]);  // TODO: update
          }
      }
      dump_2d(dp, n, n);
  
      // second dfs
      rep(i, 0, n) {
          cerrendl;
          // uを頂点とする部分木の情報dp[u][*]を配る。
          int u = tr.dfstrv[i];
          int m = sz(tr.adj[u]);
  
          vector<int> lcum(m + 2);
          vector<int> rcum(m + 2);
          {  // 前処理
              vector<int> child_info(m + 2);
              rep(j, 1, m + 1) {
                  int v = tr.adj[u][j - 1];
                  child_info[j] = max(dp[v][u], 0LL);  // TODO: update
              }
              lcum[0] = 0;
              lcum[m + 1] = 0;  // 単位元を番兵に  // TODO: update
              rcum[0] = 0;
              rcum[m + 1] = 0;  // 単位元を番兵に  // TODO: update
              rep(j, 1, m + 1) {
                  lcum[j] = lcum[j - 1] + child_info[j];  // TODO: update
              }
              r_rep(j, 1, m + 1) {
                  rcum[j] = rcum[j + 1] + child_info[j];  // TODO: update
              }
              dump(child_info);
          }
  
          dump(lcum);
          dump(rcum);
          rep(j, 1, m + 1) {
              int v = tr.adj[u][j - 1];
              dp[u][v] = lcum[j - 1] + rcum[j + 1];  // TODO: update
              dp[u][v] += col[u];  // 追加条件  // TODO: update
              dump(u, v, j, dp[u][v], lcum[j - 1], rcum[j + 1], col[u]);
          }
      }
      dump_2d(dp, n, n);
  
      // answer
      vector<int> ans;
      rep(u, n) {
          int res = col[u];  // TODO: update
          each(v, tr.adj[u]) {
              res += max(0LL, dp[v][u]);  // TODO: update
          }
          ans.push_back(res);
      }
      rep(i, sz(ans)) cout << ans[i] << (i != sz(ans) - 1 ? " " : "\n");


snippet mincostflow
alias mcf
  // snippet:mincostflow {{{
  #include <atcoder/mincostflow>
  using namespace atcoder;
  
  mcf_graph<ll, ll> g(2*n + 4);
  // auto debug = [&](){
  //     auto edges = (g.edges());
  //     for (auto& e : edges){ dump(e.from, e.to, e.cap, e.flow, e.cost); }
  // };
  ll s0 = 2*n;     // super source
  ll s1 = 2*n+1;   // original source
  ll t1 = 2*n+2;   // original target
  ll t0 = 2*n+3;   // super target
  
  ll total_cost = 0;
  ll surplus_at_super_source = 0;
  auto add_negative_edge = [&](ll u, ll v, ll cap, ll cost){
      assert(cost <= 0);
      g.add_edge(s0, v, cap, 0);
      g.add_edge(u, t0, cap, 0);
      g.add_edge(v, u, cap, -cost);
      total_cost += cost;
      surplus_at_super_source += cap;
  };
  
  // add edge
  g.add_edge(t1, s1, INF, 0);
  rep(x, n) g.add_edge(s1, x, k, 0);
  rep(x, n, 2*n) g.add_edge(x, t1, k, 0);
  rep(i, n)rep(j, n) add_negative_edge(i, n+j, 1, -a[i][j]);
  
  auto res = g.flow(s0, t0, surplus_at_super_source);
  cout << -(total_cost + res.second) << endl;
  
  // 復元
  auto edges = (g.edges());
  vec<string> ans(n, string(n, '.'));
  for (auto& e : edges){
      if (e.flow == 0 && e.cost > 0){
          ans[e.to][e.from-n] = 'X';
      }
  }
  rep(i, n) cout << ans[i] << endl;
  // snippet:mincostflow }}}


snippet lcs
  #define MAX_N 5000
  #define MAX_M 5000
  int lcs(string s, string t) {
      int n = sz(s);
      int m = sz(t);
      int dp[MAX_N + 1][MAX_M + 1] = {};  // 1-index
  
      rep(i, n) {
          rep(j, m) {
              if (s[i] == t[j])
                  chmax(dp[i + 1][j + 1], dp[i][j] + 1);
              else {
                  chmax(dp[i + 1][j + 1], dp[i][j + 1]);
                  chmax(dp[i + 1][j + 1], dp[i + 1][j]);
              }
          }
      }
      return dp[n][m];
  }


snippet kmp
  // Morris-Pratt
  template <typename T>
  struct KMP {
      int n;
      T pattern;
      vector<int> a;
      KMP() {} /*{{{*/
      KMP(const T& pattern) : pattern(pattern) {
          n = pattern.size();
          a = vector<int>(n + 1);
          a[0] = -1;
          int j = -1;
          for (int i = 0; i < n; ++i) {
              while (j != -1 && pattern[j] != pattern[i]) j = a[j];
              j++;
              a[i + 1] = j;
          }
      } /*}}}*/
      int operator[](int i) { return a[i]; }
      vector<int> findAll(const T& s) { /*{{{*/
          vector<int> res;
          int j = 0;
          for (int i = 0; i < sz(s); ++i) {
              while (j != -1 && pattern[j] != s[i]) j = a[j];
              j++;
              if (j == n) {
                  res.push_back(i - j + 1);
                  j = a[j];
              }
          }
          return res;
      } /*}}}*/
  };
  
  // KMP<vector<int>> kmp({1,2,3});
  // KMP<string> kmp("abc");


snippet header
  // snippet:header {{{
  #ifndef HEADER_H
  #define HEADER_H
  
  // template version 2.0
  using namespace std;
  #include <bits/stdc++.h>
  
  // varibable settings
  const long long INF = 1e18;
  template <class T> constexpr T inf = numeric_limits<T>::max() / 2.1;
  
  #define _overload3(_1, _2, _3, name, ...) name
  #define _rep(i, n) repi(i, 0, n)
  #define repi(i, a, b) for (ll i = (ll)(a); i < (ll)(b); ++i)
  #define rep(...) _overload3(__VA_ARGS__, repi, _rep, )(__VA_ARGS__)
  #define _rrep(i, n) rrepi(i, 0, n)
  #define rrepi(i, a, b) for (ll i = (ll)((b)-1); i >= (ll)(a); --i)
  #define r_rep(...) _overload3(__VA_ARGS__, rrepi, _rrep, )(__VA_ARGS__)
  #define each(i, a) for (auto &&i : a)
  #define all(x) (x).begin(), (x).end()
  #define sz(x) ((int)(x).size())
  #define pb(a) push_back(a)
  #define mp(a, b) make_pair(a, b)
  #define mt(...) make_tuple(__VA_ARGS__)
  #define ub upper_bound
  #define lb lower_bound
  #define lpos(A, x) (lower_bound(all(A), x) - A.begin())
  #define upos(A, x) (upper_bound(all(A), x) - A.begin())
  template <class T, class U> inline void chmax(T &a, const U &b) { if ((a) < (b)) (a) = (b); }
  template <class T, class U> inline void chmin(T &a, const U &b) { if ((a) > (b)) (a) = (b); }
  template <typename X, typename T> auto make_table(X x, T a) { return vector<T>(x, a); }
  template <typename X, typename Y, typename Z, typename... Zs> auto make_table(X x, Y y, Z z, Zs... zs) { auto cont = make_table(y, z, zs...); return vector<decltype(cont)>(x, cont); }
  
  #define cdiv(a, b) (((a) + (b)-1) / (b))
  #define is_in(x, a, b) ((a) <= (x) && (x) < (b))
  #define uni(x) sort(all(x)); x.erase(unique(all(x)), x.end())
  #define slice(l, r) substr(l, r - l)
  
  typedef long long ll;
  typedef long double ld;
  using vl = vector<ll>;
  using vvl = vector<vl>;
  using pll = pair<ll, ll>;
  
  template <typename T>
  using PQ = priority_queue<T, vector<T>, greater<T>>;
  void check_input() { assert(cin.eof() == 0); int tmp; cin >> tmp; assert(cin.eof() == 1); }
  
  #if defined(PCM) || defined(LOCAL)
  #else
  #define dump(...) ;
  #define dump_1d(...) ;
  #define dump_2d(...) ;
  #define cerrendl ;
  #endif
  
  #endif /* HEADER_H */
  // snippet:header }}}


snippet lis
  template<class T>
  int lis(const vector<T>& x, bool strict=true) { /*{{{*/
      int n = sz(x);
      vector<T> dp(n+1, numeric_limits<T>().max());
      vector<pair<int, T>> update_info(n);
      dp[0] = numeric_limits<T>().min();
      int res = 0;
      rep(i, n) {
          int j;
          if (strict) j = lb(all(dp), x[i]) - dp.begin();
          else        j = ub(all(dp), x[i]) - dp.begin();
          chmax(res, j);
          update_info[i] = make_pair(j, dp[j]);
          dp[j] = x[i];
      }
      dump(dp);
  
      // 復元
      int now_len = res;
      vector<T> lis;
      r_rep(i, n){
          auto [j, pre] = update_info[i];
          if (j==now_len) {
              now_len--;
              lis.push_back(x[i]);
          }
          dp[j] = pre;
      }
      assert(now_len==0);
      reverse(all(lis));
      dump(lis);
  
      return res;
  } /*}}}*/


snippet sparse_table
  // snippet:sparse_table {{{
  template< class T = ll >
  struct sparse_table {
      vector< vector< T > > st;
      vector< int > lookup;
  
      sparse_table(const vector< T > &v) {
          int b = 0;
          while((1 << b) <= sz(v)) ++b;
          st.assign(b, vector< T >(1 << b));
          for(int i = 0; i < sz(v); i++) {
              st[0][i] = v[i];
          }
          for(int i = 1; i < b; i++) {
              for(int j = 0; j + (1 << i) <= (1 << b); j++) {
                  st[i][j] = min(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]);
              }
          }
          lookup.resize(v.size() + 1);
          for(int i = 2; i < sz(lookup); i++) {
              lookup[i] = lookup[i >> 1] + 1;
          }
      }
  
      inline T query(int l, int r) {  // [l, r)
          int b = lookup[r - l];
          return min(st[b][l], st[b][r - (1 << b)]);
      }
  };
  // snippet:sparse_table }}}


snippet bit
  template <typename T = ll>
  struct bit {  //{{{
      int n;
      vector<T> dat;
      vector<T> raw;
  
      bit(int _n = 0) {  //{{{
          n = _n;
          dat = vector<T>(n);
          raw = vector<T>(n);
      }  //}}}
  
      bit(vector<T> a) {  // {{{
          n = (int)a.size();
          dat = vector<T>(n);
          raw = vector<T>(n);
          for (int i = 0; i < n; i++) {
              add(i, a[i]);
              raw[i] = a[i];
          }
      }  //}}}
  
      T _rsum(int i) {  //{{{ [0, i]
          T s = 0;
          while (i >= 0) {
              s += dat[i];
              i = (i & (i + 1)) - 1;
          }
          return s;
      }  //}}}
  
      T query(int l, int r) {  //{{{  [l, r)
          if (l > r - 1) return 0;
          return _rsum(r - 1) - _rsum(l - 1);
      }  //}}}
  
      void add(int i, T x) {  //{{{
          raw[i] += x;
          while (i < n) {
              dat[i] += x;
              i |= i + 1;
          }
      }  //}}}
  
      int lower_bound(T x) {  // a[0]+...+a[ret] >= x{{{
          int ret = -1;
          int k = 1;
          while (2 * k <= n) k <<= 1;
          for (; k > 0; k >>= 1) {
              if (ret + k < n && dat[ret + k] < x) {
                  x -= dat[ret + k];
                  ret += k;
              }
          }
          return ret + 1;
      }  //}}}
  
      #if defined(PCM) || defined(LOCAL)
      friend ostream& operator<<(ostream& os, bit<T>& b) {  //{{{
          os << endl << "  raw:" << b.raw << endl;
          vector<T> acum;
          rep(i, b.n) { acum.pb(b.sum(i)); }
          os << "  acm:" << acum << endl;
          return os;
      }  //}}}
      #endif
  };     //}}}


snippet segment_tree_lazy
alias lazy
  // snippet:segment_tree_lazy {{{
  template <typename X, typename M>
  struct segment_tree_lazy {
      using FX = function<X(X, X)>;
      using FA = function<X(X, M)>;
      using FM = function<M(M, M)>;
      using index = int;
      int n;  // 元の配列のサイズ
      int N;  // n以上の最小の2冪
      FX merge;
      FA apply;
      FM composite;
      const X ex;
      const M em;
      vector<X> dat;
      vector<M> lazy;
      segment_tree_lazy(FX merge_, FA apply_, FM composite_, X ex_, M em_)
          : merge(merge_), apply(apply_), composite(composite_), ex(ex_), em(em_) {
      }
  
      void set(index i, X x) { dat[i + n - 1] = x; }
      void init(index n_) { 
          N = 1;
          n = n_;
          while (N < n_) N <<= 1;
          dat.assign(2 * N, ex);
          lazy.assign(2 * N, em);
      } 
  
      void build(const vector<X> &v) { 
          int n_ = v.size();
          init(n_);
          for (int i = 0; i < n_; i++) dat[i + N - 1] = v[i];
          for (int k = N - 2; k >= 0; k--) dat[k] = merge(dat[2 * k + 1], dat[2 * k + 2]);
      } 
  
      /* lazy propagate */
      void propagate(int k) {
          if (lazy[k] == em) return;  // 更新するものが無ければ終了
          if (k < N - 1) {            // 葉でなければ子に伝搬
              lazy[k * 2 + 1] = composite(lazy[k * 2 + 1], lazy[k]);
              lazy[k * 2 + 2] = composite(lazy[k * 2 + 2], lazy[k]);
          }
          // 自身を更新
          dat[k] = apply(dat[k], lazy[k]);
          lazy[k] = em;
      }
  
      void update(index a, index b, M x) { update(a, b, x, 0, 0, N); }
      void update(index a, index b, M x, int k, index l, index r) {
          if (a <= l && r <= b) {  // 完全に内側の時
              lazy[k] = composite(lazy[k], x);
              propagate(k);
          }
          else if (a < r && l < b) {                     // 一部区間が被る時
              propagate(k);
              update(a, b, x, k * 2 + 1, l, (l + r) / 2);  // 左の子
              update(a, b, x, k * 2 + 2, (l + r) / 2, r);  // 右の子
              dat[k] = merge(dat[k * 2 + 1], dat[k * 2 + 2]);
          }
          else{
              propagate(k);
          }
      }
  
      X query(index a, index b) { return query_sub(a, b, 0, 0, N); }
      X query_sub(index a, index b, int k, index l, index r) {
          propagate(k);
          if (r <= a || b <= l) {  // 完全に外側の時
              return ex;
          }
          else if (a <= l && r <= b) {  // 完全に内側の時
              return dat[k];
          }
          else {  // 一部区間が被る時
              X lv = query_sub(a, b, k * 2 + 1, l, (l + r) / 2);
              X rv = query_sub(a, b, k * 2 + 2, (l + r) / 2, r);
              return merge(lv, rv);
          }
      }
  
      index find_most_left(index l, const function<bool(X)>& is_ok){
          // lから右に探していってis_okが初めて成り立つようなindexを返す。
          // assume query(l, *) has monotonity
          // return index i s.t is_ok(query(l, i)) does not holds, but is_ok(query(l, i+1)) does.
          // if such i does not exist, return n
          index res = _find_most_left(l, is_ok, 0, 0, N, ex).first;
          assert(l <= res);
          return res;
      }
      pair<index, X> _find_most_left(index a, const function<bool(X)>& is_ok, int k, index l, index r, X left_value){
          // params:
              // left_value = (a < l ? query(a, l) : ex)
          // return (index i, X v)
              // i is the index in [a, n)^[l, r) s.t query(a, i+1) is ok but query(a, i) isn't ok. if such i does not exist, i = n
              // v is the value s.t query(a, r)
  
          propagate(k);
          if (r <= a) return {n, ex};  // 区間が全く被っていない
          else if (a <= l && !is_ok(merge(left_value, dat[k]))) return {n, merge(left_value, dat[k])};
          else if (k >= N-1) return {k - (N-1), merge(left_value, dat[k])};
          else{
              auto [vl, xl] = _find_most_left(a, is_ok, 2 * k + 1, l, (l + r) / 2, left_value);
              if (vl != n) return {vl, xl};
              auto [vr, xr] = _find_most_left(a, is_ok, 2 * k + 2, (l + r) / 2, r, xl);
              return {vr, xr};
          }
      }
  
      index find_most_right(index r, const function<bool(X)>& is_ok){
          // rから左に探していってis_okが初めて成り立つようなindexを返す。
          // assume query(*, r) has monotonity
          // return index i s.t is_ok(query(i+1, r+1)) does not holds, but is_ok(query(i, r+1)) does.
          // if such i does not exist, return -1
          index res = _find_most_right(r+1, is_ok, 0, 0, N, ex).first;
          assert(res <= r);
          return res;
      }
      pair<index, X> _find_most_right(index b, const function<bool(X)>& is_ok, int k, index l, index r, X right_value){
          propagate(k);
          if (b <= l) return {-1, ex};  // 区間が全く被っていない
          else if (r <= b && !is_ok(merge(dat[k], right_value))) return {-1, merge(dat[k], right_value)};
          else if (k >= N-1) return {k - (N-1), merge(dat[k], right_value)};
          else{
              auto [vr, xr] = _find_most_right(b, is_ok, 2 * k + 2, (l + r) / 2, r, right_value);
              if (vr != -1) return {vr, xr};
              auto [vl, xl] = _find_most_right(b, is_ok, 2 * k + 1, l, (l + r) / 2, xr);
              return {vl, xl};
          }
      }
  
      /* debug */
      inline X operator[](int i) { return query(i, i + 1); }
  
      #if defined(PCM) || defined(LOCAL)
      friend ostream& operator<<(ostream& os, segment_tree_lazy& sg) {  //
          os << "[";
          for (int i = 0; i < sg.n; i++) {
              os << sg[i] << (i == sg.n - 1 ? "]\n" : ", ");
          }
          return os;
      }
      #endif
  };
  // Regarding apply and merge, the conditions below should holds.
  // apply(merge(x1, x2), m) = merge(apply(x1, m), apply(x2, m))
  // apply(apply(x, m1), m2) = apply(x, composition(m1, m2))
  // composition(m, em) = m && composition(em, m) = m && apply(x, em) = x
  // snippet:segment_tree_lazy }}}


snippet segment_tree
alias rmq
  // snippet:segment_tree {{{
  template <typename X> struct SegmentTree {  // {{{
      private:
          using F = function<X(X, X)>;
          using index = int;
          int n;  // 元の配列のサイズ
          int N;  // n以上の最小の2冪
          vector<X> node;
          F merge;
          X identity;
  
      public:
          SegmentTree() {}
          SegmentTree(vector<X> a, F f, X id) : merge(f), identity(id) {
              n = a.size();
              N = 1;
              while (N < n) N *= 2;
              node.resize(2 * N - 1, identity);
              for (int i = 0; i < n; i++) node[i + N - 1] = a[i];
              for (int i = N - 2; i >= 0; i--)
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
          }
          SegmentTree(int sz, F f, X id) : SegmentTree(vector<X>(sz, id), f, id) {}
  
          X& operator[](index i) { return node[i + N - 1]; }
  
          void set(index i, X val) {
              i += (N - 1);
              node[i] = val;
              while (i > 0) {
                  i = (i - 1) / 2;
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
              }
          }
  
          void add(index i, X val) {
              i += (N - 1);
              node[i] += val;
              while (i > 0) {
                  i = (i - 1) / 2;
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
              }
          }
  
          // query for [a, b)
          X query(index a, index b, int k = 0, index l = 0, index r = -1) {
              if (r < 0) r = N;
              if (r <= a || b <= l) return identity;
              if (a <= l && r <= b) return node[k];
  
              X vl = query(a, b, 2 * k + 1, l, (l + r) / 2);
              X vr = query(a, b, 2 * k + 2, (l + r) / 2, r);
              return merge(vl, vr);
          }
  
          index find_most_left(index l, const function<bool(X)>& is_ok){
              // lから右に探していってis_okが初めて成り立つようなindexを返す。
              // assume query(l, *) has monotonity
              // return index i s.t is_ok(query(l, i)) does not holds, but is_ok(query(l, i+1)) does.
              // if such i does not exist, return n
              index res = _find_most_left(l, is_ok, 0, 0, N, identity).first;
              assert(l <= res);
              return res;
          }
          pair<index, X> _find_most_left(index a, const function<bool(X)>& is_ok, int k, index l, index r, X left_value){
              // params:
                  // left_value = (a < l ? query(a, l) : ex)
              // return (index i, X v)
                  // i is the index in [a, n)^[l, r) s.t query(a, i+1) is ok but query(a, i) isn't ok. if such i does not exist, i = n
                  // v is the value s.t query(a, r)
  
              if (r <= a) return {n, identity};  // 区間が全く被っていない
              else if (a <= l && !is_ok(merge(left_value, node[k]))) return {n, merge(left_value, node[k])};
              else if (k >= N-1) return {k - (N-1), merge(left_value, node[k])};
              else{
                  auto [vl, xl] = _find_most_left(a, is_ok, 2 * k + 1, l, (l + r) / 2, left_value);
                  if (vl != n) return {vl, xl};
                  auto [vr, xr] = _find_most_left(a, is_ok, 2 * k + 2, (l + r) / 2, r, xl);
                  return {vr, xr};
              }
          }
  
          index find_most_right(index r, const function<bool(X)>& is_ok){
              // rから左に探していってis_okが初めて成り立つようなindexを返す。
              // assume query(*, r) has monotonity
              // return index i s.t is_ok(query(i+1, r+1)) does not holds, but is_ok(query(i, r+1)) does.
              // if such i does not exist, return -1
              index res = _find_most_right(r+1, is_ok, 0, 0, N, identity).first;
              assert(res <= r);
              return res;
          }
          pair<index, X> _find_most_right(index b, const function<bool(X)>& is_ok, int k, index l, index r, X right_value){
              if (b <= l) return {-1, identity};  // 区間が全く被っていない
              else if (r <= b && !is_ok(merge(node[k], right_value))) return {-1, merge(node[k], right_value)};
              else if (k >= N-1) return {k - (N-1), merge(node[k], right_value)};
              else{
                  auto [vr, xr] = _find_most_right(b, is_ok, 2 * k + 2, (l + r) / 2, r, right_value);
                  if (vr != -1) return {vr, xr};
                  auto [vl, xl] = _find_most_right(b, is_ok, 2 * k + 1, l, (l + r) / 2, xr);
                  return {vl, xl};
              }
          }
  
          #if defined(PCM) || defined(LOCAL)
          friend ostream& operator<<(ostream& os, SegmentTree<X>& sg) {  //
              os << "[";
              for (int i = 0; i < sg.n; i++) {
                  os << sg[i] << (i == sg.n - 1 ? "]\n" : ", ");
              }
              return os;
          }
          #endif
  };/*}}}*/
  // sample of initialize SegmentTree:
  // -----------------------------------------------
  // auto mymin=[](auto a, auto b){return min(a,b);};
  // SegmentTree<ll> seg(a, mymin, 1e18);
  
  // auto mymax=[](auto a, auto b){return max(a,b);};
  // SegmentTree<ll> seg(a, mymax, -1e18);
  
  // auto add=[](auto a, auto b){return a+b;};
  // SegmentTree<ll> seg(a, add, 0);
  
  // pair<int, int> get_nearest_index_of_smaller_element(int i){
  //     auto left = seg.find_most_right(i, [&](auto x){return x < a[i];});
  //     auto right = seg.find_most_left(i, [&](auto x){return x < a[i];});
  //     return {left, right};
  // }
  // -----------------------------------------------
  // snippet:segment_tree }}}


snippet make_lseg_rmq_ruq
alias rmq_ruq
  // snippet:segment_tree_lazy {{{
  template <typename X, typename M>
  struct segment_tree_lazy {
      using FX = function<X(X, X)>;
      using FA = function<X(X, M)>;
      using FM = function<M(M, M)>;
      using index = int;
      int n;  // 元の配列のサイズ
      int N;  // n以上の最小の2冪
      FX merge;
      FA apply;
      FM composite;
      const X ex;
      const M em;
      vector<X> dat;
      vector<M> lazy;
      segment_tree_lazy(FX merge_, FA apply_, FM composite_, X ex_, M em_)
          : merge(merge_), apply(apply_), composite(composite_), ex(ex_), em(em_) {
      }
  
      void set(index i, X x) { dat[i + n - 1] = x; }
      void init(index n_) { 
          N = 1;
          n = n_;
          while (N < n_) N <<= 1;
          dat.assign(2 * N, ex);
          lazy.assign(2 * N, em);
      } 
  
      void build(const vector<X> &v) { 
          int n_ = v.size();
          init(n_);
          for (int i = 0; i < n_; i++) dat[i + N - 1] = v[i];
          for (int k = N - 2; k >= 0; k--) dat[k] = merge(dat[2 * k + 1], dat[2 * k + 2]);
      } 
  
      /* lazy propagate */
      void propagate(int k) {
          if (lazy[k] == em) return;  // 更新するものが無ければ終了
          if (k < N - 1) {            // 葉でなければ子に伝搬
              lazy[k * 2 + 1] = composite(lazy[k * 2 + 1], lazy[k]);
              lazy[k * 2 + 2] = composite(lazy[k * 2 + 2], lazy[k]);
          }
          // 自身を更新
          dat[k] = apply(dat[k], lazy[k]);
          lazy[k] = em;
      }
  
      void update(index a, index b, M x) { update(a, b, x, 0, 0, N); }
      void update(index a, index b, M x, int k, index l, index r) {
          if (a <= l && r <= b) {  // 完全に内側の時
              lazy[k] = composite(lazy[k], x);
              propagate(k);
          }
          else if (a < r && l < b) {                     // 一部区間が被る時
              propagate(k);
              update(a, b, x, k * 2 + 1, l, (l + r) / 2);  // 左の子
              update(a, b, x, k * 2 + 2, (l + r) / 2, r);  // 右の子
              dat[k] = merge(dat[k * 2 + 1], dat[k * 2 + 2]);
          }
          else{
              propagate(k);
          }
      }
  
      X query(index a, index b) { return query_sub(a, b, 0, 0, N); }
      X query_sub(index a, index b, int k, index l, index r) {
          propagate(k);
          if (r <= a || b <= l) {  // 完全に外側の時
              return ex;
          }
          else if (a <= l && r <= b) {  // 完全に内側の時
              return dat[k];
          }
          else {  // 一部区間が被る時
              X lv = query_sub(a, b, k * 2 + 1, l, (l + r) / 2);
              X rv = query_sub(a, b, k * 2 + 2, (l + r) / 2, r);
              return merge(lv, rv);
          }
      }
  
      index find_most_left(index l, const function<bool(X)>& is_ok){
          // lから右に探していってis_okが初めて成り立つようなindexを返す。
          // assume query(l, *) has monotonity
          // return index i s.t is_ok(query(l, i)) does not holds, but is_ok(query(l, i+1)) does.
          // if such i does not exist, return n
          index res = _find_most_left(l, is_ok, 0, 0, N, ex).first;
          assert(l <= res);
          return res;
      }
      pair<index, X> _find_most_left(index a, const function<bool(X)>& is_ok, int k, index l, index r, X left_value){
          // params:
              // left_value = (a < l ? query(a, l) : ex)
          // return (index i, X v)
              // i is the index in [a, n)^[l, r) s.t query(a, i+1) is ok but query(a, i) isn't ok. if such i does not exist, i = n
              // v is the value s.t query(a, r)
  
          propagate(k);
          if (r <= a) return {n, ex};  // 区間が全く被っていない
          else if (a <= l && !is_ok(merge(left_value, dat[k]))) return {n, merge(left_value, dat[k])};
          else if (k >= N-1) return {k - (N-1), merge(left_value, dat[k])};
          else{
              auto [vl, xl] = _find_most_left(a, is_ok, 2 * k + 1, l, (l + r) / 2, left_value);
              if (vl != n) return {vl, xl};
              auto [vr, xr] = _find_most_left(a, is_ok, 2 * k + 2, (l + r) / 2, r, xl);
              return {vr, xr};
          }
      }
  
      index find_most_right(index r, const function<bool(X)>& is_ok){
          // rから左に探していってis_okが初めて成り立つようなindexを返す。
          // assume query(*, r) has monotonity
          // return index i s.t is_ok(query(i+1, r+1)) does not holds, but is_ok(query(i, r+1)) does.
          // if such i does not exist, return -1
          index res = _find_most_right(r+1, is_ok, 0, 0, N, ex).first;
          assert(res <= r);
          return res;
      }
      pair<index, X> _find_most_right(index b, const function<bool(X)>& is_ok, int k, index l, index r, X right_value){
          propagate(k);
          if (b <= l) return {-1, ex};  // 区間が全く被っていない
          else if (r <= b && !is_ok(merge(dat[k], right_value))) return {-1, merge(dat[k], right_value)};
          else if (k >= N-1) return {k - (N-1), merge(dat[k], right_value)};
          else{
              auto [vr, xr] = _find_most_right(b, is_ok, 2 * k + 2, (l + r) / 2, r, right_value);
              if (vr != -1) return {vr, xr};
              auto [vl, xl] = _find_most_right(b, is_ok, 2 * k + 1, l, (l + r) / 2, xr);
              return {vl, xl};
          }
      }
  
      /* debug */
      inline X operator[](int i) { return query(i, i + 1); }
  
      #if defined(PCM) || defined(LOCAL)
      friend ostream& operator<<(ostream& os, segment_tree_lazy& sg) {  //
          os << "[";
          for (int i = 0; i < sg.n; i++) {
              os << sg[i] << (i == sg.n - 1 ? "]\n" : ", ");
          }
          return os;
      }
      #endif
  };
  // Regarding apply and merge, the conditions below should holds.
  // apply(merge(x1, x2), m) = merge(apply(x1, m), apply(x2, m))
  // apply(apply(x, m1), m2) = apply(x, composition(m1, m2))
  // composition(m, em) = m && composition(em, m) = m && apply(x, em) = x
  // snippet:segment_tree_lazy }}}
  
  // snippet:make_lseg_rmq_ruq {{{
  using X = ll; // (X, merge) is monoid
  using M = ll; // (M, composition) is monoid
  auto make_lseg_rmq_ruq(){
      auto merge = [](X x1, X x2){return min(x1,x2);};
      X ex = numeric_limits<X>::max();
      M em = numeric_limits<M>::max();
      auto composition = [em](M m1, M m2){ 
          if (m1 == em) return m2;
          if (m2 == em) return m1;
          return m2;
      };
      auto apply = [em](X x, M m){return (m==em ? x : m);};
      return segment_tree_lazy<X, M>(merge, apply, composition, ex, em);
  }
  // auto lseg = make_lseg_rmq_ruq();
  // lseg.build(a);
  //   or
  // lseg.build(vector<X>(n, <初期値>);
  // snippet:make_lseg_rmq_ruq }}}


snippet make_lseg_rsq_raq
alias rsq_raq
  // snippet:segment_tree_lazy {{{
  template <typename X, typename M>
  struct segment_tree_lazy {
      using FX = function<X(X, X)>;
      using FA = function<X(X, M)>;
      using FM = function<M(M, M)>;
      using index = int;
      int n;  // 元の配列のサイズ
      int N;  // n以上の最小の2冪
      FX merge;
      FA apply;
      FM composite;
      const X ex;
      const M em;
      vector<X> dat;
      vector<M> lazy;
      segment_tree_lazy(FX merge_, FA apply_, FM composite_, X ex_, M em_)
          : merge(merge_), apply(apply_), composite(composite_), ex(ex_), em(em_) {
      }
  
      void set(index i, X x) { dat[i + n - 1] = x; }
      void init(index n_) { 
          N = 1;
          n = n_;
          while (N < n_) N <<= 1;
          dat.assign(2 * N, ex);
          lazy.assign(2 * N, em);
      } 
  
      void build(const vector<X> &v) { 
          int n_ = v.size();
          init(n_);
          for (int i = 0; i < n_; i++) dat[i + N - 1] = v[i];
          for (int k = N - 2; k >= 0; k--) dat[k] = merge(dat[2 * k + 1], dat[2 * k + 2]);
      } 
  
      /* lazy propagate */
      void propagate(int k) {
          if (lazy[k] == em) return;  // 更新するものが無ければ終了
          if (k < N - 1) {            // 葉でなければ子に伝搬
              lazy[k * 2 + 1] = composite(lazy[k * 2 + 1], lazy[k]);
              lazy[k * 2 + 2] = composite(lazy[k * 2 + 2], lazy[k]);
          }
          // 自身を更新
          dat[k] = apply(dat[k], lazy[k]);
          lazy[k] = em;
      }
  
      void update(index a, index b, M x) { update(a, b, x, 0, 0, N); }
      void update(index a, index b, M x, int k, index l, index r) {
          if (a <= l && r <= b) {  // 完全に内側の時
              lazy[k] = composite(lazy[k], x);
              propagate(k);
          }
          else if (a < r && l < b) {                     // 一部区間が被る時
              propagate(k);
              update(a, b, x, k * 2 + 1, l, (l + r) / 2);  // 左の子
              update(a, b, x, k * 2 + 2, (l + r) / 2, r);  // 右の子
              dat[k] = merge(dat[k * 2 + 1], dat[k * 2 + 2]);
          }
          else{
              propagate(k);
          }
      }
  
      X query(index a, index b) { return query_sub(a, b, 0, 0, N); }
      X query_sub(index a, index b, int k, index l, index r) {
          propagate(k);
          if (r <= a || b <= l) {  // 完全に外側の時
              return ex;
          }
          else if (a <= l && r <= b) {  // 完全に内側の時
              return dat[k];
          }
          else {  // 一部区間が被る時
              X lv = query_sub(a, b, k * 2 + 1, l, (l + r) / 2);
              X rv = query_sub(a, b, k * 2 + 2, (l + r) / 2, r);
              return merge(lv, rv);
          }
      }
  
      index find_most_left(index l, const function<bool(X)>& is_ok){
          // lから右に探していってis_okが初めて成り立つようなindexを返す。
          // assume query(l, *) has monotonity
          // return index i s.t is_ok(query(l, i)) does not holds, but is_ok(query(l, i+1)) does.
          // if such i does not exist, return n
          index res = _find_most_left(l, is_ok, 0, 0, N, ex).first;
          assert(l <= res);
          return res;
      }
      pair<index, X> _find_most_left(index a, const function<bool(X)>& is_ok, int k, index l, index r, X left_value){
          // params:
              // left_value = (a < l ? query(a, l) : ex)
          // return (index i, X v)
              // i is the index in [a, n)^[l, r) s.t query(a, i+1) is ok but query(a, i) isn't ok. if such i does not exist, i = n
              // v is the value s.t query(a, r)
  
          propagate(k);
          if (r <= a) return {n, ex};  // 区間が全く被っていない
          else if (a <= l && !is_ok(merge(left_value, dat[k]))) return {n, merge(left_value, dat[k])};
          else if (k >= N-1) return {k - (N-1), merge(left_value, dat[k])};
          else{
              auto [vl, xl] = _find_most_left(a, is_ok, 2 * k + 1, l, (l + r) / 2, left_value);
              if (vl != n) return {vl, xl};
              auto [vr, xr] = _find_most_left(a, is_ok, 2 * k + 2, (l + r) / 2, r, xl);
              return {vr, xr};
          }
      }
  
      index find_most_right(index r, const function<bool(X)>& is_ok){
          // rから左に探していってis_okが初めて成り立つようなindexを返す。
          // assume query(*, r) has monotonity
          // return index i s.t is_ok(query(i+1, r+1)) does not holds, but is_ok(query(i, r+1)) does.
          // if such i does not exist, return -1
          index res = _find_most_right(r+1, is_ok, 0, 0, N, ex).first;
          assert(res <= r);
          return res;
      }
      pair<index, X> _find_most_right(index b, const function<bool(X)>& is_ok, int k, index l, index r, X right_value){
          propagate(k);
          if (b <= l) return {-1, ex};  // 区間が全く被っていない
          else if (r <= b && !is_ok(merge(dat[k], right_value))) return {-1, merge(dat[k], right_value)};
          else if (k >= N-1) return {k - (N-1), merge(dat[k], right_value)};
          else{
              auto [vr, xr] = _find_most_right(b, is_ok, 2 * k + 2, (l + r) / 2, r, right_value);
              if (vr != -1) return {vr, xr};
              auto [vl, xl] = _find_most_right(b, is_ok, 2 * k + 1, l, (l + r) / 2, xr);
              return {vl, xl};
          }
      }
  
      /* debug */
      inline X operator[](int i) { return query(i, i + 1); }
  
      #if defined(PCM) || defined(LOCAL)
      friend ostream& operator<<(ostream& os, segment_tree_lazy& sg) {  //
          os << "[";
          for (int i = 0; i < sg.n; i++) {
              os << sg[i] << (i == sg.n - 1 ? "]\n" : ", ");
          }
          return os;
      }
      #endif
  };
  // Regarding apply and merge, the conditions below should holds.
  // apply(merge(x1, x2), m) = merge(apply(x1, m), apply(x2, m))
  // apply(apply(x, m1), m2) = apply(x, composition(m1, m2))
  // composition(m, em) = m && composition(em, m) = m && apply(x, em) = x
  // snippet:segment_tree_lazy }}}
  
  // snippet:monoid_with_len {{{
  template<class T>
  struct monoid_with_len {
      T x;
      int len;
      monoid_with_len(){};
      monoid_with_len(T x_, ll len_) : x(x_), len(len_){};
  };
  template<class T>
  monoid_with_len<T> operator+(monoid_with_len<T> a, monoid_with_len<T> b){
      return monoid_with_len<T>(a.x + b.x, a.len + b.len);
  }
  // snippet:monoid_with_len }}}
  
  // snippet:make_lseg_rsq_raq {{{
  using X = monoid_with_len<ll>; // (X, merge) is monoid
  using M = ll; // (M, composition) is monoid
  auto make_lseg_rsq_raq(){
      auto merge = [](X x1, X x2){return x1 + x2;};
      X ex = X(0, 0);
      M em = 0;
      auto composition = [](M m1, M m2){ return m1 + m2; };
      auto apply = [](X x, M m){return X(x.x + m*x.len, x.len);};
      return segment_tree_lazy<X, M>(merge, apply, composition, ex, em);
  }
  // auto lseg = make_lseg_rsq_raq();
  // lseg.build(vector<X>(sz, X(<初期値>, 1))); // X(*, 1)を入れないといけないことに注意する。
  // snippet:make_lseg_rsq_raq }}}


snippet monoid_with_len
  // snippet:monoid_with_len {{{
  template<class T>
  struct monoid_with_len {
      T x;
      int len;
      monoid_with_len(){};
      monoid_with_len(T x_, ll len_) : x(x_), len(len_){};
  };
  template<class T>
  monoid_with_len<T> operator+(monoid_with_len<T> a, monoid_with_len<T> b){
      return monoid_with_len<T>(a.x + b.x, a.len + b.len);
  }
  // snippet:monoid_with_len }}}


snippet make_lseg_rsq_raffinq
alias rsq_raffinq
  // snippet:segment_tree_lazy {{{
  template <typename X, typename M>
  struct segment_tree_lazy {
      using FX = function<X(X, X)>;
      using FA = function<X(X, M)>;
      using FM = function<M(M, M)>;
      using index = int;
      int n;  // 元の配列のサイズ
      int N;  // n以上の最小の2冪
      FX merge;
      FA apply;
      FM composite;
      const X ex;
      const M em;
      vector<X> dat;
      vector<M> lazy;
      segment_tree_lazy(FX merge_, FA apply_, FM composite_, X ex_, M em_)
          : merge(merge_), apply(apply_), composite(composite_), ex(ex_), em(em_) {
      }
  
      void set(index i, X x) { dat[i + n - 1] = x; }
      void init(index n_) { 
          N = 1;
          n = n_;
          while (N < n_) N <<= 1;
          dat.assign(2 * N, ex);
          lazy.assign(2 * N, em);
      } 
  
      void build(const vector<X> &v) { 
          int n_ = v.size();
          init(n_);
          for (int i = 0; i < n_; i++) dat[i + N - 1] = v[i];
          for (int k = N - 2; k >= 0; k--) dat[k] = merge(dat[2 * k + 1], dat[2 * k + 2]);
      } 
  
      /* lazy propagate */
      void propagate(int k) {
          if (lazy[k] == em) return;  // 更新するものが無ければ終了
          if (k < N - 1) {            // 葉でなければ子に伝搬
              lazy[k * 2 + 1] = composite(lazy[k * 2 + 1], lazy[k]);
              lazy[k * 2 + 2] = composite(lazy[k * 2 + 2], lazy[k]);
          }
          // 自身を更新
          dat[k] = apply(dat[k], lazy[k]);
          lazy[k] = em;
      }
  
      void update(index a, index b, M x) { update(a, b, x, 0, 0, N); }
      void update(index a, index b, M x, int k, index l, index r) {
          if (a <= l && r <= b) {  // 完全に内側の時
              lazy[k] = composite(lazy[k], x);
              propagate(k);
          }
          else if (a < r && l < b) {                     // 一部区間が被る時
              propagate(k);
              update(a, b, x, k * 2 + 1, l, (l + r) / 2);  // 左の子
              update(a, b, x, k * 2 + 2, (l + r) / 2, r);  // 右の子
              dat[k] = merge(dat[k * 2 + 1], dat[k * 2 + 2]);
          }
          else{
              propagate(k);
          }
      }
  
      X query(index a, index b) { return query_sub(a, b, 0, 0, N); }
      X query_sub(index a, index b, int k, index l, index r) {
          propagate(k);
          if (r <= a || b <= l) {  // 完全に外側の時
              return ex;
          }
          else if (a <= l && r <= b) {  // 完全に内側の時
              return dat[k];
          }
          else {  // 一部区間が被る時
              X lv = query_sub(a, b, k * 2 + 1, l, (l + r) / 2);
              X rv = query_sub(a, b, k * 2 + 2, (l + r) / 2, r);
              return merge(lv, rv);
          }
      }
  
      index find_most_left(index l, const function<bool(X)>& is_ok){
          // lから右に探していってis_okが初めて成り立つようなindexを返す。
          // assume query(l, *) has monotonity
          // return index i s.t is_ok(query(l, i)) does not holds, but is_ok(query(l, i+1)) does.
          // if such i does not exist, return n
          index res = _find_most_left(l, is_ok, 0, 0, N, ex).first;
          assert(l <= res);
          return res;
      }
      pair<index, X> _find_most_left(index a, const function<bool(X)>& is_ok, int k, index l, index r, X left_value){
          // params:
              // left_value = (a < l ? query(a, l) : ex)
          // return (index i, X v)
              // i is the index in [a, n)^[l, r) s.t query(a, i+1) is ok but query(a, i) isn't ok. if such i does not exist, i = n
              // v is the value s.t query(a, r)
  
          propagate(k);
          if (r <= a) return {n, ex};  // 区間が全く被っていない
          else if (a <= l && !is_ok(merge(left_value, dat[k]))) return {n, merge(left_value, dat[k])};
          else if (k >= N-1) return {k - (N-1), merge(left_value, dat[k])};
          else{
              auto [vl, xl] = _find_most_left(a, is_ok, 2 * k + 1, l, (l + r) / 2, left_value);
              if (vl != n) return {vl, xl};
              auto [vr, xr] = _find_most_left(a, is_ok, 2 * k + 2, (l + r) / 2, r, xl);
              return {vr, xr};
          }
      }
  
      index find_most_right(index r, const function<bool(X)>& is_ok){
          // rから左に探していってis_okが初めて成り立つようなindexを返す。
          // assume query(*, r) has monotonity
          // return index i s.t is_ok(query(i+1, r+1)) does not holds, but is_ok(query(i, r+1)) does.
          // if such i does not exist, return -1
          index res = _find_most_right(r+1, is_ok, 0, 0, N, ex).first;
          assert(res <= r);
          return res;
      }
      pair<index, X> _find_most_right(index b, const function<bool(X)>& is_ok, int k, index l, index r, X right_value){
          propagate(k);
          if (b <= l) return {-1, ex};  // 区間が全く被っていない
          else if (r <= b && !is_ok(merge(dat[k], right_value))) return {-1, merge(dat[k], right_value)};
          else if (k >= N-1) return {k - (N-1), merge(dat[k], right_value)};
          else{
              auto [vr, xr] = _find_most_right(b, is_ok, 2 * k + 2, (l + r) / 2, r, right_value);
              if (vr != -1) return {vr, xr};
              auto [vl, xl] = _find_most_right(b, is_ok, 2 * k + 1, l, (l + r) / 2, xr);
              return {vl, xl};
          }
      }
  
      /* debug */
      inline X operator[](int i) { return query(i, i + 1); }
  
      #if defined(PCM) || defined(LOCAL)
      friend ostream& operator<<(ostream& os, segment_tree_lazy& sg) {  //
          os << "[";
          for (int i = 0; i < sg.n; i++) {
              os << sg[i] << (i == sg.n - 1 ? "]\n" : ", ");
          }
          return os;
      }
      #endif
  };
  // Regarding apply and merge, the conditions below should holds.
  // apply(merge(x1, x2), m) = merge(apply(x1, m), apply(x2, m))
  // apply(apply(x, m1), m2) = apply(x, composition(m1, m2))
  // composition(m, em) = m && composition(em, m) = m && apply(x, em) = x
  // snippet:segment_tree_lazy }}}
  
  // snippet:monoid_with_len {{{
  template<class T>
  struct monoid_with_len {
      T x;
      int len;
      monoid_with_len(){};
      monoid_with_len(T x_, ll len_) : x(x_), len(len_){};
  };
  template<class T>
  monoid_with_len<T> operator+(monoid_with_len<T> a, monoid_with_len<T> b){
      return monoid_with_len<T>(a.x + b.x, a.len + b.len);
  }
  // snippet:monoid_with_len }}}
  
  // snippet:monoid_affin_transformation {{{
  struct monoid_affin_transformation {
      mint a, b;
      monoid_affin_transformation(){};
      monoid_affin_transformation(mint a_, mint b_) : a(a_), b(b_){};
  };
  monoid_affin_transformation operator+(monoid_affin_transformation x, monoid_affin_transformation y){
      return monoid_affin_transformation(x.a * y.a, x.b * y.a + y.b);
  }
  bool operator==(monoid_affin_transformation m1, monoid_affin_transformation m2) {
      return m1.a == m2.a && m1.b == m2.b;
  }
  // snippet:monoid_affin_transformation }}}
  
  // snippet:make_lseg_rsq_raffinq {{{
  using X = monoid_with_len<mint>; // (X, merge) is monoid
  using M = monoid_affin_transformation; // (M, composition) is monoid
  auto make_lseg_rsq_raffinq(){
      auto merge = [](X x1, X x2){return x1 + x2;};
      X ex = X(0, 0);
      M em = M(1, 0);
      auto composition = [](M m1, M m2){ return m1 + m2; };
      auto apply = [](X x, M m){return X(x.x*m.a + m.b*x.len, x.len);};
      return segment_tree_lazy<X, M>(merge, apply, composition, ex, em);
  }
  // auto lseg = make_lseg_rsq_raffinq();
  // lseg.build(vector<X>(sz, X(<初期値>, 1))); // X(*, 1)を入れないといけないことに注意する。
  // snippet:make_lseg_rsq_raffinq }}}


snippet make_lseg_rsq_ruq
alias rsq_ruq
  // snippet:segment_tree_lazy {{{
  template <typename X, typename M>
  struct segment_tree_lazy {
      using FX = function<X(X, X)>;
      using FA = function<X(X, M)>;
      using FM = function<M(M, M)>;
      using index = int;
      int n;  // 元の配列のサイズ
      int N;  // n以上の最小の2冪
      FX merge;
      FA apply;
      FM composite;
      const X ex;
      const M em;
      vector<X> dat;
      vector<M> lazy;
      segment_tree_lazy(FX merge_, FA apply_, FM composite_, X ex_, M em_)
          : merge(merge_), apply(apply_), composite(composite_), ex(ex_), em(em_) {
      }
  
      void set(index i, X x) { dat[i + n - 1] = x; }
      void init(index n_) { 
          N = 1;
          n = n_;
          while (N < n_) N <<= 1;
          dat.assign(2 * N, ex);
          lazy.assign(2 * N, em);
      } 
  
      void build(const vector<X> &v) { 
          int n_ = v.size();
          init(n_);
          for (int i = 0; i < n_; i++) dat[i + N - 1] = v[i];
          for (int k = N - 2; k >= 0; k--) dat[k] = merge(dat[2 * k + 1], dat[2 * k + 2]);
      } 
  
      /* lazy propagate */
      void propagate(int k) {
          if (lazy[k] == em) return;  // 更新するものが無ければ終了
          if (k < N - 1) {            // 葉でなければ子に伝搬
              lazy[k * 2 + 1] = composite(lazy[k * 2 + 1], lazy[k]);
              lazy[k * 2 + 2] = composite(lazy[k * 2 + 2], lazy[k]);
          }
          // 自身を更新
          dat[k] = apply(dat[k], lazy[k]);
          lazy[k] = em;
      }
  
      void update(index a, index b, M x) { update(a, b, x, 0, 0, N); }
      void update(index a, index b, M x, int k, index l, index r) {
          if (a <= l && r <= b) {  // 完全に内側の時
              lazy[k] = composite(lazy[k], x);
              propagate(k);
          }
          else if (a < r && l < b) {                     // 一部区間が被る時
              propagate(k);
              update(a, b, x, k * 2 + 1, l, (l + r) / 2);  // 左の子
              update(a, b, x, k * 2 + 2, (l + r) / 2, r);  // 右の子
              dat[k] = merge(dat[k * 2 + 1], dat[k * 2 + 2]);
          }
          else{
              propagate(k);
          }
      }
  
      X query(index a, index b) { return query_sub(a, b, 0, 0, N); }
      X query_sub(index a, index b, int k, index l, index r) {
          propagate(k);
          if (r <= a || b <= l) {  // 完全に外側の時
              return ex;
          }
          else if (a <= l && r <= b) {  // 完全に内側の時
              return dat[k];
          }
          else {  // 一部区間が被る時
              X lv = query_sub(a, b, k * 2 + 1, l, (l + r) / 2);
              X rv = query_sub(a, b, k * 2 + 2, (l + r) / 2, r);
              return merge(lv, rv);
          }
      }
  
      index find_most_left(index l, const function<bool(X)>& is_ok){
          // lから右に探していってis_okが初めて成り立つようなindexを返す。
          // assume query(l, *) has monotonity
          // return index i s.t is_ok(query(l, i)) does not holds, but is_ok(query(l, i+1)) does.
          // if such i does not exist, return n
          index res = _find_most_left(l, is_ok, 0, 0, N, ex).first;
          assert(l <= res);
          return res;
      }
      pair<index, X> _find_most_left(index a, const function<bool(X)>& is_ok, int k, index l, index r, X left_value){
          // params:
              // left_value = (a < l ? query(a, l) : ex)
          // return (index i, X v)
              // i is the index in [a, n)^[l, r) s.t query(a, i+1) is ok but query(a, i) isn't ok. if such i does not exist, i = n
              // v is the value s.t query(a, r)
  
          propagate(k);
          if (r <= a) return {n, ex};  // 区間が全く被っていない
          else if (a <= l && !is_ok(merge(left_value, dat[k]))) return {n, merge(left_value, dat[k])};
          else if (k >= N-1) return {k - (N-1), merge(left_value, dat[k])};
          else{
              auto [vl, xl] = _find_most_left(a, is_ok, 2 * k + 1, l, (l + r) / 2, left_value);
              if (vl != n) return {vl, xl};
              auto [vr, xr] = _find_most_left(a, is_ok, 2 * k + 2, (l + r) / 2, r, xl);
              return {vr, xr};
          }
      }
  
      index find_most_right(index r, const function<bool(X)>& is_ok){
          // rから左に探していってis_okが初めて成り立つようなindexを返す。
          // assume query(*, r) has monotonity
          // return index i s.t is_ok(query(i+1, r+1)) does not holds, but is_ok(query(i, r+1)) does.
          // if such i does not exist, return -1
          index res = _find_most_right(r+1, is_ok, 0, 0, N, ex).first;
          assert(res <= r);
          return res;
      }
      pair<index, X> _find_most_right(index b, const function<bool(X)>& is_ok, int k, index l, index r, X right_value){
          propagate(k);
          if (b <= l) return {-1, ex};  // 区間が全く被っていない
          else if (r <= b && !is_ok(merge(dat[k], right_value))) return {-1, merge(dat[k], right_value)};
          else if (k >= N-1) return {k - (N-1), merge(dat[k], right_value)};
          else{
              auto [vr, xr] = _find_most_right(b, is_ok, 2 * k + 2, (l + r) / 2, r, right_value);
              if (vr != -1) return {vr, xr};
              auto [vl, xl] = _find_most_right(b, is_ok, 2 * k + 1, l, (l + r) / 2, xr);
              return {vl, xl};
          }
      }
  
      /* debug */
      inline X operator[](int i) { return query(i, i + 1); }
  
      #if defined(PCM) || defined(LOCAL)
      friend ostream& operator<<(ostream& os, segment_tree_lazy& sg) {  //
          os << "[";
          for (int i = 0; i < sg.n; i++) {
              os << sg[i] << (i == sg.n - 1 ? "]\n" : ", ");
          }
          return os;
      }
      #endif
  };
  // Regarding apply and merge, the conditions below should holds.
  // apply(merge(x1, x2), m) = merge(apply(x1, m), apply(x2, m))
  // apply(apply(x, m1), m2) = apply(x, composition(m1, m2))
  // composition(m, em) = m && composition(em, m) = m && apply(x, em) = x
  // snippet:segment_tree_lazy }}}
  
  // snippet:monoid_with_len {{{
  template<class T>
  struct monoid_with_len {
      T x;
      int len;
      monoid_with_len(){};
      monoid_with_len(T x_, ll len_) : x(x_), len(len_){};
  };
  template<class T>
  monoid_with_len<T> operator+(monoid_with_len<T> a, monoid_with_len<T> b){
      return monoid_with_len<T>(a.x + b.x, a.len + b.len);
  }
  // snippet:monoid_with_len }}}
  
  // snippet:make_lseg_rsq_ruq {{{
  using X = monoid_with_len<ll>; // (X, merge) is monoid
  using M = ll; // (M, composition) is monoid
  auto make_lseg_rsq_ruq(){
      auto merge = [](X x1, X x2){return x1 + x2;};
      X ex = X(0, 0);
      M em = numeric_limits<M>::max();
      auto composition = [em](M m1, M m2){ 
          if (m1 == em) return m2;
          if (m2 == em) return m1;
          return m2;
      };
      auto apply = [em](X x, M m){return (m==em ? x : X(m * x.len, x.len));};
      return segment_tree_lazy<X, M>(merge, apply, composition, ex, em);
  }
  // auto lseg = make_lseg_rsq_ruq();
  // lseg.build(vector<X>(sz, X(<初期値>, 1))); // X(*, 1)を入れないといけないことに注意する。
  // snippet:make_lseg_rsq_ruq }}}


snippet make_lseg_rmq_raq
alias rmq_raq
  // snippet:segment_tree_lazy {{{
  template <typename X, typename M>
  struct segment_tree_lazy {
      using FX = function<X(X, X)>;
      using FA = function<X(X, M)>;
      using FM = function<M(M, M)>;
      using index = int;
      int n;  // 元の配列のサイズ
      int N;  // n以上の最小の2冪
      FX merge;
      FA apply;
      FM composite;
      const X ex;
      const M em;
      vector<X> dat;
      vector<M> lazy;
      segment_tree_lazy(FX merge_, FA apply_, FM composite_, X ex_, M em_)
          : merge(merge_), apply(apply_), composite(composite_), ex(ex_), em(em_) {
      }
  
      void set(index i, X x) { dat[i + n - 1] = x; }
      void init(index n_) { 
          N = 1;
          n = n_;
          while (N < n_) N <<= 1;
          dat.assign(2 * N, ex);
          lazy.assign(2 * N, em);
      } 
  
      void build(const vector<X> &v) { 
          int n_ = v.size();
          init(n_);
          for (int i = 0; i < n_; i++) dat[i + N - 1] = v[i];
          for (int k = N - 2; k >= 0; k--) dat[k] = merge(dat[2 * k + 1], dat[2 * k + 2]);
      } 
  
      /* lazy propagate */
      void propagate(int k) {
          if (lazy[k] == em) return;  // 更新するものが無ければ終了
          if (k < N - 1) {            // 葉でなければ子に伝搬
              lazy[k * 2 + 1] = composite(lazy[k * 2 + 1], lazy[k]);
              lazy[k * 2 + 2] = composite(lazy[k * 2 + 2], lazy[k]);
          }
          // 自身を更新
          dat[k] = apply(dat[k], lazy[k]);
          lazy[k] = em;
      }
  
      void update(index a, index b, M x) { update(a, b, x, 0, 0, N); }
      void update(index a, index b, M x, int k, index l, index r) {
          if (a <= l && r <= b) {  // 完全に内側の時
              lazy[k] = composite(lazy[k], x);
              propagate(k);
          }
          else if (a < r && l < b) {                     // 一部区間が被る時
              propagate(k);
              update(a, b, x, k * 2 + 1, l, (l + r) / 2);  // 左の子
              update(a, b, x, k * 2 + 2, (l + r) / 2, r);  // 右の子
              dat[k] = merge(dat[k * 2 + 1], dat[k * 2 + 2]);
          }
          else{
              propagate(k);
          }
      }
  
      X query(index a, index b) { return query_sub(a, b, 0, 0, N); }
      X query_sub(index a, index b, int k, index l, index r) {
          propagate(k);
          if (r <= a || b <= l) {  // 完全に外側の時
              return ex;
          }
          else if (a <= l && r <= b) {  // 完全に内側の時
              return dat[k];
          }
          else {  // 一部区間が被る時
              X lv = query_sub(a, b, k * 2 + 1, l, (l + r) / 2);
              X rv = query_sub(a, b, k * 2 + 2, (l + r) / 2, r);
              return merge(lv, rv);
          }
      }
  
      index find_most_left(index l, const function<bool(X)>& is_ok){
          // lから右に探していってis_okが初めて成り立つようなindexを返す。
          // assume query(l, *) has monotonity
          // return index i s.t is_ok(query(l, i)) does not holds, but is_ok(query(l, i+1)) does.
          // if such i does not exist, return n
          index res = _find_most_left(l, is_ok, 0, 0, N, ex).first;
          assert(l <= res);
          return res;
      }
      pair<index, X> _find_most_left(index a, const function<bool(X)>& is_ok, int k, index l, index r, X left_value){
          // params:
              // left_value = (a < l ? query(a, l) : ex)
          // return (index i, X v)
              // i is the index in [a, n)^[l, r) s.t query(a, i+1) is ok but query(a, i) isn't ok. if such i does not exist, i = n
              // v is the value s.t query(a, r)
  
          propagate(k);
          if (r <= a) return {n, ex};  // 区間が全く被っていない
          else if (a <= l && !is_ok(merge(left_value, dat[k]))) return {n, merge(left_value, dat[k])};
          else if (k >= N-1) return {k - (N-1), merge(left_value, dat[k])};
          else{
              auto [vl, xl] = _find_most_left(a, is_ok, 2 * k + 1, l, (l + r) / 2, left_value);
              if (vl != n) return {vl, xl};
              auto [vr, xr] = _find_most_left(a, is_ok, 2 * k + 2, (l + r) / 2, r, xl);
              return {vr, xr};
          }
      }
  
      index find_most_right(index r, const function<bool(X)>& is_ok){
          // rから左に探していってis_okが初めて成り立つようなindexを返す。
          // assume query(*, r) has monotonity
          // return index i s.t is_ok(query(i+1, r+1)) does not holds, but is_ok(query(i, r+1)) does.
          // if such i does not exist, return -1
          index res = _find_most_right(r+1, is_ok, 0, 0, N, ex).first;
          assert(res <= r);
          return res;
      }
      pair<index, X> _find_most_right(index b, const function<bool(X)>& is_ok, int k, index l, index r, X right_value){
          propagate(k);
          if (b <= l) return {-1, ex};  // 区間が全く被っていない
          else if (r <= b && !is_ok(merge(dat[k], right_value))) return {-1, merge(dat[k], right_value)};
          else if (k >= N-1) return {k - (N-1), merge(dat[k], right_value)};
          else{
              auto [vr, xr] = _find_most_right(b, is_ok, 2 * k + 2, (l + r) / 2, r, right_value);
              if (vr != -1) return {vr, xr};
              auto [vl, xl] = _find_most_right(b, is_ok, 2 * k + 1, l, (l + r) / 2, xr);
              return {vl, xl};
          }
      }
  
      /* debug */
      inline X operator[](int i) { return query(i, i + 1); }
  
      #if defined(PCM) || defined(LOCAL)
      friend ostream& operator<<(ostream& os, segment_tree_lazy& sg) {  //
          os << "[";
          for (int i = 0; i < sg.n; i++) {
              os << sg[i] << (i == sg.n - 1 ? "]\n" : ", ");
          }
          return os;
      }
      #endif
  };
  // Regarding apply and merge, the conditions below should holds.
  // apply(merge(x1, x2), m) = merge(apply(x1, m), apply(x2, m))
  // apply(apply(x, m1), m2) = apply(x, composition(m1, m2))
  // composition(m, em) = m && composition(em, m) = m && apply(x, em) = x
  // snippet:segment_tree_lazy }}}
  
  // snippet:make_lseg_rmq_raq {{{
  using X = ll; // (X, merge) is monoid
  using M = ll; // (M, composition) is monoid
  auto make_lseg_rmq_raq(){
      auto merge = [](X x1, X x2){return min(x1,x2);};
      X ex = numeric_limits<X>::max();
      auto composition = [](M m1, M m2){return m1 + m2;};
      M em = 0;
      auto apply = [](X x, M m){return x + m;};
      return segment_tree_lazy<X, M>(merge, apply, composition, ex, em);
  }
  // auto lseg = make_lseg_rmq_raq();
  // lseg.build(a);
  //   or
  // lseg.build(vector<X>(n, <初期値>);
  // snippet:make_lseg_rmq_raq }}}


snippet make_lseg_getone_chmin
alias getone_chmin
  // snippet:make_lseg_getone_chmin {{{
  using X = ll; // (X, merge) is monoid // 双対セグメント木として使う時は適当なモノイドを入れておけば良い。
  using M = ll; // (M, composition) is monoid
  auto make_lseg_getone_chmin(){
      auto merge = [](X x1, X x2){return min(x1,x2);};
      X ex = numeric_limits<X>::max();
      M em = numeric_limits<M>::max();
      auto composition = [](M m1, M m2){return min(m1, m2);};
      auto apply = [](X x, M m){return min(x, m);};
      return segment_tree_lazy<X, M>(merge, apply, composition, ex, em);
  }
  // snippet:make_lseg_getone_chmin }}}


snippet monoid_affin_transformation
  // snippet:monoid_affin_transformation {{{
  struct monoid_affin_transformation {
      mint a, b;
      monoid_affin_transformation(){};
      monoid_affin_transformation(mint a_, mint b_) : a(a_), b(b_){};
  };
  monoid_affin_transformation operator+(monoid_affin_transformation x, monoid_affin_transformation y){
      return monoid_affin_transformation(x.a * y.a, x.b * y.a + y.b);
  }
  bool operator==(monoid_affin_transformation m1, monoid_affin_transformation m2) {
      return m1.a == m2.a && m1.b == m2.b;
  }
  // snippet:monoid_affin_transformation }}}


snippet shifter
  struct shifter{
      ll n, min_v;
      shifter(ll _min_v, ll _max_v): min_v(_min_v){
          n = _max_v - min_v;
      }
      ll operator()(ll x) { return x - min_v; }
      ll unshift(ll sx) { return sx + min_v; }
  };
  // How to use
      // auto sh = shifter(-10000, 10000);
      // vl x(sh.n);
      // x[sh(-3)];


snippet zipper
  struct zipper {                             /*{{{*/
      // unordered_map<long long, int> zip_map;  // [2:0, 3:1, 5:2, 10:3] debugしづらい
      map<long long, int> zip_map;  // [2:0, 3:1, 5:2, 10:3]
      vector<long long> _unzipper;            // [2, 3, 5, 10]
      bool _is_build = false;
      int n = 0;
  
      zipper(long long inf_value = INF) { /*{{{*/
          _unzipper.push_back(-inf_value);
          _unzipper.push_back(inf_value);
      }                                                        /*}}}*/
      zipper(vector<long long> a, long long inf_value = INF) { /*{{{*/
          _unzipper = vector<long long>(sz(a));
          rep(i, sz(a)) { _unzipper[i] = a[i]; }
          _unzipper.push_back(-inf_value);
          _unzipper.push_back(inf_value);
          build();
      }                              /*}}}*/
      void add_value(long long lv) { /*{{{*/
          _unzipper.push_back(lv);
          _is_build = false;
      }              /*}}}*/
      void build() { /*{{{*/
          uni(_unzipper);
          zip_map.clear();
          n = sz(_unzipper);
          rep(i, n) { zip_map[_unzipper[i]] = i; }
          _is_build = true;
      }                              /*}}}*/
      vector<int> zip(vector<long long> lvs) { /*{{{*/
          if (!_is_build) assert(false);
          int n = sz(lvs);
          vector<int> res(n);
          rep(i, n) res[i] = zip_map[lvs[i]];
          return res;
      }                              /*}}}*/
      int zip(long long lv) { /*{{{*/
          if (!_is_build) assert(false);
          return zip_map[lv];
      }                                               /*}}}*/
      int operator()(long long lv) { return zip(lv); }
  
      long long unzip(int sv) { /*{{{*/
          if (!_is_build) assert(false);
          return _unzipper[sv];
      }                              /*}}}*/
      int operator[](int sv) { return unzip(sv); }
  
      int size() {return n;}
  
  #if defined(PCM) || defined(LOCAL) /*{{{*/
      friend ostream& operator<<(ostream& os, const zipper& zp) {
          os << endl;
          os << "_is_build: " << zp._is_build << endl;
          os << "zip_map:   " << zp.zip_map << endl;
          os << "_unzipper:   " << zp._unzipper << endl;
          return os;
      }
  #endif /*}}}*/
  };     /*}}}*/
  // How to use {{{
  // construct
  // auto z = zipper(x); // x: vector<long long>;
  // auto z = zipper(x, 30*INF);
  
  // auto z = zipper();
  // z.add_value(3);
  // z.add_value(5);
  // z.add_value(10);
  // z.add_value(100000000);
  // z.build();
  
  // other method
  // z(x[i]); -> zipped x[i]
  // z.unzip(z(x[i])) -> x[i];
  // z.zip(ll x) -> zipped x
  // z.zip(vl v) -> zipped v
  // }}}


snippet hakidasi_xor
  vector<ll> hakidasi_xor(vector<ll>& a){
      int r = 0;
      int n = sz(a);
      r_rep(d, 0, 64){
          int p = -1;
          rep(i, r, n) {
              if (a[i]>>d&1) {
                  p = i;
              }
          }
          if (p == -1) continue;
  
          swap(a[r], a[p]);
          rep(i, n){
              if (a[i]>>d&1 && i!=r) a[i] ^= a[r];
          }
          r++;
      }
      vector<ll> res;
      rep(i, r) res.pb(a[i]);
      return res;
  }


snippet combination
  int mod = 1e9 + 7;
  // int mod = 998244353;
  struct mint {  //{{{
      ll x;
      mint(ll x = 0) : x((x % mod + mod) % mod) {}
  
      // ?= operator
      mint& operator+=(const mint a) {
          (x += a.x) %= mod;
          return *this;
      }
      mint& operator-=(const mint a) {
          (x += mod - a.x) %= mod;
          return *this;
      }
      mint& operator*=(const mint a) {
          (x *= a.x) %= mod;
          return *this;
      }
      mint& operator/=(const mint& rhs) {
          if (rhs.x == 0) throw runtime_error("mint zero division");
          return *this *= rhs.inv();
      }
  
      mint operator+(const mint a) const {
          mint res(*this);
          return res += a;
      }
      mint operator-(const mint a) const {
          mint res(*this);
          return res -= a;
      }
      mint operator*(const mint a) const {
          mint res(*this);
          return res *= a;
      }
      mint operator/(const mint a) const {
          mint res(*this);
          return res /= a;
      }
  
      mint pow(ll n) const {
          mint res(1), x(*this);
          if (n < 0) {
              n = -n;
              x = (*this).inv();
          }
          while (n) {
              if (n & 1) res *= x;
              x *= x;
              n >>= 1;
          }
          return res;
      }
  
      mint inv() const {
          if (x == 0) throw runtime_error("inv does not exist");
          return pow(mod - 2);
      }
      // mint inv()const{
      //     int x,y;
      //     int g=extgcd(v,mod,x,y);
      //     assert(g==1);
      //     if(x<0)x+=mod;
      //     return mint(x);
      // }
  
      bool operator<(const mint& r) const { return x < r.x; }
      bool operator==(const mint& r) const { return x == r.x; }
  };
  istream& operator>>(istream& is, const mint& a) { return is >> a.x; }
  ostream& operator<<(ostream& os, const mint& a) { return os << a.x; }
  //}}}
  
  struct combination {  // {{{
      vector<mint> fact, ifact;
      combination(int n) : fact(n + 1), ifact(n + 1) {
          assert(n < mod);
          fact[0] = 1;
          for (int i = 1; i <= n; ++i) fact[i] = fact[i - 1] * i;
          ifact[n] = fact[n].inv();
          for (int i = n; i >= 1; --i) ifact[i - 1] = ifact[i] * i;
      }
      mint operator()(int n, int k) {
          if (k < 0 || k > n) return 0;
          return fact[n] * ifact[k] * ifact[n - k];
      }
  }  // }}}
  com(500001);  // check this is enough


snippet matrix_pow
  // snippet:matrix_pow {{{
  template <class value = ll>
  using mat = vector<vector<value>>;
  
  template <class T>
  mat<T> mul(const mat<T>& A, const mat<T>& B) {
      mat<T> res(A.size(), vector<T>(B[0].size()));
      rep(i, A.size()) {
          rep(j, B[0].size()) {
              rep(k, B.size()) {
                  res[i][j] = (res[i][j] + A[i][k] * B[k][j]);
              }
          }
      }
      return res;
  }
  
  template <class T>
  mat<T> pow(mat<T> A, ll n) {
      mat<T> B(A.size(), vector<T>(A.size()));
      rep(i, A.size()) {
          B[i][i] = 1;  // E
      }
      while (n > 0) {
          if (n & 1) B = mul(B, A);
          A = mul(A, A);
          n >>= 1;
      }
      return B;
  }
  // snippet:matrix_pow }}}


snippet mint
  int mod = 1e9 + 7;
  // int mod = 998244353;
  struct mint {  //{{{
      ll x;
      mint(ll x = 0) : x((x % mod + mod) % mod) {}
  
      // ?= operator
      mint& operator+=(const mint a) {
          (x += a.x) %= mod;
          return *this;
      }
      mint& operator-=(const mint a) {
          (x += mod - a.x) %= mod;
          return *this;
      }
      mint& operator*=(const mint a) {
          (x *= a.x) %= mod;
          return *this;
      }
      mint& operator/=(const mint& rhs) {
          if (rhs.x == 0) throw runtime_error("mint zero division");
          return *this *= rhs.inv();
      }
  
      mint operator+(const mint a) const {
          mint res(*this);
          return res += a;
      }
      mint operator-(const mint a) const {
          mint res(*this);
          return res -= a;
      }
      mint operator*(const mint a) const {
          mint res(*this);
          return res *= a;
      }
      mint operator/(const mint a) const {
          mint res(*this);
          return res /= a;
      }
  
      mint pow(ll n) const {
          mint res(1), x(*this);
          if (n < 0) {
              n = -n;
              x = (*this).inv();
          }
          while (n) {
              if (n & 1) res *= x;
              x *= x;
              n >>= 1;
          }
          return res;
      }
  
      mint inv() const {
          if (x == 0) throw runtime_error("inv does not exist");
          return pow(mod - 2);
      }
      // mint inv()const{
      //     int x,y;
      //     int g=extgcd(v,mod,x,y);
      //     assert(g==1);
      //     if(x<0)x+=mod;
      //     return mint(x);
      // }
  
      bool operator<(const mint& r) const { return x < r.x; }
      bool operator==(const mint& r) const { return x == r.x; }
  };
  istream& operator>>(istream& is, const mint& a) { return is >> a.x; }
  ostream& operator<<(ostream& os, const mint& a) { return os << a.x; }
  //}}}


snippet rational
alias fraction
  // snippet:rational {{{
  template<class T=ll> 
  struct rational : public P2<T> {
      rational(){}
      rational(T _x, T _y) : P2<T>(_x, _y) {
          T g = gcd(this->x, this->y);
          this->x /= g; this->y /= g;
          if (this->y<0 or (this->y==0 && this->x==-1)) this->x *= -1, this->y *= -1;
      }
  };
  // rational(3, 5);
  // assert(rational(3, 5) == rational(-6, -10));
  // map<rational<ll>, int> cnt;  // keyにもできる。
  // snippet:rational }}}


snippet sieve
alias prime_factor_by_sieve
  // snippet:sieve {{{
  struct Sieve {/*{{{*/
      // エラトステネスのふるい O(NloglogN)
      ll n;                              // n: max number for defined f and primes
      vector<ll> f;                      // [-1, 2, 3, 2, 5, 2, 7, 2, 3, ....]
      vector<ll> primes;                 // [2, 3, 5, .......]
      Sieve(ll n = 1) : n(n), f(n + 1) { /*{{{*/
          f[0] = f[1] = -1;
          for (ll i = 2; i <= n; ++i) {
              if (f[i]) continue;
              primes.push_back(i);
              f[i] = i;
              for (ll j = i * i; j <= n; j += i) {
                  if (!f[j]) f[j] = i;
              }
          }
      } /*}}}*/
      bool is_prime(ll x) {
          if (x <= n) return f[x] == x; 
          return sz(factor_list(x)) == 1;
      }
  
      vector<ll> factor_list(ll x) { /*{{{*/
          assert(x <= n*n); // これが満たされないと正しく計算されない可能性がある。
  
          vector<ll> res;
          if (x <= n) {
              while (x != 1) {
                  res.push_back(f[x]);
                  x /= f[x];
              }
          }
          else {
              for (ll i = 0; primes[i] * primes[i] <= x; i++) {
                  while (x % primes[i] == 0) {
                      res.pb(primes[i]);
                      x /= primes[i];
                  }
              }
              if (x != 1) res.pb(x);
          }
  
          return res;  // [2, 3, 3, 5, 5, 5.....]
      }                /*}}}*/
  
      vector<pair<ll, ll>> prime_factor(ll x) { /*{{{*/
          // just change fl vector to map form
          vector<ll> fl = factor_list(x);
          if (fl.size() == 0) return {};
          vector<pair<ll, ll>> res = {mp(fl[0], 0)};
          for (ll p : fl) {
              if (res.back().first == p) {
                  res.back().second++;
              } else {
                  res.emplace_back(p, 1);
              }
          }
          return res;  // [(2,1), (3,2), (5,3), .....]
      }                /*}}}*/
  };/*}}}*/
  Sieve sv(1e6);
  // How to use
      // sv.primes            // 素数のリスト
      // sv.prime_factor(x);  // 素因数分解
  // snippet:sieve }}}


snippet mypow
alias pow
  template<class T>
  T mypow(T x, int n, T e = 1) {  // e : *の単位元
      // return x^n
      T res(e);
      while (n > 0) {
          if (n & 1) res *= x;
          x *= x;
          n >>= 1;
      }
      return res;
  }


snippet P2
alias pair
  template<class T=ll>/*{{{*/
  struct P2 {
      T x, y;
      P2(T _x, T _y) : x(_x), y(_y) {}
      P2() {
          x = 0;
          y = 0;
      }
      bool operator<(const P2 &r) const {
          return (x != r.x ? x < r.x : y < r.y);
      }
      bool operator>(const P2 &r) const {
          return (x != r.x ? x > r.x : y > r.y);
      }
      bool operator==(const P2 &r) const { return (x == r.x && y == r.y); }
  
      friend ostream &operator<<(ostream &stream, P2 p) {
          stream << "(" << p.x << "," << p.y << ")";
          return stream;
      }
  
      P2 operator-() const {  // 単項演算子
          return P2(-x, -y);
      }
  
      P2& operator+=(const P2<T>& r){
          x += r.x;
          y += r.y;
          return *this;
      }
      P2& operator-=(const P2<T>& r){
          x -= r.x;
          y -= r.y;
          return *this;
      }
      P2& operator+=(const T& r){
          x += r;
          y += r;
          return *this;
      }
      P2& operator-=(const T& r){
          x -= r;
          y -= r;
          return *this;
      }
      P2& operator*=(const P2<T>& r){
          x *= r.x;
          y *= r.y;
          return *this;
      }
      P2& operator/=(const P2<T>& r){
          x /= r.x;
          y /= r.y;
          return *this;
      }
      P2& operator*=(const T& r){
          x *= r;
          y *= r;
          return *this;
      }
      P2& operator/=(const T& r){
          x /= r;
          y /= r;
          return *this;
      }
  
      template<class U>
      P2 operator+(const U& r) const {
          P2 res(*this);
          return res += r;
      }
      template<class U>
      P2 operator-(const U& r) const {
          P2 res(*this);
          return res -= r;
      }
  
      template<class U>
      P2 operator*(const U& r) const {
          P2 res(*this);
          return res *= r;
      }
      template<class U>
      P2 operator/(const U& r) const {
          P2 res(*this);
          return res /= r;
      }
  
  
      bool in(T a, T b, T c, T d) {  // x in [a, b) && y in [c, d)
          if (a <= x && x < b && c <= y && y < d) return true;
          else return false;
      }
  
  };
  template<class T>
  long double dist(const P2<T>& p, const P2<T>& q){
      return sqrt((p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y));
  }
  
  /*}}}*/
  using P = P2<ll>;


snippet angle
  struct Angle{
      ll x, y; // 実際には10^9くらいまでしか入れられない。
      int _orthant;  // 象限
      Angle(){};
      Angle(ll _x, ll _y): x(_x), y(_y){
          assert(x != 0 || y != 0);
          ll g = gcd(abs(x), abs(y));
          x /= g;
          y /= g;
          if(y >= 0) _orthant = (x >= 0 ? 0 : 1);
          else _orthant = (x >= 0 ? 3 : 2);
      }
  
      bool operator<(const Angle &r) const {
          return (_orthant != r._orthant ? _orthant < r._orthant : x * r.y - y * r.x > 0);
      }
  
      bool operator==(const Angle &r) const { return (x == r.x && y == r.y); }
  
      long double operator-(const Angle& r) const {
          // rを起点に見て何度進んでいるかradianで返す
          return rad() - r.rad();
      }
  
      long double rad() const {
          long double r = atan2(y, x); 
          return (r<0 ? (r + M_PI*2.0) : r);
      }
      long double const deg(){ return rad() * 180.0/ M_PI; }
  
      Angle rot_90() const { return Angle(-y, x); }
  
      Angle rot_r90() const { return Angle(y, -x); }
  
      friend ostream &operator<<(ostream &stream, Angle p) {
          stream << "(" << p.x << "," << p.y << ")";
          return stream;
      }
  };


snippet AreaRect
  // snippet:AreaRect {{{
  class AreaRect { //(0,0)-(X,Y)の矩形の面積の総和
  	map<ll,ll> M;  // 矩形の右端を管理
  public:
  	ll sum;
  	AreaRect() {
  		M[0] = 1LL<<60;  // 番兵
  		M[1LL<<60] = 0;  // 番兵
  		sum = 0;
  	}
  	void add(ll x, ll y) {
  		auto k = M.lower_bound(x);
  		if (k->second >= y) return;
  		while(true) {
              if (auto p = *prev(M.lower_bound(x)); p.second > y){
                  break;
              }
              else{;
                  M.erase(p.first);
                  sum -= (p.first - prev(M.lower_bound(p.first))->first) * (p.second - M.lower_bound(x)->second);
              }
  		}
  		sum += (x - prev(M.lower_bound(x))->first) * (y - M.lower_bound(x)->second);
  		M[x] = y;
  	}
  };
  // snippet:AreaRect }}}


snippet topological_sort
alias tps
  // snippet:segment_tree {{{
  template <typename X> struct SegmentTree {  // {{{
      private:
          using F = function<X(X, X)>;
          using index = int;
          int n;  // 元の配列のサイズ
          int N;  // n以上の最小の2冪
          vector<X> node;
          F merge;
          X identity;
  
      public:
          SegmentTree() {}
          SegmentTree(vector<X> a, F f, X id) : merge(f), identity(id) {
              n = a.size();
              N = 1;
              while (N < n) N *= 2;
              node.resize(2 * N - 1, identity);
              for (int i = 0; i < n; i++) node[i + N - 1] = a[i];
              for (int i = N - 2; i >= 0; i--)
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
          }
          SegmentTree(int sz, F f, X id) : SegmentTree(vector<X>(sz, id), f, id) {}
  
          X& operator[](index i) { return node[i + N - 1]; }
  
          void set(index i, X val) {
              i += (N - 1);
              node[i] = val;
              while (i > 0) {
                  i = (i - 1) / 2;
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
              }
          }
  
          void add(index i, X val) {
              i += (N - 1);
              node[i] += val;
              while (i > 0) {
                  i = (i - 1) / 2;
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
              }
          }
  
          // query for [a, b)
          X query(index a, index b, int k = 0, index l = 0, index r = -1) {
              if (r < 0) r = N;
              if (r <= a || b <= l) return identity;
              if (a <= l && r <= b) return node[k];
  
              X vl = query(a, b, 2 * k + 1, l, (l + r) / 2);
              X vr = query(a, b, 2 * k + 2, (l + r) / 2, r);
              return merge(vl, vr);
          }
  
          index find_most_left(index l, const function<bool(X)>& is_ok){
              // lから右に探していってis_okが初めて成り立つようなindexを返す。
              // assume query(l, *) has monotonity
              // return index i s.t is_ok(query(l, i)) does not holds, but is_ok(query(l, i+1)) does.
              // if such i does not exist, return n
              index res = _find_most_left(l, is_ok, 0, 0, N, identity).first;
              assert(l <= res);
              return res;
          }
          pair<index, X> _find_most_left(index a, const function<bool(X)>& is_ok, int k, index l, index r, X left_value){
              // params:
                  // left_value = (a < l ? query(a, l) : ex)
              // return (index i, X v)
                  // i is the index in [a, n)^[l, r) s.t query(a, i+1) is ok but query(a, i) isn't ok. if such i does not exist, i = n
                  // v is the value s.t query(a, r)
  
              if (r <= a) return {n, identity};  // 区間が全く被っていない
              else if (a <= l && !is_ok(merge(left_value, node[k]))) return {n, merge(left_value, node[k])};
              else if (k >= N-1) return {k - (N-1), merge(left_value, node[k])};
              else{
                  auto [vl, xl] = _find_most_left(a, is_ok, 2 * k + 1, l, (l + r) / 2, left_value);
                  if (vl != n) return {vl, xl};
                  auto [vr, xr] = _find_most_left(a, is_ok, 2 * k + 2, (l + r) / 2, r, xl);
                  return {vr, xr};
              }
          }
  
          index find_most_right(index r, const function<bool(X)>& is_ok){
              // rから左に探していってis_okが初めて成り立つようなindexを返す。
              // assume query(*, r) has monotonity
              // return index i s.t is_ok(query(i+1, r+1)) does not holds, but is_ok(query(i, r+1)) does.
              // if such i does not exist, return -1
              index res = _find_most_right(r+1, is_ok, 0, 0, N, identity).first;
              assert(res <= r);
              return res;
          }
          pair<index, X> _find_most_right(index b, const function<bool(X)>& is_ok, int k, index l, index r, X right_value){
              if (b <= l) return {-1, identity};  // 区間が全く被っていない
              else if (r <= b && !is_ok(merge(node[k], right_value))) return {-1, merge(node[k], right_value)};
              else if (k >= N-1) return {k - (N-1), merge(node[k], right_value)};
              else{
                  auto [vr, xr] = _find_most_right(b, is_ok, 2 * k + 2, (l + r) / 2, r, right_value);
                  if (vr != -1) return {vr, xr};
                  auto [vl, xl] = _find_most_right(b, is_ok, 2 * k + 1, l, (l + r) / 2, xr);
                  return {vl, xl};
              }
          }
  
          #if defined(PCM) || defined(LOCAL)
          friend ostream& operator<<(ostream& os, SegmentTree<X>& sg) {  //
              os << "[";
              for (int i = 0; i < sg.n; i++) {
                  os << sg[i] << (i == sg.n - 1 ? "]\n" : ", ");
              }
              return os;
          }
          #endif
  };/*}}}*/
  // sample of initialize SegmentTree:
  // -----------------------------------------------
  // auto mymin=[](auto a, auto b){return min(a,b);};
  // SegmentTree<ll> seg(a, mymin, 1e18);
  
  // auto mymax=[](auto a, auto b){return max(a,b);};
  // SegmentTree<ll> seg(a, mymax, -1e18);
  
  // auto add=[](auto a, auto b){return a+b;};
  // SegmentTree<ll> seg(a, add, 0);
  
  // pair<int, int> get_nearest_index_of_smaller_element(int i){
  //     auto left = seg.find_most_right(i, [&](auto x){return x < a[i];});
  //     auto right = seg.find_most_left(i, [&](auto x){return x < a[i];});
  //     return {left, right};
  // }
  // -----------------------------------------------
  // snippet:segment_tree }}}
  
  // snippet:edge {{{
  template<class Cost=ll>
  struct Edge {
      int from, to;
      Cost cost;
      int idx;
      Edge(){};
      Edge(int from, int to, Cost cost, int idx)
          : from(from), to(to), cost(cost), idx(idx) {}
  
      friend ostream& operator<<(ostream& os, const Edge& e) {
          // os << "(f:" << e.from << ", t:" << e.to << ", c:" << e.cost << ", i" << e.idx << ")";  // detailed
          os << "(" << e.from << "," << e.to << ")";
          return os;
      }
  };
  // snippet:edge }}}
  
  // snippet:UnionFind {{{
  struct UnionFind {
      vector<int> par;   // par[x]: parent of x. if root, -size.
      int gcount;         // count of groups
  
      UnionFind() {}
      UnionFind(int _n) : par(_n, -1), gcount(_n) {}
      bool merge(int x, int y) { 
          x = root(x);
          y = root(y);
          if (x != y) {
              if (par[y] < par[x]) swap(x, y);
              par[x] += par[y];
              par[y] = x;
              gcount--;
          }
          return x != y;
      } 
      int root(int x) {
          if (is_root(x)){
              return x;
          }
          else{
              return par[x] = root(par[x]);  // 経路圧縮
              // return root(par[x]);         // 経路圧縮なし
          }
      }
      bool is_root(int x) { return par[x] < 0; }
      bool same(int x, int y) { return root(x) == root(y); }
      int size(int x) { return -par[root(x)]; }
  
  #if defined(PCM) || defined(LOCAL)  // {{{
      friend ostream& operator<<(ostream& os, UnionFind& uf) {
          map<int, vector<int>> group;
          rep(i, sz(uf.par)) { group[uf.root(i)].pb(i); }
          os << endl;
          each(g, group) { os << g << endl; }
          return os;
      }
  #endif  // }}}
  };
  // snippet:UnionFind }}}
  
  // snippet:tree {{{
  template<class Cost=ll>
  struct tree { 
      int n;
      int root;
      vector<int> par;   // par[i]: dfs木における親
      vector<Cost> cost;  // par[i]: dfs木における親への辺のコスト
      vector<int> dfstrv;  // dfstrv[i]: dfs木でi番目に訪れるノード。dpはこれを逆順に回す
      vector<int> ord;    // ord[u]: uのdfs木における訪問順
      vector<int> end;    // end[u]: uのdfs終了時のカウンター
      vector<int> psize;  // psize[u]: uのpartial tree size
      // uの部分木は[ord[u], end[u])
      // ordとdfstrvは逆変換
      vector<int> depth;   // depth[i]: dfs木でのiの深さ
      vector<Cost> ldepth;  //  ldepth[i]: dfs木でのrootからの距離
      vector<vector<Edge<Cost>>> adj_list;       // 辺(隣接リスト)
      auto operator[](int pos) const { return adj_list[pos]; }
      vector<vector<int>> children;
      vector<int> euler_tour;
      vector<int> et_fpos;    // euler_tour first occurence position
      SegmentTree<int> _seg;  // seg(map(ord, euler_tour), mymin, 1e18)
      vector<int> head_of_comp;
      int _counter = 0;
  
      tree(){};/*{{{*/
      tree(int n)
          : n(n),
            par(n),
            cost(n),
            ord(n),
            end(n),
            psize(n),
            depth(n),
            ldepth(n),
            adj_list(n),
            children(n),
            et_fpos(n),
            head_of_comp(n){};/*}}}*/
      void add_edge(int u, int v, Cost cost, int idx=-1) { /*{{{*/
          adj_list[u].emplace_back(u, v, cost, idx);
          adj_list[v].emplace_back(v, u, cost, idx);
      }                             /*}}}*/
      void add_edge(int u, int v) { /*{{{*/
          adj_list[u].emplace_back(u, v, 1, -1);
          adj_list[v].emplace_back(v, u, 1, -1);
      }                      /*}}}*/
      void build(int _root) { /*{{{*/
          root = _root;
          _counter = 0;
          par[root] = -1;
          // cost[root] = -1;
          _dfs_psize(root, -1);
          _dfs_tree(root, -1, root);
          _dfs_et(root);
          vector<int> ini(2 * n - 1);
          rep(i, 2 * n - 1) ini[i] = ord[euler_tour[i]];
          _seg = SegmentTree<int>(
              ini, [](auto a, auto b) { return min(a, b); }, numeric_limits<int>().max());
      }                                /*}}}*/
      int _dfs_psize(int u, int pre) { /*{{{*/
          psize[u] = 1;
          each(edge, adj_list[u]) {
              if (edge.to == pre) continue;
              psize[u] += _dfs_psize(edge.to, u);
          }
          return psize[u];
      }                                               /*}}}*/
      void _dfs_tree(int u, int pre, int head_node) { /*{{{*/
          dfstrv.pb(u);
          ord[u] = _counter;
          if (pre != -1) {
              depth[u] = depth[pre] + 1;
              ldepth[u] = ldepth[pre] + cost[u];
          }
  
          _counter++;
          {
              // set most heavy child to top
              int max_psize = 0;
              int most_heavy_i = -1;
              rep(i, sz(adj_list[u])) {
                  if (adj_list[u][i].to == pre) continue;
                  if (psize[adj_list[u][i].to] > max_psize) {
                      most_heavy_i = i;
                      max_psize = psize[adj_list[u][i].to];
                  }
              }
              if (most_heavy_i != -1) swap(adj_list[u][most_heavy_i], adj_list[u][0]);
          }
  
          head_of_comp[u] = head_node;
          rep(i, sz(adj_list[u])) {
              int v = adj_list[u][i].to;
              if (v == pre) continue;
  
              children[u].pb(v);
              par[v] = u;
              cost[v] = adj_list[u][i].cost;
  
              if (i == 0)
                  _dfs_tree(v, u, head_node);  // continue components
              else
                  _dfs_tree(v, u, v);  // new
          }
          end[u] = _counter;
      }                     /*}}}*/
      void _dfs_et(int u) { /*{{{*/
          et_fpos[u] = euler_tour.size();
          euler_tour.pb(u);
          each(v, children[u]) {
              _dfs_et(v);
              euler_tour.pb(u);
          }
      }                       /*}}}*/
      int lca(int u, int v) { /*{{{*/
          if (u == v) return u;
          if (et_fpos[u] > et_fpos[v]) swap(u, v);
          return dfstrv[_seg.query(et_fpos[u], et_fpos[v])];
      }                        /*}}}*/
      int dist(int u, int v) { /*{{{*/
          int p = lca(u, v);
          return depth[u] + depth[v] - 2 * depth[p];
      }                          /*}}}*/
      Cost ldist(int u, int v) {  // length dist{{{
          int p = lca(u, v);
          return ldepth[u] + ldepth[v] - 2 * ldepth[p];
      }                           /*}}}*/
      pair<int, int> diameter() { /*{{{*/
          int u, v;
          Cost max_len = *max_element(all(ldepth));
          rep(i, n) {
              if (ldepth[i] == max_len) {
                  u = i;
                  break;
              }
          }
          Cost md = -1;
          rep(i, n) {
              Cost d = ldist(u, i);
              if (d > md) {
                  v = i;
                  md = d;
              }
          }
          return mp(u, v);
      }                                                /*}}}*/
      vector<pair<int, int>> hld_path(int u, int v, bool for_edge=true) {  //{{{
          // 閉区間をvectorで返す。for_edge=trueでlcaは除いて返すことに注意。
          vector<pair<int, int>> res;
          while (head_of_comp[u] != head_of_comp[v]) {
              if (depth[head_of_comp[u]] < depth[head_of_comp[v]]) {
                  res.push_back({ord[head_of_comp[v]], ord[v]});
                  v = par[head_of_comp[v]];
              } else {
                  res.push_back({ord[head_of_comp[u]], ord[u]});
                  u = par[head_of_comp[u]];
              }
          }
          res.push_back({min(ord[u], ord[v]) + (for_edge?1:0), max(ord[u], ord[v])});
          return res;
      }                              //}}}
  #if defined(PCM) || defined(LOCAL) /*{{{*/
      friend ostream& operator<<(ostream& os, const tree& tr) {
          os << endl;
          os << "par:         " << tr.par << endl;
          os << "cost:        " << tr.cost << endl;
          os << "dfstrv:      " << tr.dfstrv << endl;
          os << "ord:         " << tr.ord << endl;
          os << "end:         " << tr.end << endl;
          os << "depth:       " << tr.depth << endl;
          os << "children:    " << tr.children << endl;
          os << "euler_tour:  " << tr.euler_tour << endl;
          os << "et_fpos:     " << tr.et_fpos << endl;
          os << "head_of_comp:" << tr.head_of_comp << endl;
          return os;
      }
  #endif /*}}}*/
  }; 
  // snippet:tree }}}
  
  // snippet:Graph {{{
  template<class Cost=ll>
  struct Graph {
      using Pos = int;  // int以外には対応しない。
  
      int n;  // 頂点数
      vector<vector<Edge<Cost>>> adj_list;
      auto operator[](Pos pos) const { return adj_list[pos]; }
      vector<Edge<Cost>> edges;
      tree<Cost> tr;
      Pos root;
      vector<int> _used_in_dfs;
      vector<int> lowlink;
      Cost zerocost;
      Cost infcost;
  
      Graph() {}
      Graph(int _n) : n(_n), adj_list(_n), tr(n), _used_in_dfs(n), zerocost(0LL), infcost(INF) { }
      Graph(int _n, Cost zc, Cost ic) : n(_n), adj_list(_n), tr(n), _used_in_dfs(n), zerocost(zc), infcost(ic) { }
  
      void add_edge(Pos from, Pos to, Cost cost, int idx=-1) {/*{{{*/
          adj_list[from].emplace_back(from, to, cost, idx);
          edges.emplace_back(from, to, cost, idx);
      }
      void add_edge(Pos from, Pos to) {  // for ll
          adj_list[from].emplace_back(from, to, 1, -1);
          edges.emplace_back(from, to, 1, -1);
      }/*}}}*/
  
      void build_tree(Pos _root) {/*{{{*/
          root = _root;
          _dfs_tree(root);
          tr.build(root);
          _make_lowlink();
      }/*}}}*/
  
      vector<int> make_bipartite() {/*{{{*/
          UnionFind buf(2 * n);
          rep(u, n) {
              each(e, adj_list[u]) {
                  buf.merge(u, e.to + n);
                  buf.merge(e.to, u + n);
              }
          }
  
          vector<int> res(n, -1);
          rep(u, n) {
              if (buf.same(u, u + n)) return res;
          }
          rep(u, n) {
              if (buf.same(0, u)) res[u] = 0;
              else res[u] = 1;
          }
          return res;
      }/*}}}*/
  
      void _dfs_tree(Pos u) {/*{{{*/
          _used_in_dfs[u] = 1;
          each(e, adj_list[u]) {
              if (_used_in_dfs[e.to]) continue;
              tr.add_edge(u, e.to, e.cost);
              _dfs_tree(e.to);
          }
      }/*}}}*/
  
      void _make_lowlink() {/*{{{*/
          lowlink = vector<Pos>(n, numeric_limits<Pos>().max());
          r_rep(i, n) {
              Pos u = tr.dfstrv[i];
              chmin(lowlink[u], tr.ord[u]);
  
              each(e, adj_list[u]) {
                  if (e.to == tr.par[u])
                      continue;
                  else if (tr.ord[e.to] < tr.ord[u]) {
                      chmin(lowlink[u], tr.ord[e.to]);
                  } else {
                      chmin(lowlink[u], lowlink[e.to]);
                  }
              }
          }
      }/*}}}*/
  
      vector<Pos> get_articulation_points() {/*{{{*/
          if (sz(lowlink) == 0) throw("make_lowlik() beforehand");
  
          vector<Pos> res;
          if (sz(tr.children[root]) > 1) {
              res.push_back(root);
          }
          rep(u, 0, n) {
              if (u == root) continue;
              bool is_kan = false;
              each(v, tr.children[u]) {
                  if (tr.ord[u] <= lowlink[v]) {
                      is_kan = true;
                  }
              }
              if (is_kan) res.push_back(u);
          }
          return res;
      }/*}}}*/
  
      vector<Edge<Cost>> get_bridges() {/*{{{*/
          if (sz(lowlink) == 0) throw("make_lowlik() beforehand");
          vector<Edge<Cost>> res;
          each(edge, edges){
              if (tr.ord[edge.from] < lowlink[edge.to]) res.push_back(edge);
          }
          return res;
      }/*}}}*/
  
      vector<Edge<Cost>> kruskal_tree() {/*{{{*/
          // 使用される辺のvectorを返す
          vector<Edge<Cost>> res(n - 1);
          sort(all(edges), [&](auto l, auto r) { return l.cost < r.cost; });
          UnionFind uf(n);
  
          Cost total_cost = zerocost;
          int idx = 0;
          each(e, edges) {
              if (uf.same(e.from, e.to)) continue;
              uf.merge(e.from, e.to);
              total_cost = total_cost + e.cost;
              res[idx] = e;
              idx++;
          }
          assert(idx == n - 1);
  
          return res;
      }/*}}}*/
  
      vector<Cost> dijkstra(vector<Pos> starts) {  // 多点スタート{{{
          vector<Cost> dist(n, infcost);           // 最短距離
          PQ<pair<Cost, Pos>> pq;
          each(start, starts) {
              dist[start] = zerocost;
              pq.push(make_pair(zerocost, start));
          }
          while (!pq.empty()) {
              auto cp = pq.top();
              pq.pop();
              auto [cost, u] = cp;
              for (const auto& edge : adj_list[u]) {
                  Cost new_cost = cost + edge.cost;  // TODO: 問題によってはここが変更の必要あり
                  if (new_cost < dist[edge.to]) {
                      dist[edge.to] = new_cost;
                      pq.push(make_pair(new_cost, edge.to));
                  }
              }
          }
          return dist;
      };/*}}}*/
  
      vector<Cost> dijkstra(Pos start) {  // 1点スタート{{{
          vector<Pos> starts = {start};
          return dijkstra(starts);
      };/*}}}*/
  };
  // snippet:Graph }}}
  
  // snippet:topological_sort {{{
  using Pos = int;
  tuple<bool, vector<Pos>, int> topological_sort(const Graph<>& g) {
      vector<Pos> res;  // sort後の結果を格納
      vector<int> h(g.n);  // 頂点ごとの入次数
      stack<Pos> st;    // 入次数が0になっている頂点の集合
      int max_len = 0;   // 最長経路の長さ
  
      // 入次数を計算する。
      rep(u, g.n) {
          for (const auto& edge : g[u]) {
              h[edge.to]++;
          }
      }
  
      // 最初に入次数0になっている頂点を集める。
      rep(u, g.n) {
          if (h[u] == 0) {
              st.push(u);
              res.push_back(u);
          }
      }
  
      // 入次数0の頂点をresに追加しそこから出て行く辺は削除していく。O(g.n+E)
      while (!st.empty()) {
          stack<Pos> nex_st;
          while (!st.empty()) {
              Pos u = st.top(); st.pop();
              for (const auto& edge : g[u]) {
                  h[edge.to]--;
                  if (h[edge.to] == 0) {
                      res.push_back(edge.to);
                      nex_st.push(edge.to);
                  }
              }
          }
          max_len++;
          st = nex_st;
      }
      
      bool is_valid = (sz(res)==g.n ? true : false);
      return {is_valid, res, max_len};  // res.size()<g.nなら閉路がありDAGではない。閉路内の頂点はstに入り得ないので。
  }
  // snippet:topological_sort }}}


snippet edge
  // snippet:edge {{{
  template<class Cost=ll>
  struct Edge {
      int from, to;
      Cost cost;
      int idx;
      Edge(){};
      Edge(int from, int to, Cost cost, int idx)
          : from(from), to(to), cost(cost), idx(idx) {}
  
      friend ostream& operator<<(ostream& os, const Edge& e) {
          // os << "(f:" << e.from << ", t:" << e.to << ", c:" << e.cost << ", i" << e.idx << ")";  // detailed
          os << "(" << e.from << "," << e.to << ")";
          return os;
      }
  };
  // snippet:edge }}}


snippet two_sat
  // snippet:segment_tree {{{
  template <typename X> struct SegmentTree {  // {{{
      private:
          using F = function<X(X, X)>;
          using index = int;
          int n;  // 元の配列のサイズ
          int N;  // n以上の最小の2冪
          vector<X> node;
          F merge;
          X identity;
  
      public:
          SegmentTree() {}
          SegmentTree(vector<X> a, F f, X id) : merge(f), identity(id) {
              n = a.size();
              N = 1;
              while (N < n) N *= 2;
              node.resize(2 * N - 1, identity);
              for (int i = 0; i < n; i++) node[i + N - 1] = a[i];
              for (int i = N - 2; i >= 0; i--)
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
          }
          SegmentTree(int sz, F f, X id) : SegmentTree(vector<X>(sz, id), f, id) {}
  
          X& operator[](index i) { return node[i + N - 1]; }
  
          void set(index i, X val) {
              i += (N - 1);
              node[i] = val;
              while (i > 0) {
                  i = (i - 1) / 2;
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
              }
          }
  
          void add(index i, X val) {
              i += (N - 1);
              node[i] += val;
              while (i > 0) {
                  i = (i - 1) / 2;
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
              }
          }
  
          // query for [a, b)
          X query(index a, index b, int k = 0, index l = 0, index r = -1) {
              if (r < 0) r = N;
              if (r <= a || b <= l) return identity;
              if (a <= l && r <= b) return node[k];
  
              X vl = query(a, b, 2 * k + 1, l, (l + r) / 2);
              X vr = query(a, b, 2 * k + 2, (l + r) / 2, r);
              return merge(vl, vr);
          }
  
          index find_most_left(index l, const function<bool(X)>& is_ok){
              // lから右に探していってis_okが初めて成り立つようなindexを返す。
              // assume query(l, *) has monotonity
              // return index i s.t is_ok(query(l, i)) does not holds, but is_ok(query(l, i+1)) does.
              // if such i does not exist, return n
              index res = _find_most_left(l, is_ok, 0, 0, N, identity).first;
              assert(l <= res);
              return res;
          }
          pair<index, X> _find_most_left(index a, const function<bool(X)>& is_ok, int k, index l, index r, X left_value){
              // params:
                  // left_value = (a < l ? query(a, l) : ex)
              // return (index i, X v)
                  // i is the index in [a, n)^[l, r) s.t query(a, i+1) is ok but query(a, i) isn't ok. if such i does not exist, i = n
                  // v is the value s.t query(a, r)
  
              if (r <= a) return {n, identity};  // 区間が全く被っていない
              else if (a <= l && !is_ok(merge(left_value, node[k]))) return {n, merge(left_value, node[k])};
              else if (k >= N-1) return {k - (N-1), merge(left_value, node[k])};
              else{
                  auto [vl, xl] = _find_most_left(a, is_ok, 2 * k + 1, l, (l + r) / 2, left_value);
                  if (vl != n) return {vl, xl};
                  auto [vr, xr] = _find_most_left(a, is_ok, 2 * k + 2, (l + r) / 2, r, xl);
                  return {vr, xr};
              }
          }
  
          index find_most_right(index r, const function<bool(X)>& is_ok){
              // rから左に探していってis_okが初めて成り立つようなindexを返す。
              // assume query(*, r) has monotonity
              // return index i s.t is_ok(query(i+1, r+1)) does not holds, but is_ok(query(i, r+1)) does.
              // if such i does not exist, return -1
              index res = _find_most_right(r+1, is_ok, 0, 0, N, identity).first;
              assert(res <= r);
              return res;
          }
          pair<index, X> _find_most_right(index b, const function<bool(X)>& is_ok, int k, index l, index r, X right_value){
              if (b <= l) return {-1, identity};  // 区間が全く被っていない
              else if (r <= b && !is_ok(merge(node[k], right_value))) return {-1, merge(node[k], right_value)};
              else if (k >= N-1) return {k - (N-1), merge(node[k], right_value)};
              else{
                  auto [vr, xr] = _find_most_right(b, is_ok, 2 * k + 2, (l + r) / 2, r, right_value);
                  if (vr != -1) return {vr, xr};
                  auto [vl, xl] = _find_most_right(b, is_ok, 2 * k + 1, l, (l + r) / 2, xr);
                  return {vl, xl};
              }
          }
  
          #if defined(PCM) || defined(LOCAL)
          friend ostream& operator<<(ostream& os, SegmentTree<X>& sg) {  //
              os << "[";
              for (int i = 0; i < sg.n; i++) {
                  os << sg[i] << (i == sg.n - 1 ? "]\n" : ", ");
              }
              return os;
          }
          #endif
  };/*}}}*/
  // sample of initialize SegmentTree:
  // -----------------------------------------------
  // auto mymin=[](auto a, auto b){return min(a,b);};
  // SegmentTree<ll> seg(a, mymin, 1e18);
  
  // auto mymax=[](auto a, auto b){return max(a,b);};
  // SegmentTree<ll> seg(a, mymax, -1e18);
  
  // auto add=[](auto a, auto b){return a+b;};
  // SegmentTree<ll> seg(a, add, 0);
  
  // pair<int, int> get_nearest_index_of_smaller_element(int i){
  //     auto left = seg.find_most_right(i, [&](auto x){return x < a[i];});
  //     auto right = seg.find_most_left(i, [&](auto x){return x < a[i];});
  //     return {left, right};
  // }
  // -----------------------------------------------
  // snippet:segment_tree }}}
  
  // snippet:edge {{{
  template<class Cost=ll>
  struct Edge {
      int from, to;
      Cost cost;
      int idx;
      Edge(){};
      Edge(int from, int to, Cost cost, int idx)
          : from(from), to(to), cost(cost), idx(idx) {}
  
      friend ostream& operator<<(ostream& os, const Edge& e) {
          // os << "(f:" << e.from << ", t:" << e.to << ", c:" << e.cost << ", i" << e.idx << ")";  // detailed
          os << "(" << e.from << "," << e.to << ")";
          return os;
      }
  };
  // snippet:edge }}}
  
  // snippet:UnionFind {{{
  struct UnionFind {
      vector<int> par;   // par[x]: parent of x. if root, -size.
      int gcount;         // count of groups
  
      UnionFind() {}
      UnionFind(int _n) : par(_n, -1), gcount(_n) {}
      bool merge(int x, int y) { 
          x = root(x);
          y = root(y);
          if (x != y) {
              if (par[y] < par[x]) swap(x, y);
              par[x] += par[y];
              par[y] = x;
              gcount--;
          }
          return x != y;
      } 
      int root(int x) {
          if (is_root(x)){
              return x;
          }
          else{
              return par[x] = root(par[x]);  // 経路圧縮
              // return root(par[x]);         // 経路圧縮なし
          }
      }
      bool is_root(int x) { return par[x] < 0; }
      bool same(int x, int y) { return root(x) == root(y); }
      int size(int x) { return -par[root(x)]; }
  
  #if defined(PCM) || defined(LOCAL)  // {{{
      friend ostream& operator<<(ostream& os, UnionFind& uf) {
          map<int, vector<int>> group;
          rep(i, sz(uf.par)) { group[uf.root(i)].pb(i); }
          os << endl;
          each(g, group) { os << g << endl; }
          return os;
      }
  #endif  // }}}
  };
  // snippet:UnionFind }}}
  
  // snippet:tree {{{
  template<class Cost=ll>
  struct tree { 
      int n;
      int root;
      vector<int> par;   // par[i]: dfs木における親
      vector<Cost> cost;  // par[i]: dfs木における親への辺のコスト
      vector<int> dfstrv;  // dfstrv[i]: dfs木でi番目に訪れるノード。dpはこれを逆順に回す
      vector<int> ord;    // ord[u]: uのdfs木における訪問順
      vector<int> end;    // end[u]: uのdfs終了時のカウンター
      vector<int> psize;  // psize[u]: uのpartial tree size
      // uの部分木は[ord[u], end[u])
      // ordとdfstrvは逆変換
      vector<int> depth;   // depth[i]: dfs木でのiの深さ
      vector<Cost> ldepth;  //  ldepth[i]: dfs木でのrootからの距離
      vector<vector<Edge<Cost>>> adj_list;       // 辺(隣接リスト)
      auto operator[](int pos) const { return adj_list[pos]; }
      vector<vector<int>> children;
      vector<int> euler_tour;
      vector<int> et_fpos;    // euler_tour first occurence position
      SegmentTree<int> _seg;  // seg(map(ord, euler_tour), mymin, 1e18)
      vector<int> head_of_comp;
      int _counter = 0;
  
      tree(){};/*{{{*/
      tree(int n)
          : n(n),
            par(n),
            cost(n),
            ord(n),
            end(n),
            psize(n),
            depth(n),
            ldepth(n),
            adj_list(n),
            children(n),
            et_fpos(n),
            head_of_comp(n){};/*}}}*/
      void add_edge(int u, int v, Cost cost, int idx=-1) { /*{{{*/
          adj_list[u].emplace_back(u, v, cost, idx);
          adj_list[v].emplace_back(v, u, cost, idx);
      }                             /*}}}*/
      void add_edge(int u, int v) { /*{{{*/
          adj_list[u].emplace_back(u, v, 1, -1);
          adj_list[v].emplace_back(v, u, 1, -1);
      }                      /*}}}*/
      void build(int _root) { /*{{{*/
          root = _root;
          _counter = 0;
          par[root] = -1;
          // cost[root] = -1;
          _dfs_psize(root, -1);
          _dfs_tree(root, -1, root);
          _dfs_et(root);
          vector<int> ini(2 * n - 1);
          rep(i, 2 * n - 1) ini[i] = ord[euler_tour[i]];
          _seg = SegmentTree<int>(
              ini, [](auto a, auto b) { return min(a, b); }, numeric_limits<int>().max());
      }                                /*}}}*/
      int _dfs_psize(int u, int pre) { /*{{{*/
          psize[u] = 1;
          each(edge, adj_list[u]) {
              if (edge.to == pre) continue;
              psize[u] += _dfs_psize(edge.to, u);
          }
          return psize[u];
      }                                               /*}}}*/
      void _dfs_tree(int u, int pre, int head_node) { /*{{{*/
          dfstrv.pb(u);
          ord[u] = _counter;
          if (pre != -1) {
              depth[u] = depth[pre] + 1;
              ldepth[u] = ldepth[pre] + cost[u];
          }
  
          _counter++;
          {
              // set most heavy child to top
              int max_psize = 0;
              int most_heavy_i = -1;
              rep(i, sz(adj_list[u])) {
                  if (adj_list[u][i].to == pre) continue;
                  if (psize[adj_list[u][i].to] > max_psize) {
                      most_heavy_i = i;
                      max_psize = psize[adj_list[u][i].to];
                  }
              }
              if (most_heavy_i != -1) swap(adj_list[u][most_heavy_i], adj_list[u][0]);
          }
  
          head_of_comp[u] = head_node;
          rep(i, sz(adj_list[u])) {
              int v = adj_list[u][i].to;
              if (v == pre) continue;
  
              children[u].pb(v);
              par[v] = u;
              cost[v] = adj_list[u][i].cost;
  
              if (i == 0)
                  _dfs_tree(v, u, head_node);  // continue components
              else
                  _dfs_tree(v, u, v);  // new
          }
          end[u] = _counter;
      }                     /*}}}*/
      void _dfs_et(int u) { /*{{{*/
          et_fpos[u] = euler_tour.size();
          euler_tour.pb(u);
          each(v, children[u]) {
              _dfs_et(v);
              euler_tour.pb(u);
          }
      }                       /*}}}*/
      int lca(int u, int v) { /*{{{*/
          if (u == v) return u;
          if (et_fpos[u] > et_fpos[v]) swap(u, v);
          return dfstrv[_seg.query(et_fpos[u], et_fpos[v])];
      }                        /*}}}*/
      int dist(int u, int v) { /*{{{*/
          int p = lca(u, v);
          return depth[u] + depth[v] - 2 * depth[p];
      }                          /*}}}*/
      Cost ldist(int u, int v) {  // length dist{{{
          int p = lca(u, v);
          return ldepth[u] + ldepth[v] - 2 * ldepth[p];
      }                           /*}}}*/
      pair<int, int> diameter() { /*{{{*/
          int u, v;
          Cost max_len = *max_element(all(ldepth));
          rep(i, n) {
              if (ldepth[i] == max_len) {
                  u = i;
                  break;
              }
          }
          Cost md = -1;
          rep(i, n) {
              Cost d = ldist(u, i);
              if (d > md) {
                  v = i;
                  md = d;
              }
          }
          return mp(u, v);
      }                                                /*}}}*/
      vector<pair<int, int>> hld_path(int u, int v, bool for_edge=true) {  //{{{
          // 閉区間をvectorで返す。for_edge=trueでlcaは除いて返すことに注意。
          vector<pair<int, int>> res;
          while (head_of_comp[u] != head_of_comp[v]) {
              if (depth[head_of_comp[u]] < depth[head_of_comp[v]]) {
                  res.push_back({ord[head_of_comp[v]], ord[v]});
                  v = par[head_of_comp[v]];
              } else {
                  res.push_back({ord[head_of_comp[u]], ord[u]});
                  u = par[head_of_comp[u]];
              }
          }
          res.push_back({min(ord[u], ord[v]) + (for_edge?1:0), max(ord[u], ord[v])});
          return res;
      }                              //}}}
  #if defined(PCM) || defined(LOCAL) /*{{{*/
      friend ostream& operator<<(ostream& os, const tree& tr) {
          os << endl;
          os << "par:         " << tr.par << endl;
          os << "cost:        " << tr.cost << endl;
          os << "dfstrv:      " << tr.dfstrv << endl;
          os << "ord:         " << tr.ord << endl;
          os << "end:         " << tr.end << endl;
          os << "depth:       " << tr.depth << endl;
          os << "children:    " << tr.children << endl;
          os << "euler_tour:  " << tr.euler_tour << endl;
          os << "et_fpos:     " << tr.et_fpos << endl;
          os << "head_of_comp:" << tr.head_of_comp << endl;
          return os;
      }
  #endif /*}}}*/
  }; 
  // snippet:tree }}}
  
  // snippet:Graph {{{
  template<class Cost=ll>
  struct Graph {
      using Pos = int;  // int以外には対応しない。
  
      int n;  // 頂点数
      vector<vector<Edge<Cost>>> adj_list;
      auto operator[](Pos pos) const { return adj_list[pos]; }
      vector<Edge<Cost>> edges;
      tree<Cost> tr;
      Pos root;
      vector<int> _used_in_dfs;
      vector<int> lowlink;
      Cost zerocost;
      Cost infcost;
  
      Graph() {}
      Graph(int _n) : n(_n), adj_list(_n), tr(n), _used_in_dfs(n), zerocost(0LL), infcost(INF) { }
      Graph(int _n, Cost zc, Cost ic) : n(_n), adj_list(_n), tr(n), _used_in_dfs(n), zerocost(zc), infcost(ic) { }
  
      void add_edge(Pos from, Pos to, Cost cost, int idx=-1) {/*{{{*/
          adj_list[from].emplace_back(from, to, cost, idx);
          edges.emplace_back(from, to, cost, idx);
      }
      void add_edge(Pos from, Pos to) {  // for ll
          adj_list[from].emplace_back(from, to, 1, -1);
          edges.emplace_back(from, to, 1, -1);
      }/*}}}*/
  
      void build_tree(Pos _root) {/*{{{*/
          root = _root;
          _dfs_tree(root);
          tr.build(root);
          _make_lowlink();
      }/*}}}*/
  
      vector<int> make_bipartite() {/*{{{*/
          UnionFind buf(2 * n);
          rep(u, n) {
              each(e, adj_list[u]) {
                  buf.merge(u, e.to + n);
                  buf.merge(e.to, u + n);
              }
          }
  
          vector<int> res(n, -1);
          rep(u, n) {
              if (buf.same(u, u + n)) return res;
          }
          rep(u, n) {
              if (buf.same(0, u)) res[u] = 0;
              else res[u] = 1;
          }
          return res;
      }/*}}}*/
  
      void _dfs_tree(Pos u) {/*{{{*/
          _used_in_dfs[u] = 1;
          each(e, adj_list[u]) {
              if (_used_in_dfs[e.to]) continue;
              tr.add_edge(u, e.to, e.cost);
              _dfs_tree(e.to);
          }
      }/*}}}*/
  
      void _make_lowlink() {/*{{{*/
          lowlink = vector<Pos>(n, numeric_limits<Pos>().max());
          r_rep(i, n) {
              Pos u = tr.dfstrv[i];
              chmin(lowlink[u], tr.ord[u]);
  
              each(e, adj_list[u]) {
                  if (e.to == tr.par[u])
                      continue;
                  else if (tr.ord[e.to] < tr.ord[u]) {
                      chmin(lowlink[u], tr.ord[e.to]);
                  } else {
                      chmin(lowlink[u], lowlink[e.to]);
                  }
              }
          }
      }/*}}}*/
  
      vector<Pos> get_articulation_points() {/*{{{*/
          if (sz(lowlink) == 0) throw("make_lowlik() beforehand");
  
          vector<Pos> res;
          if (sz(tr.children[root]) > 1) {
              res.push_back(root);
          }
          rep(u, 0, n) {
              if (u == root) continue;
              bool is_kan = false;
              each(v, tr.children[u]) {
                  if (tr.ord[u] <= lowlink[v]) {
                      is_kan = true;
                  }
              }
              if (is_kan) res.push_back(u);
          }
          return res;
      }/*}}}*/
  
      vector<Edge<Cost>> get_bridges() {/*{{{*/
          if (sz(lowlink) == 0) throw("make_lowlik() beforehand");
          vector<Edge<Cost>> res;
          each(edge, edges){
              if (tr.ord[edge.from] < lowlink[edge.to]) res.push_back(edge);
          }
          return res;
      }/*}}}*/
  
      vector<Edge<Cost>> kruskal_tree() {/*{{{*/
          // 使用される辺のvectorを返す
          vector<Edge<Cost>> res(n - 1);
          sort(all(edges), [&](auto l, auto r) { return l.cost < r.cost; });
          UnionFind uf(n);
  
          Cost total_cost = zerocost;
          int idx = 0;
          each(e, edges) {
              if (uf.same(e.from, e.to)) continue;
              uf.merge(e.from, e.to);
              total_cost = total_cost + e.cost;
              res[idx] = e;
              idx++;
          }
          assert(idx == n - 1);
  
          return res;
      }/*}}}*/
  
      vector<Cost> dijkstra(vector<Pos> starts) {  // 多点スタート{{{
          vector<Cost> dist(n, infcost);           // 最短距離
          PQ<pair<Cost, Pos>> pq;
          each(start, starts) {
              dist[start] = zerocost;
              pq.push(make_pair(zerocost, start));
          }
          while (!pq.empty()) {
              auto cp = pq.top();
              pq.pop();
              auto [cost, u] = cp;
              for (const auto& edge : adj_list[u]) {
                  Cost new_cost = cost + edge.cost;  // TODO: 問題によってはここが変更の必要あり
                  if (new_cost < dist[edge.to]) {
                      dist[edge.to] = new_cost;
                      pq.push(make_pair(new_cost, edge.to));
                  }
              }
          }
          return dist;
      };/*}}}*/
  
      vector<Cost> dijkstra(Pos start) {  // 1点スタート{{{
          vector<Pos> starts = {start};
          return dijkstra(starts);
      };/*}}}*/
  };
  // snippet:Graph }}}
  
  // snippet:topological_sort {{{
  using Pos = int;
  tuple<bool, vector<Pos>, int> topological_sort(const Graph<>& g) {
      vector<Pos> res;  // sort後の結果を格納
      vector<int> h(g.n);  // 頂点ごとの入次数
      stack<Pos> st;    // 入次数が0になっている頂点の集合
      int max_len = 0;   // 最長経路の長さ
  
      // 入次数を計算する。
      rep(u, g.n) {
          for (const auto& edge : g[u]) {
              h[edge.to]++;
          }
      }
  
      // 最初に入次数0になっている頂点を集める。
      rep(u, g.n) {
          if (h[u] == 0) {
              st.push(u);
              res.push_back(u);
          }
      }
  
      // 入次数0の頂点をresに追加しそこから出て行く辺は削除していく。O(g.n+E)
      while (!st.empty()) {
          stack<Pos> nex_st;
          while (!st.empty()) {
              Pos u = st.top(); st.pop();
              for (const auto& edge : g[u]) {
                  h[edge.to]--;
                  if (h[edge.to] == 0) {
                      res.push_back(edge.to);
                      nex_st.push(edge.to);
                  }
              }
          }
          max_len++;
          st = nex_st;
      }
      
      bool is_valid = (sz(res)==g.n ? true : false);
      return {is_valid, res, max_len};  // res.size()<g.nなら閉路がありDAGではない。閉路内の頂点はstに入り得ないので。
  }
  // snippet:topological_sort }}}
  
  // snippet:scc {{{
  template<class T = ll>
  struct StronglyConnectedComponents {
      const Graph<T> &g;  //{{{
      vector<int> comp;  // comp[i]: iが属する強連結成分が何番目の成分か
      Graph<> dag;  // 縮約されたDAG graph. sizeをとれば強連結成分の個数が分かる。
      Graph<> _rg;  // reversed graph
      vector<int> _order;  // order[i]: 帰りがけ順
      vector<int> _used;
  
      StronglyConnectedComponents(Graph<T> &_g)
          : g(_g), comp(_g.n, -1), _rg(_g.n), _used(_g.n) {
          for (int i = 0; i < g.n; i++) {
              for (auto e : g[i]) {
                  _rg.add_edge(e.to, e.from);
              }
          }
          _build();
      }
  
      int operator[](int k) { return comp[k]; }
  
      void _build() {
          for (int i = 0; i < g.n; i++) _dfs(i);
          reverse(begin(_order), end(_order));
          int cnt = 0;
          for (int u : _order)
              if (comp[u] == -1) _rdfs(u, cnt), cnt++;
  
          dag = Graph(cnt);
          for (int u = 0; u < g.n; u++) {
              for (auto &e : g[u]) {
                  if (comp[u] == comp[e.to]) continue;
                  dag.add_edge(comp[u], comp[e.to]);
              }
          }
      }
  
      void _dfs(int idx) {
          if (_used[idx]) return;
          _used[idx] = true;
          for (auto &e : g[idx]) _dfs(e.to);
          _order.push_back(idx);
      }
  
      void _rdfs(int idx, int cnt) {
          if (comp[idx] != -1) return;
          comp[idx] = cnt;
          for (auto e : _rg[idx]) _rdfs(e.to, cnt);
      }  //}}}
  };
  // how to use
  // StronglyConnectedComponents scc(g); // g: Graph
  // dump(scc.comp, scc.dag.adj_list);
  // snippet:scc }}}
  
  // snippet:two_sat {{{
  struct two_sat{
      using Pos = int;
      using Size = int;
      Size orig_n;
      Graph<bool> g;
      vector<int> assigned;
  
      two_sat(Size _orig_n): orig_n(_orig_n){
          g = Graph<bool>(orig_n * 2);  // 頂点倍加
      };
  
      Pos toid(Pos u, bool is_u) {
          return u * 2 + is_u;
      }
  
      void add_condition(Pos u, bool is_u, Pos v, bool is_v) {
          // add condition (u == is_u or v == is_v)
          g.add_edge(toid(u, is_u^1), toid(v, is_v));
          g.add_edge(toid(v, is_v^1), toid(u, is_u));
      }
  
      bool build(){
          // if successed to assigne valiables, return true, else return false。
          StronglyConnectedComponents scc(g);
          auto ts = get<1>(topological_sort(scc.dag));
          vector<Size> ord(sz(ts));
          rep(i, sz(ts)) ord[ts[i]] = i;
  
          // check valid
          rep(u, orig_n){
              if (scc.comp[toid(u, 0)] == scc.comp[toid(u, 1)]) {
                  return false;
              }
          }
  
          assigned = vector<int>(orig_n, -1);
          rep(u, orig_n){
              assigned[u] = (ord[scc.comp[toid(u, 0)]] < ord[scc.comp[toid(u, 1)]] ? 1 : 0);
          }
          return true;
      }
  };
  // how to use
  // two_sat ts(n); // n変数
  // ts.add_condition(x, 1, y, 0);  // represents (x==1 or y==0)
  // ......
  // ......
  // auto valid = ts.build();
  // if (valid) dump(ts.assigned);
  // snippet:two_sat }}}


snippet local_min_cycle_undirected
alias cycle
  // snippet:segment_tree {{{
  template <typename X> struct SegmentTree {  // {{{
      private:
          using F = function<X(X, X)>;
          using index = int;
          int n;  // 元の配列のサイズ
          int N;  // n以上の最小の2冪
          vector<X> node;
          F merge;
          X identity;
  
      public:
          SegmentTree() {}
          SegmentTree(vector<X> a, F f, X id) : merge(f), identity(id) {
              n = a.size();
              N = 1;
              while (N < n) N *= 2;
              node.resize(2 * N - 1, identity);
              for (int i = 0; i < n; i++) node[i + N - 1] = a[i];
              for (int i = N - 2; i >= 0; i--)
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
          }
          SegmentTree(int sz, F f, X id) : SegmentTree(vector<X>(sz, id), f, id) {}
  
          X& operator[](index i) { return node[i + N - 1]; }
  
          void set(index i, X val) {
              i += (N - 1);
              node[i] = val;
              while (i > 0) {
                  i = (i - 1) / 2;
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
              }
          }
  
          void add(index i, X val) {
              i += (N - 1);
              node[i] += val;
              while (i > 0) {
                  i = (i - 1) / 2;
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
              }
          }
  
          // query for [a, b)
          X query(index a, index b, int k = 0, index l = 0, index r = -1) {
              if (r < 0) r = N;
              if (r <= a || b <= l) return identity;
              if (a <= l && r <= b) return node[k];
  
              X vl = query(a, b, 2 * k + 1, l, (l + r) / 2);
              X vr = query(a, b, 2 * k + 2, (l + r) / 2, r);
              return merge(vl, vr);
          }
  
          index find_most_left(index l, const function<bool(X)>& is_ok){
              // lから右に探していってis_okが初めて成り立つようなindexを返す。
              // assume query(l, *) has monotonity
              // return index i s.t is_ok(query(l, i)) does not holds, but is_ok(query(l, i+1)) does.
              // if such i does not exist, return n
              index res = _find_most_left(l, is_ok, 0, 0, N, identity).first;
              assert(l <= res);
              return res;
          }
          pair<index, X> _find_most_left(index a, const function<bool(X)>& is_ok, int k, index l, index r, X left_value){
              // params:
                  // left_value = (a < l ? query(a, l) : ex)
              // return (index i, X v)
                  // i is the index in [a, n)^[l, r) s.t query(a, i+1) is ok but query(a, i) isn't ok. if such i does not exist, i = n
                  // v is the value s.t query(a, r)
  
              if (r <= a) return {n, identity};  // 区間が全く被っていない
              else if (a <= l && !is_ok(merge(left_value, node[k]))) return {n, merge(left_value, node[k])};
              else if (k >= N-1) return {k - (N-1), merge(left_value, node[k])};
              else{
                  auto [vl, xl] = _find_most_left(a, is_ok, 2 * k + 1, l, (l + r) / 2, left_value);
                  if (vl != n) return {vl, xl};
                  auto [vr, xr] = _find_most_left(a, is_ok, 2 * k + 2, (l + r) / 2, r, xl);
                  return {vr, xr};
              }
          }
  
          index find_most_right(index r, const function<bool(X)>& is_ok){
              // rから左に探していってis_okが初めて成り立つようなindexを返す。
              // assume query(*, r) has monotonity
              // return index i s.t is_ok(query(i+1, r+1)) does not holds, but is_ok(query(i, r+1)) does.
              // if such i does not exist, return -1
              index res = _find_most_right(r+1, is_ok, 0, 0, N, identity).first;
              assert(res <= r);
              return res;
          }
          pair<index, X> _find_most_right(index b, const function<bool(X)>& is_ok, int k, index l, index r, X right_value){
              if (b <= l) return {-1, identity};  // 区間が全く被っていない
              else if (r <= b && !is_ok(merge(node[k], right_value))) return {-1, merge(node[k], right_value)};
              else if (k >= N-1) return {k - (N-1), merge(node[k], right_value)};
              else{
                  auto [vr, xr] = _find_most_right(b, is_ok, 2 * k + 2, (l + r) / 2, r, right_value);
                  if (vr != -1) return {vr, xr};
                  auto [vl, xl] = _find_most_right(b, is_ok, 2 * k + 1, l, (l + r) / 2, xr);
                  return {vl, xl};
              }
          }
  
          #if defined(PCM) || defined(LOCAL)
          friend ostream& operator<<(ostream& os, SegmentTree<X>& sg) {  //
              os << "[";
              for (int i = 0; i < sg.n; i++) {
                  os << sg[i] << (i == sg.n - 1 ? "]\n" : ", ");
              }
              return os;
          }
          #endif
  };/*}}}*/
  // sample of initialize SegmentTree:
  // -----------------------------------------------
  // auto mymin=[](auto a, auto b){return min(a,b);};
  // SegmentTree<ll> seg(a, mymin, 1e18);
  
  // auto mymax=[](auto a, auto b){return max(a,b);};
  // SegmentTree<ll> seg(a, mymax, -1e18);
  
  // auto add=[](auto a, auto b){return a+b;};
  // SegmentTree<ll> seg(a, add, 0);
  
  // pair<int, int> get_nearest_index_of_smaller_element(int i){
  //     auto left = seg.find_most_right(i, [&](auto x){return x < a[i];});
  //     auto right = seg.find_most_left(i, [&](auto x){return x < a[i];});
  //     return {left, right};
  // }
  // -----------------------------------------------
  // snippet:segment_tree }}}
  
  // snippet:edge {{{
  template<class Cost=ll>
  struct Edge {
      int from, to;
      Cost cost;
      int idx;
      Edge(){};
      Edge(int from, int to, Cost cost, int idx)
          : from(from), to(to), cost(cost), idx(idx) {}
  
      friend ostream& operator<<(ostream& os, const Edge& e) {
          // os << "(f:" << e.from << ", t:" << e.to << ", c:" << e.cost << ", i" << e.idx << ")";  // detailed
          os << "(" << e.from << "," << e.to << ")";
          return os;
      }
  };
  // snippet:edge }}}
  
  // snippet:UnionFind {{{
  struct UnionFind {
      vector<int> par;   // par[x]: parent of x. if root, -size.
      int gcount;         // count of groups
  
      UnionFind() {}
      UnionFind(int _n) : par(_n, -1), gcount(_n) {}
      bool merge(int x, int y) { 
          x = root(x);
          y = root(y);
          if (x != y) {
              if (par[y] < par[x]) swap(x, y);
              par[x] += par[y];
              par[y] = x;
              gcount--;
          }
          return x != y;
      } 
      int root(int x) {
          if (is_root(x)){
              return x;
          }
          else{
              return par[x] = root(par[x]);  // 経路圧縮
              // return root(par[x]);         // 経路圧縮なし
          }
      }
      bool is_root(int x) { return par[x] < 0; }
      bool same(int x, int y) { return root(x) == root(y); }
      int size(int x) { return -par[root(x)]; }
  
  #if defined(PCM) || defined(LOCAL)  // {{{
      friend ostream& operator<<(ostream& os, UnionFind& uf) {
          map<int, vector<int>> group;
          rep(i, sz(uf.par)) { group[uf.root(i)].pb(i); }
          os << endl;
          each(g, group) { os << g << endl; }
          return os;
      }
  #endif  // }}}
  };
  // snippet:UnionFind }}}
  
  // snippet:tree {{{
  template<class Cost=ll>
  struct tree { 
      int n;
      int root;
      vector<int> par;   // par[i]: dfs木における親
      vector<Cost> cost;  // par[i]: dfs木における親への辺のコスト
      vector<int> dfstrv;  // dfstrv[i]: dfs木でi番目に訪れるノード。dpはこれを逆順に回す
      vector<int> ord;    // ord[u]: uのdfs木における訪問順
      vector<int> end;    // end[u]: uのdfs終了時のカウンター
      vector<int> psize;  // psize[u]: uのpartial tree size
      // uの部分木は[ord[u], end[u])
      // ordとdfstrvは逆変換
      vector<int> depth;   // depth[i]: dfs木でのiの深さ
      vector<Cost> ldepth;  //  ldepth[i]: dfs木でのrootからの距離
      vector<vector<Edge<Cost>>> adj_list;       // 辺(隣接リスト)
      auto operator[](int pos) const { return adj_list[pos]; }
      vector<vector<int>> children;
      vector<int> euler_tour;
      vector<int> et_fpos;    // euler_tour first occurence position
      SegmentTree<int> _seg;  // seg(map(ord, euler_tour), mymin, 1e18)
      vector<int> head_of_comp;
      int _counter = 0;
  
      tree(){};/*{{{*/
      tree(int n)
          : n(n),
            par(n),
            cost(n),
            ord(n),
            end(n),
            psize(n),
            depth(n),
            ldepth(n),
            adj_list(n),
            children(n),
            et_fpos(n),
            head_of_comp(n){};/*}}}*/
      void add_edge(int u, int v, Cost cost, int idx=-1) { /*{{{*/
          adj_list[u].emplace_back(u, v, cost, idx);
          adj_list[v].emplace_back(v, u, cost, idx);
      }                             /*}}}*/
      void add_edge(int u, int v) { /*{{{*/
          adj_list[u].emplace_back(u, v, 1, -1);
          adj_list[v].emplace_back(v, u, 1, -1);
      }                      /*}}}*/
      void build(int _root) { /*{{{*/
          root = _root;
          _counter = 0;
          par[root] = -1;
          // cost[root] = -1;
          _dfs_psize(root, -1);
          _dfs_tree(root, -1, root);
          _dfs_et(root);
          vector<int> ini(2 * n - 1);
          rep(i, 2 * n - 1) ini[i] = ord[euler_tour[i]];
          _seg = SegmentTree<int>(
              ini, [](auto a, auto b) { return min(a, b); }, numeric_limits<int>().max());
      }                                /*}}}*/
      int _dfs_psize(int u, int pre) { /*{{{*/
          psize[u] = 1;
          each(edge, adj_list[u]) {
              if (edge.to == pre) continue;
              psize[u] += _dfs_psize(edge.to, u);
          }
          return psize[u];
      }                                               /*}}}*/
      void _dfs_tree(int u, int pre, int head_node) { /*{{{*/
          dfstrv.pb(u);
          ord[u] = _counter;
          if (pre != -1) {
              depth[u] = depth[pre] + 1;
              ldepth[u] = ldepth[pre] + cost[u];
          }
  
          _counter++;
          {
              // set most heavy child to top
              int max_psize = 0;
              int most_heavy_i = -1;
              rep(i, sz(adj_list[u])) {
                  if (adj_list[u][i].to == pre) continue;
                  if (psize[adj_list[u][i].to] > max_psize) {
                      most_heavy_i = i;
                      max_psize = psize[adj_list[u][i].to];
                  }
              }
              if (most_heavy_i != -1) swap(adj_list[u][most_heavy_i], adj_list[u][0]);
          }
  
          head_of_comp[u] = head_node;
          rep(i, sz(adj_list[u])) {
              int v = adj_list[u][i].to;
              if (v == pre) continue;
  
              children[u].pb(v);
              par[v] = u;
              cost[v] = adj_list[u][i].cost;
  
              if (i == 0)
                  _dfs_tree(v, u, head_node);  // continue components
              else
                  _dfs_tree(v, u, v);  // new
          }
          end[u] = _counter;
      }                     /*}}}*/
      void _dfs_et(int u) { /*{{{*/
          et_fpos[u] = euler_tour.size();
          euler_tour.pb(u);
          each(v, children[u]) {
              _dfs_et(v);
              euler_tour.pb(u);
          }
      }                       /*}}}*/
      int lca(int u, int v) { /*{{{*/
          if (u == v) return u;
          if (et_fpos[u] > et_fpos[v]) swap(u, v);
          return dfstrv[_seg.query(et_fpos[u], et_fpos[v])];
      }                        /*}}}*/
      int dist(int u, int v) { /*{{{*/
          int p = lca(u, v);
          return depth[u] + depth[v] - 2 * depth[p];
      }                          /*}}}*/
      Cost ldist(int u, int v) {  // length dist{{{
          int p = lca(u, v);
          return ldepth[u] + ldepth[v] - 2 * ldepth[p];
      }                           /*}}}*/
      pair<int, int> diameter() { /*{{{*/
          int u, v;
          Cost max_len = *max_element(all(ldepth));
          rep(i, n) {
              if (ldepth[i] == max_len) {
                  u = i;
                  break;
              }
          }
          Cost md = -1;
          rep(i, n) {
              Cost d = ldist(u, i);
              if (d > md) {
                  v = i;
                  md = d;
              }
          }
          return mp(u, v);
      }                                                /*}}}*/
      vector<pair<int, int>> hld_path(int u, int v, bool for_edge=true) {  //{{{
          // 閉区間をvectorで返す。for_edge=trueでlcaは除いて返すことに注意。
          vector<pair<int, int>> res;
          while (head_of_comp[u] != head_of_comp[v]) {
              if (depth[head_of_comp[u]] < depth[head_of_comp[v]]) {
                  res.push_back({ord[head_of_comp[v]], ord[v]});
                  v = par[head_of_comp[v]];
              } else {
                  res.push_back({ord[head_of_comp[u]], ord[u]});
                  u = par[head_of_comp[u]];
              }
          }
          res.push_back({min(ord[u], ord[v]) + (for_edge?1:0), max(ord[u], ord[v])});
          return res;
      }                              //}}}
  #if defined(PCM) || defined(LOCAL) /*{{{*/
      friend ostream& operator<<(ostream& os, const tree& tr) {
          os << endl;
          os << "par:         " << tr.par << endl;
          os << "cost:        " << tr.cost << endl;
          os << "dfstrv:      " << tr.dfstrv << endl;
          os << "ord:         " << tr.ord << endl;
          os << "end:         " << tr.end << endl;
          os << "depth:       " << tr.depth << endl;
          os << "children:    " << tr.children << endl;
          os << "euler_tour:  " << tr.euler_tour << endl;
          os << "et_fpos:     " << tr.et_fpos << endl;
          os << "head_of_comp:" << tr.head_of_comp << endl;
          return os;
      }
  #endif /*}}}*/
  }; 
  // snippet:tree }}}
  
  // snippet:Graph {{{
  template<class Cost=ll>
  struct Graph {
      using Pos = int;  // int以外には対応しない。
  
      int n;  // 頂点数
      vector<vector<Edge<Cost>>> adj_list;
      auto operator[](Pos pos) const { return adj_list[pos]; }
      vector<Edge<Cost>> edges;
      tree<Cost> tr;
      Pos root;
      vector<int> _used_in_dfs;
      vector<int> lowlink;
      Cost zerocost;
      Cost infcost;
  
      Graph() {}
      Graph(int _n) : n(_n), adj_list(_n), tr(n), _used_in_dfs(n), zerocost(0LL), infcost(INF) { }
      Graph(int _n, Cost zc, Cost ic) : n(_n), adj_list(_n), tr(n), _used_in_dfs(n), zerocost(zc), infcost(ic) { }
  
      void add_edge(Pos from, Pos to, Cost cost, int idx=-1) {/*{{{*/
          adj_list[from].emplace_back(from, to, cost, idx);
          edges.emplace_back(from, to, cost, idx);
      }
      void add_edge(Pos from, Pos to) {  // for ll
          adj_list[from].emplace_back(from, to, 1, -1);
          edges.emplace_back(from, to, 1, -1);
      }/*}}}*/
  
      void build_tree(Pos _root) {/*{{{*/
          root = _root;
          _dfs_tree(root);
          tr.build(root);
          _make_lowlink();
      }/*}}}*/
  
      vector<int> make_bipartite() {/*{{{*/
          UnionFind buf(2 * n);
          rep(u, n) {
              each(e, adj_list[u]) {
                  buf.merge(u, e.to + n);
                  buf.merge(e.to, u + n);
              }
          }
  
          vector<int> res(n, -1);
          rep(u, n) {
              if (buf.same(u, u + n)) return res;
          }
          rep(u, n) {
              if (buf.same(0, u)) res[u] = 0;
              else res[u] = 1;
          }
          return res;
      }/*}}}*/
  
      void _dfs_tree(Pos u) {/*{{{*/
          _used_in_dfs[u] = 1;
          each(e, adj_list[u]) {
              if (_used_in_dfs[e.to]) continue;
              tr.add_edge(u, e.to, e.cost);
              _dfs_tree(e.to);
          }
      }/*}}}*/
  
      void _make_lowlink() {/*{{{*/
          lowlink = vector<Pos>(n, numeric_limits<Pos>().max());
          r_rep(i, n) {
              Pos u = tr.dfstrv[i];
              chmin(lowlink[u], tr.ord[u]);
  
              each(e, adj_list[u]) {
                  if (e.to == tr.par[u])
                      continue;
                  else if (tr.ord[e.to] < tr.ord[u]) {
                      chmin(lowlink[u], tr.ord[e.to]);
                  } else {
                      chmin(lowlink[u], lowlink[e.to]);
                  }
              }
          }
      }/*}}}*/
  
      vector<Pos> get_articulation_points() {/*{{{*/
          if (sz(lowlink) == 0) throw("make_lowlik() beforehand");
  
          vector<Pos> res;
          if (sz(tr.children[root]) > 1) {
              res.push_back(root);
          }
          rep(u, 0, n) {
              if (u == root) continue;
              bool is_kan = false;
              each(v, tr.children[u]) {
                  if (tr.ord[u] <= lowlink[v]) {
                      is_kan = true;
                  }
              }
              if (is_kan) res.push_back(u);
          }
          return res;
      }/*}}}*/
  
      vector<Edge<Cost>> get_bridges() {/*{{{*/
          if (sz(lowlink) == 0) throw("make_lowlik() beforehand");
          vector<Edge<Cost>> res;
          each(edge, edges){
              if (tr.ord[edge.from] < lowlink[edge.to]) res.push_back(edge);
          }
          return res;
      }/*}}}*/
  
      vector<Edge<Cost>> kruskal_tree() {/*{{{*/
          // 使用される辺のvectorを返す
          vector<Edge<Cost>> res(n - 1);
          sort(all(edges), [&](auto l, auto r) { return l.cost < r.cost; });
          UnionFind uf(n);
  
          Cost total_cost = zerocost;
          int idx = 0;
          each(e, edges) {
              if (uf.same(e.from, e.to)) continue;
              uf.merge(e.from, e.to);
              total_cost = total_cost + e.cost;
              res[idx] = e;
              idx++;
          }
          assert(idx == n - 1);
  
          return res;
      }/*}}}*/
  
      vector<Cost> dijkstra(vector<Pos> starts) {  // 多点スタート{{{
          vector<Cost> dist(n, infcost);           // 最短距離
          PQ<pair<Cost, Pos>> pq;
          each(start, starts) {
              dist[start] = zerocost;
              pq.push(make_pair(zerocost, start));
          }
          while (!pq.empty()) {
              auto cp = pq.top();
              pq.pop();
              auto [cost, u] = cp;
              for (const auto& edge : adj_list[u]) {
                  Cost new_cost = cost + edge.cost;  // TODO: 問題によってはここが変更の必要あり
                  if (new_cost < dist[edge.to]) {
                      dist[edge.to] = new_cost;
                      pq.push(make_pair(new_cost, edge.to));
                  }
              }
          }
          return dist;
      };/*}}}*/
  
      vector<Cost> dijkstra(Pos start) {  // 1点スタート{{{
          vector<Pos> starts = {start};
          return dijkstra(starts);
      };/*}}}*/
  };
  // snippet:Graph }}}
  
  // snippet:local_min_cycle_undirected {{{
  // verified by https://codeforces.com/contest/1364/problem/D
  
  template<class T>
  vector<int> local_min_cycle_undirected(Graph<T>& g){
      // 無向グラフにしか対応していないので注意
      pair<int, int> loop = mp(-1, -1);  // start, end
      vector<int> loop_path;
      vector<bool> used(g.n);
      bool loop_found = false;
      auto dfs = [&](const auto& dfs, int u, int pre) -> int {
          used[u] = 1;
          int max_depth = -1;
          each(e, g.adj_list[u]){
              if (e.to == pre) continue;
              else if (used[e.to]){  // back-track-edge
                  loop_found = true;
                  if (g.tr.depth[e.to] > max_depth) {
                      max_depth = g.tr.depth[e.to];
                      loop = mp(e.to, u);
                  }
              }
          }
          if (loop_found){
              // generate path
              loop_path.pb(loop.first);
              int cur = loop.second;
              while(cur != loop.first){
                  loop_path.pb(cur);
                  cur = g.tr.par[cur];
              }
              // loop_path.pb(loop.first);
          }
  
          // if no back-tarck edge exists, the continue to dfs
          each(e, g.tr.adj_list[u]){
              if (e.to == pre) continue;
              if (!loop_found) dfs(dfs, e.to, u);
          }
  
          return 0;
      };
  
      dfs(dfs, 0, -1);
      return loop_path;  // if tree, loop_path = {};
  }
  // snippet:local_min_cycle_undirected }}}


snippet local_min_cycle_directed
  // snippet:segment_tree {{{
  template <typename X> struct SegmentTree {  // {{{
      private:
          using F = function<X(X, X)>;
          using index = int;
          int n;  // 元の配列のサイズ
          int N;  // n以上の最小の2冪
          vector<X> node;
          F merge;
          X identity;
  
      public:
          SegmentTree() {}
          SegmentTree(vector<X> a, F f, X id) : merge(f), identity(id) {
              n = a.size();
              N = 1;
              while (N < n) N *= 2;
              node.resize(2 * N - 1, identity);
              for (int i = 0; i < n; i++) node[i + N - 1] = a[i];
              for (int i = N - 2; i >= 0; i--)
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
          }
          SegmentTree(int sz, F f, X id) : SegmentTree(vector<X>(sz, id), f, id) {}
  
          X& operator[](index i) { return node[i + N - 1]; }
  
          void set(index i, X val) {
              i += (N - 1);
              node[i] = val;
              while (i > 0) {
                  i = (i - 1) / 2;
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
              }
          }
  
          void add(index i, X val) {
              i += (N - 1);
              node[i] += val;
              while (i > 0) {
                  i = (i - 1) / 2;
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
              }
          }
  
          // query for [a, b)
          X query(index a, index b, int k = 0, index l = 0, index r = -1) {
              if (r < 0) r = N;
              if (r <= a || b <= l) return identity;
              if (a <= l && r <= b) return node[k];
  
              X vl = query(a, b, 2 * k + 1, l, (l + r) / 2);
              X vr = query(a, b, 2 * k + 2, (l + r) / 2, r);
              return merge(vl, vr);
          }
  
          index find_most_left(index l, const function<bool(X)>& is_ok){
              // lから右に探していってis_okが初めて成り立つようなindexを返す。
              // assume query(l, *) has monotonity
              // return index i s.t is_ok(query(l, i)) does not holds, but is_ok(query(l, i+1)) does.
              // if such i does not exist, return n
              index res = _find_most_left(l, is_ok, 0, 0, N, identity).first;
              assert(l <= res);
              return res;
          }
          pair<index, X> _find_most_left(index a, const function<bool(X)>& is_ok, int k, index l, index r, X left_value){
              // params:
                  // left_value = (a < l ? query(a, l) : ex)
              // return (index i, X v)
                  // i is the index in [a, n)^[l, r) s.t query(a, i+1) is ok but query(a, i) isn't ok. if such i does not exist, i = n
                  // v is the value s.t query(a, r)
  
              if (r <= a) return {n, identity};  // 区間が全く被っていない
              else if (a <= l && !is_ok(merge(left_value, node[k]))) return {n, merge(left_value, node[k])};
              else if (k >= N-1) return {k - (N-1), merge(left_value, node[k])};
              else{
                  auto [vl, xl] = _find_most_left(a, is_ok, 2 * k + 1, l, (l + r) / 2, left_value);
                  if (vl != n) return {vl, xl};
                  auto [vr, xr] = _find_most_left(a, is_ok, 2 * k + 2, (l + r) / 2, r, xl);
                  return {vr, xr};
              }
          }
  
          index find_most_right(index r, const function<bool(X)>& is_ok){
              // rから左に探していってis_okが初めて成り立つようなindexを返す。
              // assume query(*, r) has monotonity
              // return index i s.t is_ok(query(i+1, r+1)) does not holds, but is_ok(query(i, r+1)) does.
              // if such i does not exist, return -1
              index res = _find_most_right(r+1, is_ok, 0, 0, N, identity).first;
              assert(res <= r);
              return res;
          }
          pair<index, X> _find_most_right(index b, const function<bool(X)>& is_ok, int k, index l, index r, X right_value){
              if (b <= l) return {-1, identity};  // 区間が全く被っていない
              else if (r <= b && !is_ok(merge(node[k], right_value))) return {-1, merge(node[k], right_value)};
              else if (k >= N-1) return {k - (N-1), merge(node[k], right_value)};
              else{
                  auto [vr, xr] = _find_most_right(b, is_ok, 2 * k + 2, (l + r) / 2, r, right_value);
                  if (vr != -1) return {vr, xr};
                  auto [vl, xl] = _find_most_right(b, is_ok, 2 * k + 1, l, (l + r) / 2, xr);
                  return {vl, xl};
              }
          }
  
          #if defined(PCM) || defined(LOCAL)
          friend ostream& operator<<(ostream& os, SegmentTree<X>& sg) {  //
              os << "[";
              for (int i = 0; i < sg.n; i++) {
                  os << sg[i] << (i == sg.n - 1 ? "]\n" : ", ");
              }
              return os;
          }
          #endif
  };/*}}}*/
  // sample of initialize SegmentTree:
  // -----------------------------------------------
  // auto mymin=[](auto a, auto b){return min(a,b);};
  // SegmentTree<ll> seg(a, mymin, 1e18);
  
  // auto mymax=[](auto a, auto b){return max(a,b);};
  // SegmentTree<ll> seg(a, mymax, -1e18);
  
  // auto add=[](auto a, auto b){return a+b;};
  // SegmentTree<ll> seg(a, add, 0);
  
  // pair<int, int> get_nearest_index_of_smaller_element(int i){
  //     auto left = seg.find_most_right(i, [&](auto x){return x < a[i];});
  //     auto right = seg.find_most_left(i, [&](auto x){return x < a[i];});
  //     return {left, right};
  // }
  // -----------------------------------------------
  // snippet:segment_tree }}}
  
  // snippet:edge {{{
  template<class Cost=ll>
  struct Edge {
      int from, to;
      Cost cost;
      int idx;
      Edge(){};
      Edge(int from, int to, Cost cost, int idx)
          : from(from), to(to), cost(cost), idx(idx) {}
  
      friend ostream& operator<<(ostream& os, const Edge& e) {
          // os << "(f:" << e.from << ", t:" << e.to << ", c:" << e.cost << ", i" << e.idx << ")";  // detailed
          os << "(" << e.from << "," << e.to << ")";
          return os;
      }
  };
  // snippet:edge }}}
  
  // snippet:UnionFind {{{
  struct UnionFind {
      vector<int> par;   // par[x]: parent of x. if root, -size.
      int gcount;         // count of groups
  
      UnionFind() {}
      UnionFind(int _n) : par(_n, -1), gcount(_n) {}
      bool merge(int x, int y) { 
          x = root(x);
          y = root(y);
          if (x != y) {
              if (par[y] < par[x]) swap(x, y);
              par[x] += par[y];
              par[y] = x;
              gcount--;
          }
          return x != y;
      } 
      int root(int x) {
          if (is_root(x)){
              return x;
          }
          else{
              return par[x] = root(par[x]);  // 経路圧縮
              // return root(par[x]);         // 経路圧縮なし
          }
      }
      bool is_root(int x) { return par[x] < 0; }
      bool same(int x, int y) { return root(x) == root(y); }
      int size(int x) { return -par[root(x)]; }
  
  #if defined(PCM) || defined(LOCAL)  // {{{
      friend ostream& operator<<(ostream& os, UnionFind& uf) {
          map<int, vector<int>> group;
          rep(i, sz(uf.par)) { group[uf.root(i)].pb(i); }
          os << endl;
          each(g, group) { os << g << endl; }
          return os;
      }
  #endif  // }}}
  };
  // snippet:UnionFind }}}
  
  // snippet:tree {{{
  template<class Cost=ll>
  struct tree { 
      int n;
      int root;
      vector<int> par;   // par[i]: dfs木における親
      vector<Cost> cost;  // par[i]: dfs木における親への辺のコスト
      vector<int> dfstrv;  // dfstrv[i]: dfs木でi番目に訪れるノード。dpはこれを逆順に回す
      vector<int> ord;    // ord[u]: uのdfs木における訪問順
      vector<int> end;    // end[u]: uのdfs終了時のカウンター
      vector<int> psize;  // psize[u]: uのpartial tree size
      // uの部分木は[ord[u], end[u])
      // ordとdfstrvは逆変換
      vector<int> depth;   // depth[i]: dfs木でのiの深さ
      vector<Cost> ldepth;  //  ldepth[i]: dfs木でのrootからの距離
      vector<vector<Edge<Cost>>> adj_list;       // 辺(隣接リスト)
      auto operator[](int pos) const { return adj_list[pos]; }
      vector<vector<int>> children;
      vector<int> euler_tour;
      vector<int> et_fpos;    // euler_tour first occurence position
      SegmentTree<int> _seg;  // seg(map(ord, euler_tour), mymin, 1e18)
      vector<int> head_of_comp;
      int _counter = 0;
  
      tree(){};/*{{{*/
      tree(int n)
          : n(n),
            par(n),
            cost(n),
            ord(n),
            end(n),
            psize(n),
            depth(n),
            ldepth(n),
            adj_list(n),
            children(n),
            et_fpos(n),
            head_of_comp(n){};/*}}}*/
      void add_edge(int u, int v, Cost cost, int idx=-1) { /*{{{*/
          adj_list[u].emplace_back(u, v, cost, idx);
          adj_list[v].emplace_back(v, u, cost, idx);
      }                             /*}}}*/
      void add_edge(int u, int v) { /*{{{*/
          adj_list[u].emplace_back(u, v, 1, -1);
          adj_list[v].emplace_back(v, u, 1, -1);
      }                      /*}}}*/
      void build(int _root) { /*{{{*/
          root = _root;
          _counter = 0;
          par[root] = -1;
          // cost[root] = -1;
          _dfs_psize(root, -1);
          _dfs_tree(root, -1, root);
          _dfs_et(root);
          vector<int> ini(2 * n - 1);
          rep(i, 2 * n - 1) ini[i] = ord[euler_tour[i]];
          _seg = SegmentTree<int>(
              ini, [](auto a, auto b) { return min(a, b); }, numeric_limits<int>().max());
      }                                /*}}}*/
      int _dfs_psize(int u, int pre) { /*{{{*/
          psize[u] = 1;
          each(edge, adj_list[u]) {
              if (edge.to == pre) continue;
              psize[u] += _dfs_psize(edge.to, u);
          }
          return psize[u];
      }                                               /*}}}*/
      void _dfs_tree(int u, int pre, int head_node) { /*{{{*/
          dfstrv.pb(u);
          ord[u] = _counter;
          if (pre != -1) {
              depth[u] = depth[pre] + 1;
              ldepth[u] = ldepth[pre] + cost[u];
          }
  
          _counter++;
          {
              // set most heavy child to top
              int max_psize = 0;
              int most_heavy_i = -1;
              rep(i, sz(adj_list[u])) {
                  if (adj_list[u][i].to == pre) continue;
                  if (psize[adj_list[u][i].to] > max_psize) {
                      most_heavy_i = i;
                      max_psize = psize[adj_list[u][i].to];
                  }
              }
              if (most_heavy_i != -1) swap(adj_list[u][most_heavy_i], adj_list[u][0]);
          }
  
          head_of_comp[u] = head_node;
          rep(i, sz(adj_list[u])) {
              int v = adj_list[u][i].to;
              if (v == pre) continue;
  
              children[u].pb(v);
              par[v] = u;
              cost[v] = adj_list[u][i].cost;
  
              if (i == 0)
                  _dfs_tree(v, u, head_node);  // continue components
              else
                  _dfs_tree(v, u, v);  // new
          }
          end[u] = _counter;
      }                     /*}}}*/
      void _dfs_et(int u) { /*{{{*/
          et_fpos[u] = euler_tour.size();
          euler_tour.pb(u);
          each(v, children[u]) {
              _dfs_et(v);
              euler_tour.pb(u);
          }
      }                       /*}}}*/
      int lca(int u, int v) { /*{{{*/
          if (u == v) return u;
          if (et_fpos[u] > et_fpos[v]) swap(u, v);
          return dfstrv[_seg.query(et_fpos[u], et_fpos[v])];
      }                        /*}}}*/
      int dist(int u, int v) { /*{{{*/
          int p = lca(u, v);
          return depth[u] + depth[v] - 2 * depth[p];
      }                          /*}}}*/
      Cost ldist(int u, int v) {  // length dist{{{
          int p = lca(u, v);
          return ldepth[u] + ldepth[v] - 2 * ldepth[p];
      }                           /*}}}*/
      pair<int, int> diameter() { /*{{{*/
          int u, v;
          Cost max_len = *max_element(all(ldepth));
          rep(i, n) {
              if (ldepth[i] == max_len) {
                  u = i;
                  break;
              }
          }
          Cost md = -1;
          rep(i, n) {
              Cost d = ldist(u, i);
              if (d > md) {
                  v = i;
                  md = d;
              }
          }
          return mp(u, v);
      }                                                /*}}}*/
      vector<pair<int, int>> hld_path(int u, int v, bool for_edge=true) {  //{{{
          // 閉区間をvectorで返す。for_edge=trueでlcaは除いて返すことに注意。
          vector<pair<int, int>> res;
          while (head_of_comp[u] != head_of_comp[v]) {
              if (depth[head_of_comp[u]] < depth[head_of_comp[v]]) {
                  res.push_back({ord[head_of_comp[v]], ord[v]});
                  v = par[head_of_comp[v]];
              } else {
                  res.push_back({ord[head_of_comp[u]], ord[u]});
                  u = par[head_of_comp[u]];
              }
          }
          res.push_back({min(ord[u], ord[v]) + (for_edge?1:0), max(ord[u], ord[v])});
          return res;
      }                              //}}}
  #if defined(PCM) || defined(LOCAL) /*{{{*/
      friend ostream& operator<<(ostream& os, const tree& tr) {
          os << endl;
          os << "par:         " << tr.par << endl;
          os << "cost:        " << tr.cost << endl;
          os << "dfstrv:      " << tr.dfstrv << endl;
          os << "ord:         " << tr.ord << endl;
          os << "end:         " << tr.end << endl;
          os << "depth:       " << tr.depth << endl;
          os << "children:    " << tr.children << endl;
          os << "euler_tour:  " << tr.euler_tour << endl;
          os << "et_fpos:     " << tr.et_fpos << endl;
          os << "head_of_comp:" << tr.head_of_comp << endl;
          return os;
      }
  #endif /*}}}*/
  }; 
  // snippet:tree }}}
  
  // snippet:Graph {{{
  template<class Cost=ll>
  struct Graph {
      using Pos = int;  // int以外には対応しない。
  
      int n;  // 頂点数
      vector<vector<Edge<Cost>>> adj_list;
      auto operator[](Pos pos) const { return adj_list[pos]; }
      vector<Edge<Cost>> edges;
      tree<Cost> tr;
      Pos root;
      vector<int> _used_in_dfs;
      vector<int> lowlink;
      Cost zerocost;
      Cost infcost;
  
      Graph() {}
      Graph(int _n) : n(_n), adj_list(_n), tr(n), _used_in_dfs(n), zerocost(0LL), infcost(INF) { }
      Graph(int _n, Cost zc, Cost ic) : n(_n), adj_list(_n), tr(n), _used_in_dfs(n), zerocost(zc), infcost(ic) { }
  
      void add_edge(Pos from, Pos to, Cost cost, int idx=-1) {/*{{{*/
          adj_list[from].emplace_back(from, to, cost, idx);
          edges.emplace_back(from, to, cost, idx);
      }
      void add_edge(Pos from, Pos to) {  // for ll
          adj_list[from].emplace_back(from, to, 1, -1);
          edges.emplace_back(from, to, 1, -1);
      }/*}}}*/
  
      void build_tree(Pos _root) {/*{{{*/
          root = _root;
          _dfs_tree(root);
          tr.build(root);
          _make_lowlink();
      }/*}}}*/
  
      vector<int> make_bipartite() {/*{{{*/
          UnionFind buf(2 * n);
          rep(u, n) {
              each(e, adj_list[u]) {
                  buf.merge(u, e.to + n);
                  buf.merge(e.to, u + n);
              }
          }
  
          vector<int> res(n, -1);
          rep(u, n) {
              if (buf.same(u, u + n)) return res;
          }
          rep(u, n) {
              if (buf.same(0, u)) res[u] = 0;
              else res[u] = 1;
          }
          return res;
      }/*}}}*/
  
      void _dfs_tree(Pos u) {/*{{{*/
          _used_in_dfs[u] = 1;
          each(e, adj_list[u]) {
              if (_used_in_dfs[e.to]) continue;
              tr.add_edge(u, e.to, e.cost);
              _dfs_tree(e.to);
          }
      }/*}}}*/
  
      void _make_lowlink() {/*{{{*/
          lowlink = vector<Pos>(n, numeric_limits<Pos>().max());
          r_rep(i, n) {
              Pos u = tr.dfstrv[i];
              chmin(lowlink[u], tr.ord[u]);
  
              each(e, adj_list[u]) {
                  if (e.to == tr.par[u])
                      continue;
                  else if (tr.ord[e.to] < tr.ord[u]) {
                      chmin(lowlink[u], tr.ord[e.to]);
                  } else {
                      chmin(lowlink[u], lowlink[e.to]);
                  }
              }
          }
      }/*}}}*/
  
      vector<Pos> get_articulation_points() {/*{{{*/
          if (sz(lowlink) == 0) throw("make_lowlik() beforehand");
  
          vector<Pos> res;
          if (sz(tr.children[root]) > 1) {
              res.push_back(root);
          }
          rep(u, 0, n) {
              if (u == root) continue;
              bool is_kan = false;
              each(v, tr.children[u]) {
                  if (tr.ord[u] <= lowlink[v]) {
                      is_kan = true;
                  }
              }
              if (is_kan) res.push_back(u);
          }
          return res;
      }/*}}}*/
  
      vector<Edge<Cost>> get_bridges() {/*{{{*/
          if (sz(lowlink) == 0) throw("make_lowlik() beforehand");
          vector<Edge<Cost>> res;
          each(edge, edges){
              if (tr.ord[edge.from] < lowlink[edge.to]) res.push_back(edge);
          }
          return res;
      }/*}}}*/
  
      vector<Edge<Cost>> kruskal_tree() {/*{{{*/
          // 使用される辺のvectorを返す
          vector<Edge<Cost>> res(n - 1);
          sort(all(edges), [&](auto l, auto r) { return l.cost < r.cost; });
          UnionFind uf(n);
  
          Cost total_cost = zerocost;
          int idx = 0;
          each(e, edges) {
              if (uf.same(e.from, e.to)) continue;
              uf.merge(e.from, e.to);
              total_cost = total_cost + e.cost;
              res[idx] = e;
              idx++;
          }
          assert(idx == n - 1);
  
          return res;
      }/*}}}*/
  
      vector<Cost> dijkstra(vector<Pos> starts) {  // 多点スタート{{{
          vector<Cost> dist(n, infcost);           // 最短距離
          PQ<pair<Cost, Pos>> pq;
          each(start, starts) {
              dist[start] = zerocost;
              pq.push(make_pair(zerocost, start));
          }
          while (!pq.empty()) {
              auto cp = pq.top();
              pq.pop();
              auto [cost, u] = cp;
              for (const auto& edge : adj_list[u]) {
                  Cost new_cost = cost + edge.cost;  // TODO: 問題によってはここが変更の必要あり
                  if (new_cost < dist[edge.to]) {
                      dist[edge.to] = new_cost;
                      pq.push(make_pair(new_cost, edge.to));
                  }
              }
          }
          return dist;
      };/*}}}*/
  
      vector<Cost> dijkstra(Pos start) {  // 1点スタート{{{
          vector<Pos> starts = {start};
          return dijkstra(starts);
      };/*}}}*/
  };
  // snippet:Graph }}}
  
  // snippet:local_min_cycle_directed {{{
  // verified by https://atcoder.jp/contests/abc142/tasks/abc142_f
  // 有向グラフの極小閉路の見つけ方（線形✕logくらい）
  // ・dfsでひとつ閉路をみつける（けんちょんさんのdfsの記事）
  // ・全辺を走査してショートカットの辺があれば不要なノードを削除していく。サイクルは(index, node-num)のsetで管理しておくと各ノードの削除はlog
  
  template<class T>
  vec<int> local_min_cycle_directed(Graph<T>& g){
      int n = g.n;
      vec<bool> seen(n);
      vec<bool> finished(n);
      vec<int> hist;
      bool exist_loop = false;
      int starting_point = -1;
      auto dfs = [&](const auto& dfs, int u, int pre) -> void {
          seen[u] = true;
          hist.push_back(u);
          each(e, g[u]){
              if (e.to == pre) continue;
              else if (finished[e.to]) continue;
              else if (seen[e.to]){
                  starting_point = e.to;
                  exist_loop = true;
                  return;
              }
              else{
                  dfs(dfs, e.to, u);
              }
              if (exist_loop) return;
          }
          hist.pop_back();
          finished[u] = true;
          return;
      };
  
      rep(u, n){
          if (finished[u]) continue;
          dfs(dfs, u, -1);
          if (exist_loop){
              vec<int> loop;
              r_rep(i, sz(hist)){
                  loop.pb(hist[i]);
                  if (hist[i] == starting_point) break;
              }
              reverse(all(loop));
              int m = sz(loop);
  
              // find short cut
              map<int, int> pos;
              rep(i, m) pos[loop[i]] = i;
              vec<int> ans;
              int next_right = -1;
              int next_left = -1;
              rep(i, m) {
                  if (next_right == -1 || next_right == i){
                      ans.pb(loop[i]);
                      next_right = -1;
                      each(e, g[loop[i]]){
                          if (e.to != loop[(i+1)%m] && pos.find(e.to) != pos.end()) {
                              if (pos[e.to] < i)
                                  chmax(next_left, pos[e.to]); // back-edge
                              else
                                  chmax(next_right, pos[e.to]); // to-edge
                          }
                      }
                      if (next_left != -1){
                          ans.clear();
                          rep(j, next_left, i+1){
                              if (pos.find(loop[j]) != pos.end()) ans.pb(loop[j]);
                          }
                          return ans;
                      }
                  }
                  else{
                      pos.erase(loop[i]);
                  }
              }
              return ans;
          }
      }
      return {};
  }
  // snippet:local_min_cycle_directed }}}


snippet unionfind_with_potential
  // snippet:unionfind_with_potential {{{
  template<class Pot = ll>  // Pot: Abel
  struct UnionFind {
      vector<int> par;   // par[x]: parent of x. if root, -size.
      int gcount;         // count of groups
      vector<Pot>  diff;
      UnionFind() {}
      UnionFind(int _n, Pot SUM_UNITY = 0) : par(_n, -1), gcount(_n), diff(_n, SUM_UNITY) {}
      bool merge(int x, int y, Pot d) { /*{{{*/
          // d:= wight(y) - weight(x)
          int rx = root(x);
          int ry = root(y);
          if (rx != ry) {
              if (par[ry] >= par[rx]) {
                  par[rx] += par[ry];
                  par[ry] = rx;
                  diff[ry] = diff[x] + d + (-diff[y]);
              }
              else{
                  par[ry] += par[rx];
                  par[rx] = ry;
                  diff[rx] = (-diff[x]) + (-d) + diff[y];
              }
              gcount--;
          }
          else{
              if (weight(y) + (-weight(x)) != d){
                  throw runtime_error("contradiction exist");
              }
          }
          return rx != ry;
      } /*}}}*/
      int root(int x) {/*{{{*/
          if (is_root(x)){
              return x;
          }
          else{
              int r = root(par[x]);
              diff[x] += diff[par[x]];
              par[x] = r;
              return par[x];
          }
      }/*}}}*/
      Pot weight(int x){/*{{{*/
          root(x); // 経路圧縮
          return diff[x];
      }/*}}}*/
      Pot diff(int x, int y){/*{{{*/
          if (!same(x, y)){
              string s = to_string(x) + " and " + to_string(y) + " are not in the same group.";
              throw invalid_argument(s);
          }
          else{
              return weight(y) + (-weight(x));
          }
      }/*}}}*/
      bool is_root(int x) { return par[x] < 0; }
      bool same(int x, int y) { return root(x) == root(y); }
      int size(int x) { return -par[root(x)]; }
  #if defined(PCM) || defined(LOCAL)  // {{{
      friend ostream& operator<<(ostream& os, UnionFind& uf) {
          map<int, vector<int>> group;
          rep(i, sz(uf.par)) { group[uf.root(i)].pb(i); }
          os << endl;
          each(g, group) { os << g << endl; }
          return os;
      }
  #endif  // }}}
  };
  // snippet:unionfind_with_potential }}}


snippet UnionFind
  // snippet:UnionFind {{{
  struct UnionFind {
      vector<int> par;   // par[x]: parent of x. if root, -size.
      int gcount;         // count of groups
  
      UnionFind() {}
      UnionFind(int _n) : par(_n, -1), gcount(_n) {}
      bool merge(int x, int y) { 
          x = root(x);
          y = root(y);
          if (x != y) {
              if (par[y] < par[x]) swap(x, y);
              par[x] += par[y];
              par[y] = x;
              gcount--;
          }
          return x != y;
      } 
      int root(int x) {
          if (is_root(x)){
              return x;
          }
          else{
              return par[x] = root(par[x]);  // 経路圧縮
              // return root(par[x]);         // 経路圧縮なし
          }
      }
      bool is_root(int x) { return par[x] < 0; }
      bool same(int x, int y) { return root(x) == root(y); }
      int size(int x) { return -par[root(x)]; }
  
  #if defined(PCM) || defined(LOCAL)  // {{{
      friend ostream& operator<<(ostream& os, UnionFind& uf) {
          map<int, vector<int>> group;
          rep(i, sz(uf.par)) { group[uf.root(i)].pb(i); }
          os << endl;
          each(g, group) { os << g << endl; }
          return os;
      }
  #endif  // }}}
  };
  // snippet:UnionFind }}}


snippet Graph
  // snippet:segment_tree {{{
  template <typename X> struct SegmentTree {  // {{{
      private:
          using F = function<X(X, X)>;
          using index = int;
          int n;  // 元の配列のサイズ
          int N;  // n以上の最小の2冪
          vector<X> node;
          F merge;
          X identity;
  
      public:
          SegmentTree() {}
          SegmentTree(vector<X> a, F f, X id) : merge(f), identity(id) {
              n = a.size();
              N = 1;
              while (N < n) N *= 2;
              node.resize(2 * N - 1, identity);
              for (int i = 0; i < n; i++) node[i + N - 1] = a[i];
              for (int i = N - 2; i >= 0; i--)
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
          }
          SegmentTree(int sz, F f, X id) : SegmentTree(vector<X>(sz, id), f, id) {}
  
          X& operator[](index i) { return node[i + N - 1]; }
  
          void set(index i, X val) {
              i += (N - 1);
              node[i] = val;
              while (i > 0) {
                  i = (i - 1) / 2;
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
              }
          }
  
          void add(index i, X val) {
              i += (N - 1);
              node[i] += val;
              while (i > 0) {
                  i = (i - 1) / 2;
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
              }
          }
  
          // query for [a, b)
          X query(index a, index b, int k = 0, index l = 0, index r = -1) {
              if (r < 0) r = N;
              if (r <= a || b <= l) return identity;
              if (a <= l && r <= b) return node[k];
  
              X vl = query(a, b, 2 * k + 1, l, (l + r) / 2);
              X vr = query(a, b, 2 * k + 2, (l + r) / 2, r);
              return merge(vl, vr);
          }
  
          index find_most_left(index l, const function<bool(X)>& is_ok){
              // lから右に探していってis_okが初めて成り立つようなindexを返す。
              // assume query(l, *) has monotonity
              // return index i s.t is_ok(query(l, i)) does not holds, but is_ok(query(l, i+1)) does.
              // if such i does not exist, return n
              index res = _find_most_left(l, is_ok, 0, 0, N, identity).first;
              assert(l <= res);
              return res;
          }
          pair<index, X> _find_most_left(index a, const function<bool(X)>& is_ok, int k, index l, index r, X left_value){
              // params:
                  // left_value = (a < l ? query(a, l) : ex)
              // return (index i, X v)
                  // i is the index in [a, n)^[l, r) s.t query(a, i+1) is ok but query(a, i) isn't ok. if such i does not exist, i = n
                  // v is the value s.t query(a, r)
  
              if (r <= a) return {n, identity};  // 区間が全く被っていない
              else if (a <= l && !is_ok(merge(left_value, node[k]))) return {n, merge(left_value, node[k])};
              else if (k >= N-1) return {k - (N-1), merge(left_value, node[k])};
              else{
                  auto [vl, xl] = _find_most_left(a, is_ok, 2 * k + 1, l, (l + r) / 2, left_value);
                  if (vl != n) return {vl, xl};
                  auto [vr, xr] = _find_most_left(a, is_ok, 2 * k + 2, (l + r) / 2, r, xl);
                  return {vr, xr};
              }
          }
  
          index find_most_right(index r, const function<bool(X)>& is_ok){
              // rから左に探していってis_okが初めて成り立つようなindexを返す。
              // assume query(*, r) has monotonity
              // return index i s.t is_ok(query(i+1, r+1)) does not holds, but is_ok(query(i, r+1)) does.
              // if such i does not exist, return -1
              index res = _find_most_right(r+1, is_ok, 0, 0, N, identity).first;
              assert(res <= r);
              return res;
          }
          pair<index, X> _find_most_right(index b, const function<bool(X)>& is_ok, int k, index l, index r, X right_value){
              if (b <= l) return {-1, identity};  // 区間が全く被っていない
              else if (r <= b && !is_ok(merge(node[k], right_value))) return {-1, merge(node[k], right_value)};
              else if (k >= N-1) return {k - (N-1), merge(node[k], right_value)};
              else{
                  auto [vr, xr] = _find_most_right(b, is_ok, 2 * k + 2, (l + r) / 2, r, right_value);
                  if (vr != -1) return {vr, xr};
                  auto [vl, xl] = _find_most_right(b, is_ok, 2 * k + 1, l, (l + r) / 2, xr);
                  return {vl, xl};
              }
          }
  
          #if defined(PCM) || defined(LOCAL)
          friend ostream& operator<<(ostream& os, SegmentTree<X>& sg) {  //
              os << "[";
              for (int i = 0; i < sg.n; i++) {
                  os << sg[i] << (i == sg.n - 1 ? "]\n" : ", ");
              }
              return os;
          }
          #endif
  };/*}}}*/
  // sample of initialize SegmentTree:
  // -----------------------------------------------
  // auto mymin=[](auto a, auto b){return min(a,b);};
  // SegmentTree<ll> seg(a, mymin, 1e18);
  
  // auto mymax=[](auto a, auto b){return max(a,b);};
  // SegmentTree<ll> seg(a, mymax, -1e18);
  
  // auto add=[](auto a, auto b){return a+b;};
  // SegmentTree<ll> seg(a, add, 0);
  
  // pair<int, int> get_nearest_index_of_smaller_element(int i){
  //     auto left = seg.find_most_right(i, [&](auto x){return x < a[i];});
  //     auto right = seg.find_most_left(i, [&](auto x){return x < a[i];});
  //     return {left, right};
  // }
  // -----------------------------------------------
  // snippet:segment_tree }}}
  
  // snippet:edge {{{
  template<class Cost=ll>
  struct Edge {
      int from, to;
      Cost cost;
      int idx;
      Edge(){};
      Edge(int from, int to, Cost cost, int idx)
          : from(from), to(to), cost(cost), idx(idx) {}
  
      friend ostream& operator<<(ostream& os, const Edge& e) {
          // os << "(f:" << e.from << ", t:" << e.to << ", c:" << e.cost << ", i" << e.idx << ")";  // detailed
          os << "(" << e.from << "," << e.to << ")";
          return os;
      }
  };
  // snippet:edge }}}
  
  // snippet:UnionFind {{{
  struct UnionFind {
      vector<int> par;   // par[x]: parent of x. if root, -size.
      int gcount;         // count of groups
  
      UnionFind() {}
      UnionFind(int _n) : par(_n, -1), gcount(_n) {}
      bool merge(int x, int y) { 
          x = root(x);
          y = root(y);
          if (x != y) {
              if (par[y] < par[x]) swap(x, y);
              par[x] += par[y];
              par[y] = x;
              gcount--;
          }
          return x != y;
      } 
      int root(int x) {
          if (is_root(x)){
              return x;
          }
          else{
              return par[x] = root(par[x]);  // 経路圧縮
              // return root(par[x]);         // 経路圧縮なし
          }
      }
      bool is_root(int x) { return par[x] < 0; }
      bool same(int x, int y) { return root(x) == root(y); }
      int size(int x) { return -par[root(x)]; }
  
  #if defined(PCM) || defined(LOCAL)  // {{{
      friend ostream& operator<<(ostream& os, UnionFind& uf) {
          map<int, vector<int>> group;
          rep(i, sz(uf.par)) { group[uf.root(i)].pb(i); }
          os << endl;
          each(g, group) { os << g << endl; }
          return os;
      }
  #endif  // }}}
  };
  // snippet:UnionFind }}}
  
  // snippet:tree {{{
  template<class Cost=ll>
  struct tree { 
      int n;
      int root;
      vector<int> par;   // par[i]: dfs木における親
      vector<Cost> cost;  // par[i]: dfs木における親への辺のコスト
      vector<int> dfstrv;  // dfstrv[i]: dfs木でi番目に訪れるノード。dpはこれを逆順に回す
      vector<int> ord;    // ord[u]: uのdfs木における訪問順
      vector<int> end;    // end[u]: uのdfs終了時のカウンター
      vector<int> psize;  // psize[u]: uのpartial tree size
      // uの部分木は[ord[u], end[u])
      // ordとdfstrvは逆変換
      vector<int> depth;   // depth[i]: dfs木でのiの深さ
      vector<Cost> ldepth;  //  ldepth[i]: dfs木でのrootからの距離
      vector<vector<Edge<Cost>>> adj_list;       // 辺(隣接リスト)
      auto operator[](int pos) const { return adj_list[pos]; }
      vector<vector<int>> children;
      vector<int> euler_tour;
      vector<int> et_fpos;    // euler_tour first occurence position
      SegmentTree<int> _seg;  // seg(map(ord, euler_tour), mymin, 1e18)
      vector<int> head_of_comp;
      int _counter = 0;
  
      tree(){};/*{{{*/
      tree(int n)
          : n(n),
            par(n),
            cost(n),
            ord(n),
            end(n),
            psize(n),
            depth(n),
            ldepth(n),
            adj_list(n),
            children(n),
            et_fpos(n),
            head_of_comp(n){};/*}}}*/
      void add_edge(int u, int v, Cost cost, int idx=-1) { /*{{{*/
          adj_list[u].emplace_back(u, v, cost, idx);
          adj_list[v].emplace_back(v, u, cost, idx);
      }                             /*}}}*/
      void add_edge(int u, int v) { /*{{{*/
          adj_list[u].emplace_back(u, v, 1, -1);
          adj_list[v].emplace_back(v, u, 1, -1);
      }                      /*}}}*/
      void build(int _root) { /*{{{*/
          root = _root;
          _counter = 0;
          par[root] = -1;
          // cost[root] = -1;
          _dfs_psize(root, -1);
          _dfs_tree(root, -1, root);
          _dfs_et(root);
          vector<int> ini(2 * n - 1);
          rep(i, 2 * n - 1) ini[i] = ord[euler_tour[i]];
          _seg = SegmentTree<int>(
              ini, [](auto a, auto b) { return min(a, b); }, numeric_limits<int>().max());
      }                                /*}}}*/
      int _dfs_psize(int u, int pre) { /*{{{*/
          psize[u] = 1;
          each(edge, adj_list[u]) {
              if (edge.to == pre) continue;
              psize[u] += _dfs_psize(edge.to, u);
          }
          return psize[u];
      }                                               /*}}}*/
      void _dfs_tree(int u, int pre, int head_node) { /*{{{*/
          dfstrv.pb(u);
          ord[u] = _counter;
          if (pre != -1) {
              depth[u] = depth[pre] + 1;
              ldepth[u] = ldepth[pre] + cost[u];
          }
  
          _counter++;
          {
              // set most heavy child to top
              int max_psize = 0;
              int most_heavy_i = -1;
              rep(i, sz(adj_list[u])) {
                  if (adj_list[u][i].to == pre) continue;
                  if (psize[adj_list[u][i].to] > max_psize) {
                      most_heavy_i = i;
                      max_psize = psize[adj_list[u][i].to];
                  }
              }
              if (most_heavy_i != -1) swap(adj_list[u][most_heavy_i], adj_list[u][0]);
          }
  
          head_of_comp[u] = head_node;
          rep(i, sz(adj_list[u])) {
              int v = adj_list[u][i].to;
              if (v == pre) continue;
  
              children[u].pb(v);
              par[v] = u;
              cost[v] = adj_list[u][i].cost;
  
              if (i == 0)
                  _dfs_tree(v, u, head_node);  // continue components
              else
                  _dfs_tree(v, u, v);  // new
          }
          end[u] = _counter;
      }                     /*}}}*/
      void _dfs_et(int u) { /*{{{*/
          et_fpos[u] = euler_tour.size();
          euler_tour.pb(u);
          each(v, children[u]) {
              _dfs_et(v);
              euler_tour.pb(u);
          }
      }                       /*}}}*/
      int lca(int u, int v) { /*{{{*/
          if (u == v) return u;
          if (et_fpos[u] > et_fpos[v]) swap(u, v);
          return dfstrv[_seg.query(et_fpos[u], et_fpos[v])];
      }                        /*}}}*/
      int dist(int u, int v) { /*{{{*/
          int p = lca(u, v);
          return depth[u] + depth[v] - 2 * depth[p];
      }                          /*}}}*/
      Cost ldist(int u, int v) {  // length dist{{{
          int p = lca(u, v);
          return ldepth[u] + ldepth[v] - 2 * ldepth[p];
      }                           /*}}}*/
      pair<int, int> diameter() { /*{{{*/
          int u, v;
          Cost max_len = *max_element(all(ldepth));
          rep(i, n) {
              if (ldepth[i] == max_len) {
                  u = i;
                  break;
              }
          }
          Cost md = -1;
          rep(i, n) {
              Cost d = ldist(u, i);
              if (d > md) {
                  v = i;
                  md = d;
              }
          }
          return mp(u, v);
      }                                                /*}}}*/
      vector<pair<int, int>> hld_path(int u, int v, bool for_edge=true) {  //{{{
          // 閉区間をvectorで返す。for_edge=trueでlcaは除いて返すことに注意。
          vector<pair<int, int>> res;
          while (head_of_comp[u] != head_of_comp[v]) {
              if (depth[head_of_comp[u]] < depth[head_of_comp[v]]) {
                  res.push_back({ord[head_of_comp[v]], ord[v]});
                  v = par[head_of_comp[v]];
              } else {
                  res.push_back({ord[head_of_comp[u]], ord[u]});
                  u = par[head_of_comp[u]];
              }
          }
          res.push_back({min(ord[u], ord[v]) + (for_edge?1:0), max(ord[u], ord[v])});
          return res;
      }                              //}}}
  #if defined(PCM) || defined(LOCAL) /*{{{*/
      friend ostream& operator<<(ostream& os, const tree& tr) {
          os << endl;
          os << "par:         " << tr.par << endl;
          os << "cost:        " << tr.cost << endl;
          os << "dfstrv:      " << tr.dfstrv << endl;
          os << "ord:         " << tr.ord << endl;
          os << "end:         " << tr.end << endl;
          os << "depth:       " << tr.depth << endl;
          os << "children:    " << tr.children << endl;
          os << "euler_tour:  " << tr.euler_tour << endl;
          os << "et_fpos:     " << tr.et_fpos << endl;
          os << "head_of_comp:" << tr.head_of_comp << endl;
          return os;
      }
  #endif /*}}}*/
  }; 
  // snippet:tree }}}
  
  // snippet:Graph {{{
  template<class Cost=ll>
  struct Graph {
      using Pos = int;  // int以外には対応しない。
  
      int n;  // 頂点数
      vector<vector<Edge<Cost>>> adj_list;
      auto operator[](Pos pos) const { return adj_list[pos]; }
      vector<Edge<Cost>> edges;
      tree<Cost> tr;
      Pos root;
      vector<int> _used_in_dfs;
      vector<int> lowlink;
      Cost zerocost;
      Cost infcost;
  
      Graph() {}
      Graph(int _n) : n(_n), adj_list(_n), tr(n), _used_in_dfs(n), zerocost(0LL), infcost(INF) { }
      Graph(int _n, Cost zc, Cost ic) : n(_n), adj_list(_n), tr(n), _used_in_dfs(n), zerocost(zc), infcost(ic) { }
  
      void add_edge(Pos from, Pos to, Cost cost, int idx=-1) {/*{{{*/
          adj_list[from].emplace_back(from, to, cost, idx);
          edges.emplace_back(from, to, cost, idx);
      }
      void add_edge(Pos from, Pos to) {  // for ll
          adj_list[from].emplace_back(from, to, 1, -1);
          edges.emplace_back(from, to, 1, -1);
      }/*}}}*/
  
      void build_tree(Pos _root) {/*{{{*/
          root = _root;
          _dfs_tree(root);
          tr.build(root);
          _make_lowlink();
      }/*}}}*/
  
      vector<int> make_bipartite() {/*{{{*/
          UnionFind buf(2 * n);
          rep(u, n) {
              each(e, adj_list[u]) {
                  buf.merge(u, e.to + n);
                  buf.merge(e.to, u + n);
              }
          }
  
          vector<int> res(n, -1);
          rep(u, n) {
              if (buf.same(u, u + n)) return res;
          }
          rep(u, n) {
              if (buf.same(0, u)) res[u] = 0;
              else res[u] = 1;
          }
          return res;
      }/*}}}*/
  
      void _dfs_tree(Pos u) {/*{{{*/
          _used_in_dfs[u] = 1;
          each(e, adj_list[u]) {
              if (_used_in_dfs[e.to]) continue;
              tr.add_edge(u, e.to, e.cost);
              _dfs_tree(e.to);
          }
      }/*}}}*/
  
      void _make_lowlink() {/*{{{*/
          lowlink = vector<Pos>(n, numeric_limits<Pos>().max());
          r_rep(i, n) {
              Pos u = tr.dfstrv[i];
              chmin(lowlink[u], tr.ord[u]);
  
              each(e, adj_list[u]) {
                  if (e.to == tr.par[u])
                      continue;
                  else if (tr.ord[e.to] < tr.ord[u]) {
                      chmin(lowlink[u], tr.ord[e.to]);
                  } else {
                      chmin(lowlink[u], lowlink[e.to]);
                  }
              }
          }
      }/*}}}*/
  
      vector<Pos> get_articulation_points() {/*{{{*/
          if (sz(lowlink) == 0) throw("make_lowlik() beforehand");
  
          vector<Pos> res;
          if (sz(tr.children[root]) > 1) {
              res.push_back(root);
          }
          rep(u, 0, n) {
              if (u == root) continue;
              bool is_kan = false;
              each(v, tr.children[u]) {
                  if (tr.ord[u] <= lowlink[v]) {
                      is_kan = true;
                  }
              }
              if (is_kan) res.push_back(u);
          }
          return res;
      }/*}}}*/
  
      vector<Edge<Cost>> get_bridges() {/*{{{*/
          if (sz(lowlink) == 0) throw("make_lowlik() beforehand");
          vector<Edge<Cost>> res;
          each(edge, edges){
              if (tr.ord[edge.from] < lowlink[edge.to]) res.push_back(edge);
          }
          return res;
      }/*}}}*/
  
      vector<Edge<Cost>> kruskal_tree() {/*{{{*/
          // 使用される辺のvectorを返す
          vector<Edge<Cost>> res(n - 1);
          sort(all(edges), [&](auto l, auto r) { return l.cost < r.cost; });
          UnionFind uf(n);
  
          Cost total_cost = zerocost;
          int idx = 0;
          each(e, edges) {
              if (uf.same(e.from, e.to)) continue;
              uf.merge(e.from, e.to);
              total_cost = total_cost + e.cost;
              res[idx] = e;
              idx++;
          }
          assert(idx == n - 1);
  
          return res;
      }/*}}}*/
  
      vector<Cost> dijkstra(vector<Pos> starts) {  // 多点スタート{{{
          vector<Cost> dist(n, infcost);           // 最短距離
          PQ<pair<Cost, Pos>> pq;
          each(start, starts) {
              dist[start] = zerocost;
              pq.push(make_pair(zerocost, start));
          }
          while (!pq.empty()) {
              auto cp = pq.top();
              pq.pop();
              auto [cost, u] = cp;
              for (const auto& edge : adj_list[u]) {
                  Cost new_cost = cost + edge.cost;  // TODO: 問題によってはここが変更の必要あり
                  if (new_cost < dist[edge.to]) {
                      dist[edge.to] = new_cost;
                      pq.push(make_pair(new_cost, edge.to));
                  }
              }
          }
          return dist;
      };/*}}}*/
  
      vector<Cost> dijkstra(Pos start) {  // 1点スタート{{{
          vector<Pos> starts = {start};
          return dijkstra(starts);
      };/*}}}*/
  };
  // snippet:Graph }}}


snippet scc
alias StronglyConnectedComponents
  // snippet:segment_tree {{{
  template <typename X> struct SegmentTree {  // {{{
      private:
          using F = function<X(X, X)>;
          using index = int;
          int n;  // 元の配列のサイズ
          int N;  // n以上の最小の2冪
          vector<X> node;
          F merge;
          X identity;
  
      public:
          SegmentTree() {}
          SegmentTree(vector<X> a, F f, X id) : merge(f), identity(id) {
              n = a.size();
              N = 1;
              while (N < n) N *= 2;
              node.resize(2 * N - 1, identity);
              for (int i = 0; i < n; i++) node[i + N - 1] = a[i];
              for (int i = N - 2; i >= 0; i--)
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
          }
          SegmentTree(int sz, F f, X id) : SegmentTree(vector<X>(sz, id), f, id) {}
  
          X& operator[](index i) { return node[i + N - 1]; }
  
          void set(index i, X val) {
              i += (N - 1);
              node[i] = val;
              while (i > 0) {
                  i = (i - 1) / 2;
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
              }
          }
  
          void add(index i, X val) {
              i += (N - 1);
              node[i] += val;
              while (i > 0) {
                  i = (i - 1) / 2;
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
              }
          }
  
          // query for [a, b)
          X query(index a, index b, int k = 0, index l = 0, index r = -1) {
              if (r < 0) r = N;
              if (r <= a || b <= l) return identity;
              if (a <= l && r <= b) return node[k];
  
              X vl = query(a, b, 2 * k + 1, l, (l + r) / 2);
              X vr = query(a, b, 2 * k + 2, (l + r) / 2, r);
              return merge(vl, vr);
          }
  
          index find_most_left(index l, const function<bool(X)>& is_ok){
              // lから右に探していってis_okが初めて成り立つようなindexを返す。
              // assume query(l, *) has monotonity
              // return index i s.t is_ok(query(l, i)) does not holds, but is_ok(query(l, i+1)) does.
              // if such i does not exist, return n
              index res = _find_most_left(l, is_ok, 0, 0, N, identity).first;
              assert(l <= res);
              return res;
          }
          pair<index, X> _find_most_left(index a, const function<bool(X)>& is_ok, int k, index l, index r, X left_value){
              // params:
                  // left_value = (a < l ? query(a, l) : ex)
              // return (index i, X v)
                  // i is the index in [a, n)^[l, r) s.t query(a, i+1) is ok but query(a, i) isn't ok. if such i does not exist, i = n
                  // v is the value s.t query(a, r)
  
              if (r <= a) return {n, identity};  // 区間が全く被っていない
              else if (a <= l && !is_ok(merge(left_value, node[k]))) return {n, merge(left_value, node[k])};
              else if (k >= N-1) return {k - (N-1), merge(left_value, node[k])};
              else{
                  auto [vl, xl] = _find_most_left(a, is_ok, 2 * k + 1, l, (l + r) / 2, left_value);
                  if (vl != n) return {vl, xl};
                  auto [vr, xr] = _find_most_left(a, is_ok, 2 * k + 2, (l + r) / 2, r, xl);
                  return {vr, xr};
              }
          }
  
          index find_most_right(index r, const function<bool(X)>& is_ok){
              // rから左に探していってis_okが初めて成り立つようなindexを返す。
              // assume query(*, r) has monotonity
              // return index i s.t is_ok(query(i+1, r+1)) does not holds, but is_ok(query(i, r+1)) does.
              // if such i does not exist, return -1
              index res = _find_most_right(r+1, is_ok, 0, 0, N, identity).first;
              assert(res <= r);
              return res;
          }
          pair<index, X> _find_most_right(index b, const function<bool(X)>& is_ok, int k, index l, index r, X right_value){
              if (b <= l) return {-1, identity};  // 区間が全く被っていない
              else if (r <= b && !is_ok(merge(node[k], right_value))) return {-1, merge(node[k], right_value)};
              else if (k >= N-1) return {k - (N-1), merge(node[k], right_value)};
              else{
                  auto [vr, xr] = _find_most_right(b, is_ok, 2 * k + 2, (l + r) / 2, r, right_value);
                  if (vr != -1) return {vr, xr};
                  auto [vl, xl] = _find_most_right(b, is_ok, 2 * k + 1, l, (l + r) / 2, xr);
                  return {vl, xl};
              }
          }
  
          #if defined(PCM) || defined(LOCAL)
          friend ostream& operator<<(ostream& os, SegmentTree<X>& sg) {  //
              os << "[";
              for (int i = 0; i < sg.n; i++) {
                  os << sg[i] << (i == sg.n - 1 ? "]\n" : ", ");
              }
              return os;
          }
          #endif
  };/*}}}*/
  // sample of initialize SegmentTree:
  // -----------------------------------------------
  // auto mymin=[](auto a, auto b){return min(a,b);};
  // SegmentTree<ll> seg(a, mymin, 1e18);
  
  // auto mymax=[](auto a, auto b){return max(a,b);};
  // SegmentTree<ll> seg(a, mymax, -1e18);
  
  // auto add=[](auto a, auto b){return a+b;};
  // SegmentTree<ll> seg(a, add, 0);
  
  // pair<int, int> get_nearest_index_of_smaller_element(int i){
  //     auto left = seg.find_most_right(i, [&](auto x){return x < a[i];});
  //     auto right = seg.find_most_left(i, [&](auto x){return x < a[i];});
  //     return {left, right};
  // }
  // -----------------------------------------------
  // snippet:segment_tree }}}
  
  // snippet:edge {{{
  template<class Cost=ll>
  struct Edge {
      int from, to;
      Cost cost;
      int idx;
      Edge(){};
      Edge(int from, int to, Cost cost, int idx)
          : from(from), to(to), cost(cost), idx(idx) {}
  
      friend ostream& operator<<(ostream& os, const Edge& e) {
          // os << "(f:" << e.from << ", t:" << e.to << ", c:" << e.cost << ", i" << e.idx << ")";  // detailed
          os << "(" << e.from << "," << e.to << ")";
          return os;
      }
  };
  // snippet:edge }}}
  
  // snippet:UnionFind {{{
  struct UnionFind {
      vector<int> par;   // par[x]: parent of x. if root, -size.
      int gcount;         // count of groups
  
      UnionFind() {}
      UnionFind(int _n) : par(_n, -1), gcount(_n) {}
      bool merge(int x, int y) { 
          x = root(x);
          y = root(y);
          if (x != y) {
              if (par[y] < par[x]) swap(x, y);
              par[x] += par[y];
              par[y] = x;
              gcount--;
          }
          return x != y;
      } 
      int root(int x) {
          if (is_root(x)){
              return x;
          }
          else{
              return par[x] = root(par[x]);  // 経路圧縮
              // return root(par[x]);         // 経路圧縮なし
          }
      }
      bool is_root(int x) { return par[x] < 0; }
      bool same(int x, int y) { return root(x) == root(y); }
      int size(int x) { return -par[root(x)]; }
  
  #if defined(PCM) || defined(LOCAL)  // {{{
      friend ostream& operator<<(ostream& os, UnionFind& uf) {
          map<int, vector<int>> group;
          rep(i, sz(uf.par)) { group[uf.root(i)].pb(i); }
          os << endl;
          each(g, group) { os << g << endl; }
          return os;
      }
  #endif  // }}}
  };
  // snippet:UnionFind }}}
  
  // snippet:tree {{{
  template<class Cost=ll>
  struct tree { 
      int n;
      int root;
      vector<int> par;   // par[i]: dfs木における親
      vector<Cost> cost;  // par[i]: dfs木における親への辺のコスト
      vector<int> dfstrv;  // dfstrv[i]: dfs木でi番目に訪れるノード。dpはこれを逆順に回す
      vector<int> ord;    // ord[u]: uのdfs木における訪問順
      vector<int> end;    // end[u]: uのdfs終了時のカウンター
      vector<int> psize;  // psize[u]: uのpartial tree size
      // uの部分木は[ord[u], end[u])
      // ordとdfstrvは逆変換
      vector<int> depth;   // depth[i]: dfs木でのiの深さ
      vector<Cost> ldepth;  //  ldepth[i]: dfs木でのrootからの距離
      vector<vector<Edge<Cost>>> adj_list;       // 辺(隣接リスト)
      auto operator[](int pos) const { return adj_list[pos]; }
      vector<vector<int>> children;
      vector<int> euler_tour;
      vector<int> et_fpos;    // euler_tour first occurence position
      SegmentTree<int> _seg;  // seg(map(ord, euler_tour), mymin, 1e18)
      vector<int> head_of_comp;
      int _counter = 0;
  
      tree(){};/*{{{*/
      tree(int n)
          : n(n),
            par(n),
            cost(n),
            ord(n),
            end(n),
            psize(n),
            depth(n),
            ldepth(n),
            adj_list(n),
            children(n),
            et_fpos(n),
            head_of_comp(n){};/*}}}*/
      void add_edge(int u, int v, Cost cost, int idx=-1) { /*{{{*/
          adj_list[u].emplace_back(u, v, cost, idx);
          adj_list[v].emplace_back(v, u, cost, idx);
      }                             /*}}}*/
      void add_edge(int u, int v) { /*{{{*/
          adj_list[u].emplace_back(u, v, 1, -1);
          adj_list[v].emplace_back(v, u, 1, -1);
      }                      /*}}}*/
      void build(int _root) { /*{{{*/
          root = _root;
          _counter = 0;
          par[root] = -1;
          // cost[root] = -1;
          _dfs_psize(root, -1);
          _dfs_tree(root, -1, root);
          _dfs_et(root);
          vector<int> ini(2 * n - 1);
          rep(i, 2 * n - 1) ini[i] = ord[euler_tour[i]];
          _seg = SegmentTree<int>(
              ini, [](auto a, auto b) { return min(a, b); }, numeric_limits<int>().max());
      }                                /*}}}*/
      int _dfs_psize(int u, int pre) { /*{{{*/
          psize[u] = 1;
          each(edge, adj_list[u]) {
              if (edge.to == pre) continue;
              psize[u] += _dfs_psize(edge.to, u);
          }
          return psize[u];
      }                                               /*}}}*/
      void _dfs_tree(int u, int pre, int head_node) { /*{{{*/
          dfstrv.pb(u);
          ord[u] = _counter;
          if (pre != -1) {
              depth[u] = depth[pre] + 1;
              ldepth[u] = ldepth[pre] + cost[u];
          }
  
          _counter++;
          {
              // set most heavy child to top
              int max_psize = 0;
              int most_heavy_i = -1;
              rep(i, sz(adj_list[u])) {
                  if (adj_list[u][i].to == pre) continue;
                  if (psize[adj_list[u][i].to] > max_psize) {
                      most_heavy_i = i;
                      max_psize = psize[adj_list[u][i].to];
                  }
              }
              if (most_heavy_i != -1) swap(adj_list[u][most_heavy_i], adj_list[u][0]);
          }
  
          head_of_comp[u] = head_node;
          rep(i, sz(adj_list[u])) {
              int v = adj_list[u][i].to;
              if (v == pre) continue;
  
              children[u].pb(v);
              par[v] = u;
              cost[v] = adj_list[u][i].cost;
  
              if (i == 0)
                  _dfs_tree(v, u, head_node);  // continue components
              else
                  _dfs_tree(v, u, v);  // new
          }
          end[u] = _counter;
      }                     /*}}}*/
      void _dfs_et(int u) { /*{{{*/
          et_fpos[u] = euler_tour.size();
          euler_tour.pb(u);
          each(v, children[u]) {
              _dfs_et(v);
              euler_tour.pb(u);
          }
      }                       /*}}}*/
      int lca(int u, int v) { /*{{{*/
          if (u == v) return u;
          if (et_fpos[u] > et_fpos[v]) swap(u, v);
          return dfstrv[_seg.query(et_fpos[u], et_fpos[v])];
      }                        /*}}}*/
      int dist(int u, int v) { /*{{{*/
          int p = lca(u, v);
          return depth[u] + depth[v] - 2 * depth[p];
      }                          /*}}}*/
      Cost ldist(int u, int v) {  // length dist{{{
          int p = lca(u, v);
          return ldepth[u] + ldepth[v] - 2 * ldepth[p];
      }                           /*}}}*/
      pair<int, int> diameter() { /*{{{*/
          int u, v;
          Cost max_len = *max_element(all(ldepth));
          rep(i, n) {
              if (ldepth[i] == max_len) {
                  u = i;
                  break;
              }
          }
          Cost md = -1;
          rep(i, n) {
              Cost d = ldist(u, i);
              if (d > md) {
                  v = i;
                  md = d;
              }
          }
          return mp(u, v);
      }                                                /*}}}*/
      vector<pair<int, int>> hld_path(int u, int v, bool for_edge=true) {  //{{{
          // 閉区間をvectorで返す。for_edge=trueでlcaは除いて返すことに注意。
          vector<pair<int, int>> res;
          while (head_of_comp[u] != head_of_comp[v]) {
              if (depth[head_of_comp[u]] < depth[head_of_comp[v]]) {
                  res.push_back({ord[head_of_comp[v]], ord[v]});
                  v = par[head_of_comp[v]];
              } else {
                  res.push_back({ord[head_of_comp[u]], ord[u]});
                  u = par[head_of_comp[u]];
              }
          }
          res.push_back({min(ord[u], ord[v]) + (for_edge?1:0), max(ord[u], ord[v])});
          return res;
      }                              //}}}
  #if defined(PCM) || defined(LOCAL) /*{{{*/
      friend ostream& operator<<(ostream& os, const tree& tr) {
          os << endl;
          os << "par:         " << tr.par << endl;
          os << "cost:        " << tr.cost << endl;
          os << "dfstrv:      " << tr.dfstrv << endl;
          os << "ord:         " << tr.ord << endl;
          os << "end:         " << tr.end << endl;
          os << "depth:       " << tr.depth << endl;
          os << "children:    " << tr.children << endl;
          os << "euler_tour:  " << tr.euler_tour << endl;
          os << "et_fpos:     " << tr.et_fpos << endl;
          os << "head_of_comp:" << tr.head_of_comp << endl;
          return os;
      }
  #endif /*}}}*/
  }; 
  // snippet:tree }}}
  
  // snippet:Graph {{{
  template<class Cost=ll>
  struct Graph {
      using Pos = int;  // int以外には対応しない。
  
      int n;  // 頂点数
      vector<vector<Edge<Cost>>> adj_list;
      auto operator[](Pos pos) const { return adj_list[pos]; }
      vector<Edge<Cost>> edges;
      tree<Cost> tr;
      Pos root;
      vector<int> _used_in_dfs;
      vector<int> lowlink;
      Cost zerocost;
      Cost infcost;
  
      Graph() {}
      Graph(int _n) : n(_n), adj_list(_n), tr(n), _used_in_dfs(n), zerocost(0LL), infcost(INF) { }
      Graph(int _n, Cost zc, Cost ic) : n(_n), adj_list(_n), tr(n), _used_in_dfs(n), zerocost(zc), infcost(ic) { }
  
      void add_edge(Pos from, Pos to, Cost cost, int idx=-1) {/*{{{*/
          adj_list[from].emplace_back(from, to, cost, idx);
          edges.emplace_back(from, to, cost, idx);
      }
      void add_edge(Pos from, Pos to) {  // for ll
          adj_list[from].emplace_back(from, to, 1, -1);
          edges.emplace_back(from, to, 1, -1);
      }/*}}}*/
  
      void build_tree(Pos _root) {/*{{{*/
          root = _root;
          _dfs_tree(root);
          tr.build(root);
          _make_lowlink();
      }/*}}}*/
  
      vector<int> make_bipartite() {/*{{{*/
          UnionFind buf(2 * n);
          rep(u, n) {
              each(e, adj_list[u]) {
                  buf.merge(u, e.to + n);
                  buf.merge(e.to, u + n);
              }
          }
  
          vector<int> res(n, -1);
          rep(u, n) {
              if (buf.same(u, u + n)) return res;
          }
          rep(u, n) {
              if (buf.same(0, u)) res[u] = 0;
              else res[u] = 1;
          }
          return res;
      }/*}}}*/
  
      void _dfs_tree(Pos u) {/*{{{*/
          _used_in_dfs[u] = 1;
          each(e, adj_list[u]) {
              if (_used_in_dfs[e.to]) continue;
              tr.add_edge(u, e.to, e.cost);
              _dfs_tree(e.to);
          }
      }/*}}}*/
  
      void _make_lowlink() {/*{{{*/
          lowlink = vector<Pos>(n, numeric_limits<Pos>().max());
          r_rep(i, n) {
              Pos u = tr.dfstrv[i];
              chmin(lowlink[u], tr.ord[u]);
  
              each(e, adj_list[u]) {
                  if (e.to == tr.par[u])
                      continue;
                  else if (tr.ord[e.to] < tr.ord[u]) {
                      chmin(lowlink[u], tr.ord[e.to]);
                  } else {
                      chmin(lowlink[u], lowlink[e.to]);
                  }
              }
          }
      }/*}}}*/
  
      vector<Pos> get_articulation_points() {/*{{{*/
          if (sz(lowlink) == 0) throw("make_lowlik() beforehand");
  
          vector<Pos> res;
          if (sz(tr.children[root]) > 1) {
              res.push_back(root);
          }
          rep(u, 0, n) {
              if (u == root) continue;
              bool is_kan = false;
              each(v, tr.children[u]) {
                  if (tr.ord[u] <= lowlink[v]) {
                      is_kan = true;
                  }
              }
              if (is_kan) res.push_back(u);
          }
          return res;
      }/*}}}*/
  
      vector<Edge<Cost>> get_bridges() {/*{{{*/
          if (sz(lowlink) == 0) throw("make_lowlik() beforehand");
          vector<Edge<Cost>> res;
          each(edge, edges){
              if (tr.ord[edge.from] < lowlink[edge.to]) res.push_back(edge);
          }
          return res;
      }/*}}}*/
  
      vector<Edge<Cost>> kruskal_tree() {/*{{{*/
          // 使用される辺のvectorを返す
          vector<Edge<Cost>> res(n - 1);
          sort(all(edges), [&](auto l, auto r) { return l.cost < r.cost; });
          UnionFind uf(n);
  
          Cost total_cost = zerocost;
          int idx = 0;
          each(e, edges) {
              if (uf.same(e.from, e.to)) continue;
              uf.merge(e.from, e.to);
              total_cost = total_cost + e.cost;
              res[idx] = e;
              idx++;
          }
          assert(idx == n - 1);
  
          return res;
      }/*}}}*/
  
      vector<Cost> dijkstra(vector<Pos> starts) {  // 多点スタート{{{
          vector<Cost> dist(n, infcost);           // 最短距離
          PQ<pair<Cost, Pos>> pq;
          each(start, starts) {
              dist[start] = zerocost;
              pq.push(make_pair(zerocost, start));
          }
          while (!pq.empty()) {
              auto cp = pq.top();
              pq.pop();
              auto [cost, u] = cp;
              for (const auto& edge : adj_list[u]) {
                  Cost new_cost = cost + edge.cost;  // TODO: 問題によってはここが変更の必要あり
                  if (new_cost < dist[edge.to]) {
                      dist[edge.to] = new_cost;
                      pq.push(make_pair(new_cost, edge.to));
                  }
              }
          }
          return dist;
      };/*}}}*/
  
      vector<Cost> dijkstra(Pos start) {  // 1点スタート{{{
          vector<Pos> starts = {start};
          return dijkstra(starts);
      };/*}}}*/
  };
  // snippet:Graph }}}
  
  // snippet:scc {{{
  template<class T = ll>
  struct StronglyConnectedComponents {
      const Graph<T> &g;  //{{{
      vector<int> comp;  // comp[i]: iが属する強連結成分が何番目の成分か
      Graph<> dag;  // 縮約されたDAG graph. sizeをとれば強連結成分の個数が分かる。
      Graph<> _rg;  // reversed graph
      vector<int> _order;  // order[i]: 帰りがけ順
      vector<int> _used;
  
      StronglyConnectedComponents(Graph<T> &_g)
          : g(_g), comp(_g.n, -1), _rg(_g.n), _used(_g.n) {
          for (int i = 0; i < g.n; i++) {
              for (auto e : g[i]) {
                  _rg.add_edge(e.to, e.from);
              }
          }
          _build();
      }
  
      int operator[](int k) { return comp[k]; }
  
      void _build() {
          for (int i = 0; i < g.n; i++) _dfs(i);
          reverse(begin(_order), end(_order));
          int cnt = 0;
          for (int u : _order)
              if (comp[u] == -1) _rdfs(u, cnt), cnt++;
  
          dag = Graph(cnt);
          for (int u = 0; u < g.n; u++) {
              for (auto &e : g[u]) {
                  if (comp[u] == comp[e.to]) continue;
                  dag.add_edge(comp[u], comp[e.to]);
              }
          }
      }
  
      void _dfs(int idx) {
          if (_used[idx]) return;
          _used[idx] = true;
          for (auto &e : g[idx]) _dfs(e.to);
          _order.push_back(idx);
      }
  
      void _rdfs(int idx, int cnt) {
          if (comp[idx] != -1) return;
          comp[idx] = cnt;
          for (auto e : _rg[idx]) _rdfs(e.to, cnt);
      }  //}}}
  };
  // how to use
  // StronglyConnectedComponents scc(g); // g: Graph
  // dump(scc.comp, scc.dag.adj_list);
  // snippet:scc }}}


snippet bellman_ford
  // snippet:segment_tree {{{
  template <typename X> struct SegmentTree {  // {{{
      private:
          using F = function<X(X, X)>;
          using index = int;
          int n;  // 元の配列のサイズ
          int N;  // n以上の最小の2冪
          vector<X> node;
          F merge;
          X identity;
  
      public:
          SegmentTree() {}
          SegmentTree(vector<X> a, F f, X id) : merge(f), identity(id) {
              n = a.size();
              N = 1;
              while (N < n) N *= 2;
              node.resize(2 * N - 1, identity);
              for (int i = 0; i < n; i++) node[i + N - 1] = a[i];
              for (int i = N - 2; i >= 0; i--)
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
          }
          SegmentTree(int sz, F f, X id) : SegmentTree(vector<X>(sz, id), f, id) {}
  
          X& operator[](index i) { return node[i + N - 1]; }
  
          void set(index i, X val) {
              i += (N - 1);
              node[i] = val;
              while (i > 0) {
                  i = (i - 1) / 2;
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
              }
          }
  
          void add(index i, X val) {
              i += (N - 1);
              node[i] += val;
              while (i > 0) {
                  i = (i - 1) / 2;
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
              }
          }
  
          // query for [a, b)
          X query(index a, index b, int k = 0, index l = 0, index r = -1) {
              if (r < 0) r = N;
              if (r <= a || b <= l) return identity;
              if (a <= l && r <= b) return node[k];
  
              X vl = query(a, b, 2 * k + 1, l, (l + r) / 2);
              X vr = query(a, b, 2 * k + 2, (l + r) / 2, r);
              return merge(vl, vr);
          }
  
          index find_most_left(index l, const function<bool(X)>& is_ok){
              // lから右に探していってis_okが初めて成り立つようなindexを返す。
              // assume query(l, *) has monotonity
              // return index i s.t is_ok(query(l, i)) does not holds, but is_ok(query(l, i+1)) does.
              // if such i does not exist, return n
              index res = _find_most_left(l, is_ok, 0, 0, N, identity).first;
              assert(l <= res);
              return res;
          }
          pair<index, X> _find_most_left(index a, const function<bool(X)>& is_ok, int k, index l, index r, X left_value){
              // params:
                  // left_value = (a < l ? query(a, l) : ex)
              // return (index i, X v)
                  // i is the index in [a, n)^[l, r) s.t query(a, i+1) is ok but query(a, i) isn't ok. if such i does not exist, i = n
                  // v is the value s.t query(a, r)
  
              if (r <= a) return {n, identity};  // 区間が全く被っていない
              else if (a <= l && !is_ok(merge(left_value, node[k]))) return {n, merge(left_value, node[k])};
              else if (k >= N-1) return {k - (N-1), merge(left_value, node[k])};
              else{
                  auto [vl, xl] = _find_most_left(a, is_ok, 2 * k + 1, l, (l + r) / 2, left_value);
                  if (vl != n) return {vl, xl};
                  auto [vr, xr] = _find_most_left(a, is_ok, 2 * k + 2, (l + r) / 2, r, xl);
                  return {vr, xr};
              }
          }
  
          index find_most_right(index r, const function<bool(X)>& is_ok){
              // rから左に探していってis_okが初めて成り立つようなindexを返す。
              // assume query(*, r) has monotonity
              // return index i s.t is_ok(query(i+1, r+1)) does not holds, but is_ok(query(i, r+1)) does.
              // if such i does not exist, return -1
              index res = _find_most_right(r+1, is_ok, 0, 0, N, identity).first;
              assert(res <= r);
              return res;
          }
          pair<index, X> _find_most_right(index b, const function<bool(X)>& is_ok, int k, index l, index r, X right_value){
              if (b <= l) return {-1, identity};  // 区間が全く被っていない
              else if (r <= b && !is_ok(merge(node[k], right_value))) return {-1, merge(node[k], right_value)};
              else if (k >= N-1) return {k - (N-1), merge(node[k], right_value)};
              else{
                  auto [vr, xr] = _find_most_right(b, is_ok, 2 * k + 2, (l + r) / 2, r, right_value);
                  if (vr != -1) return {vr, xr};
                  auto [vl, xl] = _find_most_right(b, is_ok, 2 * k + 1, l, (l + r) / 2, xr);
                  return {vl, xl};
              }
          }
  
          #if defined(PCM) || defined(LOCAL)
          friend ostream& operator<<(ostream& os, SegmentTree<X>& sg) {  //
              os << "[";
              for (int i = 0; i < sg.n; i++) {
                  os << sg[i] << (i == sg.n - 1 ? "]\n" : ", ");
              }
              return os;
          }
          #endif
  };/*}}}*/
  // sample of initialize SegmentTree:
  // -----------------------------------------------
  // auto mymin=[](auto a, auto b){return min(a,b);};
  // SegmentTree<ll> seg(a, mymin, 1e18);
  
  // auto mymax=[](auto a, auto b){return max(a,b);};
  // SegmentTree<ll> seg(a, mymax, -1e18);
  
  // auto add=[](auto a, auto b){return a+b;};
  // SegmentTree<ll> seg(a, add, 0);
  
  // pair<int, int> get_nearest_index_of_smaller_element(int i){
  //     auto left = seg.find_most_right(i, [&](auto x){return x < a[i];});
  //     auto right = seg.find_most_left(i, [&](auto x){return x < a[i];});
  //     return {left, right};
  // }
  // -----------------------------------------------
  // snippet:segment_tree }}}
  
  // snippet:edge {{{
  template<class Cost=ll>
  struct Edge {
      int from, to;
      Cost cost;
      int idx;
      Edge(){};
      Edge(int from, int to, Cost cost, int idx)
          : from(from), to(to), cost(cost), idx(idx) {}
  
      friend ostream& operator<<(ostream& os, const Edge& e) {
          // os << "(f:" << e.from << ", t:" << e.to << ", c:" << e.cost << ", i" << e.idx << ")";  // detailed
          os << "(" << e.from << "," << e.to << ")";
          return os;
      }
  };
  // snippet:edge }}}
  
  // snippet:UnionFind {{{
  struct UnionFind {
      vector<int> par;   // par[x]: parent of x. if root, -size.
      int gcount;         // count of groups
  
      UnionFind() {}
      UnionFind(int _n) : par(_n, -1), gcount(_n) {}
      bool merge(int x, int y) { 
          x = root(x);
          y = root(y);
          if (x != y) {
              if (par[y] < par[x]) swap(x, y);
              par[x] += par[y];
              par[y] = x;
              gcount--;
          }
          return x != y;
      } 
      int root(int x) {
          if (is_root(x)){
              return x;
          }
          else{
              return par[x] = root(par[x]);  // 経路圧縮
              // return root(par[x]);         // 経路圧縮なし
          }
      }
      bool is_root(int x) { return par[x] < 0; }
      bool same(int x, int y) { return root(x) == root(y); }
      int size(int x) { return -par[root(x)]; }
  
  #if defined(PCM) || defined(LOCAL)  // {{{
      friend ostream& operator<<(ostream& os, UnionFind& uf) {
          map<int, vector<int>> group;
          rep(i, sz(uf.par)) { group[uf.root(i)].pb(i); }
          os << endl;
          each(g, group) { os << g << endl; }
          return os;
      }
  #endif  // }}}
  };
  // snippet:UnionFind }}}
  
  // snippet:tree {{{
  template<class Cost=ll>
  struct tree { 
      int n;
      int root;
      vector<int> par;   // par[i]: dfs木における親
      vector<Cost> cost;  // par[i]: dfs木における親への辺のコスト
      vector<int> dfstrv;  // dfstrv[i]: dfs木でi番目に訪れるノード。dpはこれを逆順に回す
      vector<int> ord;    // ord[u]: uのdfs木における訪問順
      vector<int> end;    // end[u]: uのdfs終了時のカウンター
      vector<int> psize;  // psize[u]: uのpartial tree size
      // uの部分木は[ord[u], end[u])
      // ordとdfstrvは逆変換
      vector<int> depth;   // depth[i]: dfs木でのiの深さ
      vector<Cost> ldepth;  //  ldepth[i]: dfs木でのrootからの距離
      vector<vector<Edge<Cost>>> adj_list;       // 辺(隣接リスト)
      auto operator[](int pos) const { return adj_list[pos]; }
      vector<vector<int>> children;
      vector<int> euler_tour;
      vector<int> et_fpos;    // euler_tour first occurence position
      SegmentTree<int> _seg;  // seg(map(ord, euler_tour), mymin, 1e18)
      vector<int> head_of_comp;
      int _counter = 0;
  
      tree(){};/*{{{*/
      tree(int n)
          : n(n),
            par(n),
            cost(n),
            ord(n),
            end(n),
            psize(n),
            depth(n),
            ldepth(n),
            adj_list(n),
            children(n),
            et_fpos(n),
            head_of_comp(n){};/*}}}*/
      void add_edge(int u, int v, Cost cost, int idx=-1) { /*{{{*/
          adj_list[u].emplace_back(u, v, cost, idx);
          adj_list[v].emplace_back(v, u, cost, idx);
      }                             /*}}}*/
      void add_edge(int u, int v) { /*{{{*/
          adj_list[u].emplace_back(u, v, 1, -1);
          adj_list[v].emplace_back(v, u, 1, -1);
      }                      /*}}}*/
      void build(int _root) { /*{{{*/
          root = _root;
          _counter = 0;
          par[root] = -1;
          // cost[root] = -1;
          _dfs_psize(root, -1);
          _dfs_tree(root, -1, root);
          _dfs_et(root);
          vector<int> ini(2 * n - 1);
          rep(i, 2 * n - 1) ini[i] = ord[euler_tour[i]];
          _seg = SegmentTree<int>(
              ini, [](auto a, auto b) { return min(a, b); }, numeric_limits<int>().max());
      }                                /*}}}*/
      int _dfs_psize(int u, int pre) { /*{{{*/
          psize[u] = 1;
          each(edge, adj_list[u]) {
              if (edge.to == pre) continue;
              psize[u] += _dfs_psize(edge.to, u);
          }
          return psize[u];
      }                                               /*}}}*/
      void _dfs_tree(int u, int pre, int head_node) { /*{{{*/
          dfstrv.pb(u);
          ord[u] = _counter;
          if (pre != -1) {
              depth[u] = depth[pre] + 1;
              ldepth[u] = ldepth[pre] + cost[u];
          }
  
          _counter++;
          {
              // set most heavy child to top
              int max_psize = 0;
              int most_heavy_i = -1;
              rep(i, sz(adj_list[u])) {
                  if (adj_list[u][i].to == pre) continue;
                  if (psize[adj_list[u][i].to] > max_psize) {
                      most_heavy_i = i;
                      max_psize = psize[adj_list[u][i].to];
                  }
              }
              if (most_heavy_i != -1) swap(adj_list[u][most_heavy_i], adj_list[u][0]);
          }
  
          head_of_comp[u] = head_node;
          rep(i, sz(adj_list[u])) {
              int v = adj_list[u][i].to;
              if (v == pre) continue;
  
              children[u].pb(v);
              par[v] = u;
              cost[v] = adj_list[u][i].cost;
  
              if (i == 0)
                  _dfs_tree(v, u, head_node);  // continue components
              else
                  _dfs_tree(v, u, v);  // new
          }
          end[u] = _counter;
      }                     /*}}}*/
      void _dfs_et(int u) { /*{{{*/
          et_fpos[u] = euler_tour.size();
          euler_tour.pb(u);
          each(v, children[u]) {
              _dfs_et(v);
              euler_tour.pb(u);
          }
      }                       /*}}}*/
      int lca(int u, int v) { /*{{{*/
          if (u == v) return u;
          if (et_fpos[u] > et_fpos[v]) swap(u, v);
          return dfstrv[_seg.query(et_fpos[u], et_fpos[v])];
      }                        /*}}}*/
      int dist(int u, int v) { /*{{{*/
          int p = lca(u, v);
          return depth[u] + depth[v] - 2 * depth[p];
      }                          /*}}}*/
      Cost ldist(int u, int v) {  // length dist{{{
          int p = lca(u, v);
          return ldepth[u] + ldepth[v] - 2 * ldepth[p];
      }                           /*}}}*/
      pair<int, int> diameter() { /*{{{*/
          int u, v;
          Cost max_len = *max_element(all(ldepth));
          rep(i, n) {
              if (ldepth[i] == max_len) {
                  u = i;
                  break;
              }
          }
          Cost md = -1;
          rep(i, n) {
              Cost d = ldist(u, i);
              if (d > md) {
                  v = i;
                  md = d;
              }
          }
          return mp(u, v);
      }                                                /*}}}*/
      vector<pair<int, int>> hld_path(int u, int v, bool for_edge=true) {  //{{{
          // 閉区間をvectorで返す。for_edge=trueでlcaは除いて返すことに注意。
          vector<pair<int, int>> res;
          while (head_of_comp[u] != head_of_comp[v]) {
              if (depth[head_of_comp[u]] < depth[head_of_comp[v]]) {
                  res.push_back({ord[head_of_comp[v]], ord[v]});
                  v = par[head_of_comp[v]];
              } else {
                  res.push_back({ord[head_of_comp[u]], ord[u]});
                  u = par[head_of_comp[u]];
              }
          }
          res.push_back({min(ord[u], ord[v]) + (for_edge?1:0), max(ord[u], ord[v])});
          return res;
      }                              //}}}
  #if defined(PCM) || defined(LOCAL) /*{{{*/
      friend ostream& operator<<(ostream& os, const tree& tr) {
          os << endl;
          os << "par:         " << tr.par << endl;
          os << "cost:        " << tr.cost << endl;
          os << "dfstrv:      " << tr.dfstrv << endl;
          os << "ord:         " << tr.ord << endl;
          os << "end:         " << tr.end << endl;
          os << "depth:       " << tr.depth << endl;
          os << "children:    " << tr.children << endl;
          os << "euler_tour:  " << tr.euler_tour << endl;
          os << "et_fpos:     " << tr.et_fpos << endl;
          os << "head_of_comp:" << tr.head_of_comp << endl;
          return os;
      }
  #endif /*}}}*/
  }; 
  // snippet:tree }}}
  
  // snippet:Graph {{{
  template<class Cost=ll>
  struct Graph {
      using Pos = int;  // int以外には対応しない。
  
      int n;  // 頂点数
      vector<vector<Edge<Cost>>> adj_list;
      auto operator[](Pos pos) const { return adj_list[pos]; }
      vector<Edge<Cost>> edges;
      tree<Cost> tr;
      Pos root;
      vector<int> _used_in_dfs;
      vector<int> lowlink;
      Cost zerocost;
      Cost infcost;
  
      Graph() {}
      Graph(int _n) : n(_n), adj_list(_n), tr(n), _used_in_dfs(n), zerocost(0LL), infcost(INF) { }
      Graph(int _n, Cost zc, Cost ic) : n(_n), adj_list(_n), tr(n), _used_in_dfs(n), zerocost(zc), infcost(ic) { }
  
      void add_edge(Pos from, Pos to, Cost cost, int idx=-1) {/*{{{*/
          adj_list[from].emplace_back(from, to, cost, idx);
          edges.emplace_back(from, to, cost, idx);
      }
      void add_edge(Pos from, Pos to) {  // for ll
          adj_list[from].emplace_back(from, to, 1, -1);
          edges.emplace_back(from, to, 1, -1);
      }/*}}}*/
  
      void build_tree(Pos _root) {/*{{{*/
          root = _root;
          _dfs_tree(root);
          tr.build(root);
          _make_lowlink();
      }/*}}}*/
  
      vector<int> make_bipartite() {/*{{{*/
          UnionFind buf(2 * n);
          rep(u, n) {
              each(e, adj_list[u]) {
                  buf.merge(u, e.to + n);
                  buf.merge(e.to, u + n);
              }
          }
  
          vector<int> res(n, -1);
          rep(u, n) {
              if (buf.same(u, u + n)) return res;
          }
          rep(u, n) {
              if (buf.same(0, u)) res[u] = 0;
              else res[u] = 1;
          }
          return res;
      }/*}}}*/
  
      void _dfs_tree(Pos u) {/*{{{*/
          _used_in_dfs[u] = 1;
          each(e, adj_list[u]) {
              if (_used_in_dfs[e.to]) continue;
              tr.add_edge(u, e.to, e.cost);
              _dfs_tree(e.to);
          }
      }/*}}}*/
  
      void _make_lowlink() {/*{{{*/
          lowlink = vector<Pos>(n, numeric_limits<Pos>().max());
          r_rep(i, n) {
              Pos u = tr.dfstrv[i];
              chmin(lowlink[u], tr.ord[u]);
  
              each(e, adj_list[u]) {
                  if (e.to == tr.par[u])
                      continue;
                  else if (tr.ord[e.to] < tr.ord[u]) {
                      chmin(lowlink[u], tr.ord[e.to]);
                  } else {
                      chmin(lowlink[u], lowlink[e.to]);
                  }
              }
          }
      }/*}}}*/
  
      vector<Pos> get_articulation_points() {/*{{{*/
          if (sz(lowlink) == 0) throw("make_lowlik() beforehand");
  
          vector<Pos> res;
          if (sz(tr.children[root]) > 1) {
              res.push_back(root);
          }
          rep(u, 0, n) {
              if (u == root) continue;
              bool is_kan = false;
              each(v, tr.children[u]) {
                  if (tr.ord[u] <= lowlink[v]) {
                      is_kan = true;
                  }
              }
              if (is_kan) res.push_back(u);
          }
          return res;
      }/*}}}*/
  
      vector<Edge<Cost>> get_bridges() {/*{{{*/
          if (sz(lowlink) == 0) throw("make_lowlik() beforehand");
          vector<Edge<Cost>> res;
          each(edge, edges){
              if (tr.ord[edge.from] < lowlink[edge.to]) res.push_back(edge);
          }
          return res;
      }/*}}}*/
  
      vector<Edge<Cost>> kruskal_tree() {/*{{{*/
          // 使用される辺のvectorを返す
          vector<Edge<Cost>> res(n - 1);
          sort(all(edges), [&](auto l, auto r) { return l.cost < r.cost; });
          UnionFind uf(n);
  
          Cost total_cost = zerocost;
          int idx = 0;
          each(e, edges) {
              if (uf.same(e.from, e.to)) continue;
              uf.merge(e.from, e.to);
              total_cost = total_cost + e.cost;
              res[idx] = e;
              idx++;
          }
          assert(idx == n - 1);
  
          return res;
      }/*}}}*/
  
      vector<Cost> dijkstra(vector<Pos> starts) {  // 多点スタート{{{
          vector<Cost> dist(n, infcost);           // 最短距離
          PQ<pair<Cost, Pos>> pq;
          each(start, starts) {
              dist[start] = zerocost;
              pq.push(make_pair(zerocost, start));
          }
          while (!pq.empty()) {
              auto cp = pq.top();
              pq.pop();
              auto [cost, u] = cp;
              for (const auto& edge : adj_list[u]) {
                  Cost new_cost = cost + edge.cost;  // TODO: 問題によってはここが変更の必要あり
                  if (new_cost < dist[edge.to]) {
                      dist[edge.to] = new_cost;
                      pq.push(make_pair(new_cost, edge.to));
                  }
              }
          }
          return dist;
      };/*}}}*/
  
      vector<Cost> dijkstra(Pos start) {  // 1点スタート{{{
          vector<Pos> starts = {start};
          return dijkstra(starts);
      };/*}}}*/
  };
  // snippet:Graph }}}
  
  // snippet:bellman_ford {{{
  auto bellman_ford(const Graph<>& g, int start) { // 負閉路検出
      vector<decltype(g.infcost)> dist(g.n, g.infcost);  // 最短距離
      dist[start] = g.zerocost;
      for (int i = 0; i < g.n; i++) {
          each(edge, g.edges){
              if (dist[edge.from] != INF && dist[edge.to] > dist[edge.from] + edge.cost) {
                  dist[edge.to] = dist[edge.from] + edge.cost;
                  if (i == g.n - 1)
                      return make_pair(true, dist);  // n回目にも更新があるなら負の閉路が存在
              }
          }
      }
      return make_pair(false, dist);
  }
  // snippet:bellman_ford }}}


snippet tree
  // snippet:segment_tree {{{
  template <typename X> struct SegmentTree {  // {{{
      private:
          using F = function<X(X, X)>;
          using index = int;
          int n;  // 元の配列のサイズ
          int N;  // n以上の最小の2冪
          vector<X> node;
          F merge;
          X identity;
  
      public:
          SegmentTree() {}
          SegmentTree(vector<X> a, F f, X id) : merge(f), identity(id) {
              n = a.size();
              N = 1;
              while (N < n) N *= 2;
              node.resize(2 * N - 1, identity);
              for (int i = 0; i < n; i++) node[i + N - 1] = a[i];
              for (int i = N - 2; i >= 0; i--)
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
          }
          SegmentTree(int sz, F f, X id) : SegmentTree(vector<X>(sz, id), f, id) {}
  
          X& operator[](index i) { return node[i + N - 1]; }
  
          void set(index i, X val) {
              i += (N - 1);
              node[i] = val;
              while (i > 0) {
                  i = (i - 1) / 2;
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
              }
          }
  
          void add(index i, X val) {
              i += (N - 1);
              node[i] += val;
              while (i > 0) {
                  i = (i - 1) / 2;
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
              }
          }
  
          // query for [a, b)
          X query(index a, index b, int k = 0, index l = 0, index r = -1) {
              if (r < 0) r = N;
              if (r <= a || b <= l) return identity;
              if (a <= l && r <= b) return node[k];
  
              X vl = query(a, b, 2 * k + 1, l, (l + r) / 2);
              X vr = query(a, b, 2 * k + 2, (l + r) / 2, r);
              return merge(vl, vr);
          }
  
          index find_most_left(index l, const function<bool(X)>& is_ok){
              // lから右に探していってis_okが初めて成り立つようなindexを返す。
              // assume query(l, *) has monotonity
              // return index i s.t is_ok(query(l, i)) does not holds, but is_ok(query(l, i+1)) does.
              // if such i does not exist, return n
              index res = _find_most_left(l, is_ok, 0, 0, N, identity).first;
              assert(l <= res);
              return res;
          }
          pair<index, X> _find_most_left(index a, const function<bool(X)>& is_ok, int k, index l, index r, X left_value){
              // params:
                  // left_value = (a < l ? query(a, l) : ex)
              // return (index i, X v)
                  // i is the index in [a, n)^[l, r) s.t query(a, i+1) is ok but query(a, i) isn't ok. if such i does not exist, i = n
                  // v is the value s.t query(a, r)
  
              if (r <= a) return {n, identity};  // 区間が全く被っていない
              else if (a <= l && !is_ok(merge(left_value, node[k]))) return {n, merge(left_value, node[k])};
              else if (k >= N-1) return {k - (N-1), merge(left_value, node[k])};
              else{
                  auto [vl, xl] = _find_most_left(a, is_ok, 2 * k + 1, l, (l + r) / 2, left_value);
                  if (vl != n) return {vl, xl};
                  auto [vr, xr] = _find_most_left(a, is_ok, 2 * k + 2, (l + r) / 2, r, xl);
                  return {vr, xr};
              }
          }
  
          index find_most_right(index r, const function<bool(X)>& is_ok){
              // rから左に探していってis_okが初めて成り立つようなindexを返す。
              // assume query(*, r) has monotonity
              // return index i s.t is_ok(query(i+1, r+1)) does not holds, but is_ok(query(i, r+1)) does.
              // if such i does not exist, return -1
              index res = _find_most_right(r+1, is_ok, 0, 0, N, identity).first;
              assert(res <= r);
              return res;
          }
          pair<index, X> _find_most_right(index b, const function<bool(X)>& is_ok, int k, index l, index r, X right_value){
              if (b <= l) return {-1, identity};  // 区間が全く被っていない
              else if (r <= b && !is_ok(merge(node[k], right_value))) return {-1, merge(node[k], right_value)};
              else if (k >= N-1) return {k - (N-1), merge(node[k], right_value)};
              else{
                  auto [vr, xr] = _find_most_right(b, is_ok, 2 * k + 2, (l + r) / 2, r, right_value);
                  if (vr != -1) return {vr, xr};
                  auto [vl, xl] = _find_most_right(b, is_ok, 2 * k + 1, l, (l + r) / 2, xr);
                  return {vl, xl};
              }
          }
  
          #if defined(PCM) || defined(LOCAL)
          friend ostream& operator<<(ostream& os, SegmentTree<X>& sg) {  //
              os << "[";
              for (int i = 0; i < sg.n; i++) {
                  os << sg[i] << (i == sg.n - 1 ? "]\n" : ", ");
              }
              return os;
          }
          #endif
  };/*}}}*/
  // sample of initialize SegmentTree:
  // -----------------------------------------------
  // auto mymin=[](auto a, auto b){return min(a,b);};
  // SegmentTree<ll> seg(a, mymin, 1e18);
  
  // auto mymax=[](auto a, auto b){return max(a,b);};
  // SegmentTree<ll> seg(a, mymax, -1e18);
  
  // auto add=[](auto a, auto b){return a+b;};
  // SegmentTree<ll> seg(a, add, 0);
  
  // pair<int, int> get_nearest_index_of_smaller_element(int i){
  //     auto left = seg.find_most_right(i, [&](auto x){return x < a[i];});
  //     auto right = seg.find_most_left(i, [&](auto x){return x < a[i];});
  //     return {left, right};
  // }
  // -----------------------------------------------
  // snippet:segment_tree }}}
  
  // snippet:edge {{{
  template<class Cost=ll>
  struct Edge {
      int from, to;
      Cost cost;
      int idx;
      Edge(){};
      Edge(int from, int to, Cost cost, int idx)
          : from(from), to(to), cost(cost), idx(idx) {}
  
      friend ostream& operator<<(ostream& os, const Edge& e) {
          // os << "(f:" << e.from << ", t:" << e.to << ", c:" << e.cost << ", i" << e.idx << ")";  // detailed
          os << "(" << e.from << "," << e.to << ")";
          return os;
      }
  };
  // snippet:edge }}}
  
  // snippet:tree {{{
  template<class Cost=ll>
  struct tree { 
      int n;
      int root;
      vector<int> par;   // par[i]: dfs木における親
      vector<Cost> cost;  // par[i]: dfs木における親への辺のコスト
      vector<int> dfstrv;  // dfstrv[i]: dfs木でi番目に訪れるノード。dpはこれを逆順に回す
      vector<int> ord;    // ord[u]: uのdfs木における訪問順
      vector<int> end;    // end[u]: uのdfs終了時のカウンター
      vector<int> psize;  // psize[u]: uのpartial tree size
      // uの部分木は[ord[u], end[u])
      // ordとdfstrvは逆変換
      vector<int> depth;   // depth[i]: dfs木でのiの深さ
      vector<Cost> ldepth;  //  ldepth[i]: dfs木でのrootからの距離
      vector<vector<Edge<Cost>>> adj_list;       // 辺(隣接リスト)
      auto operator[](int pos) const { return adj_list[pos]; }
      vector<vector<int>> children;
      vector<int> euler_tour;
      vector<int> et_fpos;    // euler_tour first occurence position
      SegmentTree<int> _seg;  // seg(map(ord, euler_tour), mymin, 1e18)
      vector<int> head_of_comp;
      int _counter = 0;
  
      tree(){};/*{{{*/
      tree(int n)
          : n(n),
            par(n),
            cost(n),
            ord(n),
            end(n),
            psize(n),
            depth(n),
            ldepth(n),
            adj_list(n),
            children(n),
            et_fpos(n),
            head_of_comp(n){};/*}}}*/
      void add_edge(int u, int v, Cost cost, int idx=-1) { /*{{{*/
          adj_list[u].emplace_back(u, v, cost, idx);
          adj_list[v].emplace_back(v, u, cost, idx);
      }                             /*}}}*/
      void add_edge(int u, int v) { /*{{{*/
          adj_list[u].emplace_back(u, v, 1, -1);
          adj_list[v].emplace_back(v, u, 1, -1);
      }                      /*}}}*/
      void build(int _root) { /*{{{*/
          root = _root;
          _counter = 0;
          par[root] = -1;
          // cost[root] = -1;
          _dfs_psize(root, -1);
          _dfs_tree(root, -1, root);
          _dfs_et(root);
          vector<int> ini(2 * n - 1);
          rep(i, 2 * n - 1) ini[i] = ord[euler_tour[i]];
          _seg = SegmentTree<int>(
              ini, [](auto a, auto b) { return min(a, b); }, numeric_limits<int>().max());
      }                                /*}}}*/
      int _dfs_psize(int u, int pre) { /*{{{*/
          psize[u] = 1;
          each(edge, adj_list[u]) {
              if (edge.to == pre) continue;
              psize[u] += _dfs_psize(edge.to, u);
          }
          return psize[u];
      }                                               /*}}}*/
      void _dfs_tree(int u, int pre, int head_node) { /*{{{*/
          dfstrv.pb(u);
          ord[u] = _counter;
          if (pre != -1) {
              depth[u] = depth[pre] + 1;
              ldepth[u] = ldepth[pre] + cost[u];
          }
  
          _counter++;
          {
              // set most heavy child to top
              int max_psize = 0;
              int most_heavy_i = -1;
              rep(i, sz(adj_list[u])) {
                  if (adj_list[u][i].to == pre) continue;
                  if (psize[adj_list[u][i].to] > max_psize) {
                      most_heavy_i = i;
                      max_psize = psize[adj_list[u][i].to];
                  }
              }
              if (most_heavy_i != -1) swap(adj_list[u][most_heavy_i], adj_list[u][0]);
          }
  
          head_of_comp[u] = head_node;
          rep(i, sz(adj_list[u])) {
              int v = adj_list[u][i].to;
              if (v == pre) continue;
  
              children[u].pb(v);
              par[v] = u;
              cost[v] = adj_list[u][i].cost;
  
              if (i == 0)
                  _dfs_tree(v, u, head_node);  // continue components
              else
                  _dfs_tree(v, u, v);  // new
          }
          end[u] = _counter;
      }                     /*}}}*/
      void _dfs_et(int u) { /*{{{*/
          et_fpos[u] = euler_tour.size();
          euler_tour.pb(u);
          each(v, children[u]) {
              _dfs_et(v);
              euler_tour.pb(u);
          }
      }                       /*}}}*/
      int lca(int u, int v) { /*{{{*/
          if (u == v) return u;
          if (et_fpos[u] > et_fpos[v]) swap(u, v);
          return dfstrv[_seg.query(et_fpos[u], et_fpos[v])];
      }                        /*}}}*/
      int dist(int u, int v) { /*{{{*/
          int p = lca(u, v);
          return depth[u] + depth[v] - 2 * depth[p];
      }                          /*}}}*/
      Cost ldist(int u, int v) {  // length dist{{{
          int p = lca(u, v);
          return ldepth[u] + ldepth[v] - 2 * ldepth[p];
      }                           /*}}}*/
      pair<int, int> diameter() { /*{{{*/
          int u, v;
          Cost max_len = *max_element(all(ldepth));
          rep(i, n) {
              if (ldepth[i] == max_len) {
                  u = i;
                  break;
              }
          }
          Cost md = -1;
          rep(i, n) {
              Cost d = ldist(u, i);
              if (d > md) {
                  v = i;
                  md = d;
              }
          }
          return mp(u, v);
      }                                                /*}}}*/
      vector<pair<int, int>> hld_path(int u, int v, bool for_edge=true) {  //{{{
          // 閉区間をvectorで返す。for_edge=trueでlcaは除いて返すことに注意。
          vector<pair<int, int>> res;
          while (head_of_comp[u] != head_of_comp[v]) {
              if (depth[head_of_comp[u]] < depth[head_of_comp[v]]) {
                  res.push_back({ord[head_of_comp[v]], ord[v]});
                  v = par[head_of_comp[v]];
              } else {
                  res.push_back({ord[head_of_comp[u]], ord[u]});
                  u = par[head_of_comp[u]];
              }
          }
          res.push_back({min(ord[u], ord[v]) + (for_edge?1:0), max(ord[u], ord[v])});
          return res;
      }                              //}}}
  #if defined(PCM) || defined(LOCAL) /*{{{*/
      friend ostream& operator<<(ostream& os, const tree& tr) {
          os << endl;
          os << "par:         " << tr.par << endl;
          os << "cost:        " << tr.cost << endl;
          os << "dfstrv:      " << tr.dfstrv << endl;
          os << "ord:         " << tr.ord << endl;
          os << "end:         " << tr.end << endl;
          os << "depth:       " << tr.depth << endl;
          os << "children:    " << tr.children << endl;
          os << "euler_tour:  " << tr.euler_tour << endl;
          os << "et_fpos:     " << tr.et_fpos << endl;
          os << "head_of_comp:" << tr.head_of_comp << endl;
          return os;
      }
  #endif /*}}}*/
  }; 
  // snippet:tree }}}


snippet dinic
alias flow
  // snippet:dinic {{{
  // Dinic: https://tubo28.me/compprog/algorithm/dinic/
  using Capacity = int;
  struct Edge {
      int src, dst;
      Capacity cap;
      Edge(int src_, int dst_, Capacity cap_) : src(src_), dst(dst_), cap(cap_) {}
  };
  
  using Edges = vector<Edge>;
  using Graph = vector<Edges>;
  template <typename Flow>
  struct dinic {
      int n, s, t;
      vector<int> level, prog, que;
      vector<vector<Flow>> cap, flow;
      vector<vector<int>> g;
      Flow inf;
      dinic(const Graph &graph)/*{{{*/
          : n(graph.size()),
            cap(n, vector<Flow>(n)),
            flow(n, vector<Flow>(n)),
            g(n, vector<int>()),
            inf(numeric_limits<Flow>::max() / 8) {
          for (int i = 0; i < n; i++) {
              for (auto &e : graph[i]) {
                  int u = e.src, v = e.dst;
                  Flow c = e.cap;
                  cap[u][v] += c;
                  cap[v][u] += c;
                  flow[v][u] += c;
                  g[u].push_back(v);
                  g[v].push_back(u);
              }
          }
      }/*}}}*/
      Flow solve(int s_, int t_) {/*{{{*/
          this->t = t_, this->s = s_;
          que.resize(n + 1);
          Flow res = 0;
          while (levelize()) {
              prog.assign(n, 0);
              res += augment(s, inf);
          }
          return res;
      }/*}}}*/
  
  private:
      inline Flow residue(int u, int v) { return cap[u][v] - flow[u][v]; }
      bool levelize() {/*{{{*/
          int l = 0, r = 0;
          level.assign(n, -1);
          level[s] = 0;
          que[r++] = s;
          while (l != r) {
              int v = que[l++];
              if (v == t) break;
              for (const int &d : g[v])
                  if (level[d] == -1 && residue(v, d) != 0) {
                      level[d] = level[v] + 1;
                      que[r++] = d;
                  }
          }
          return level[t] != -1;
      }/*}}}*/
      Flow augment(int v, Flow lim) {/*{{{*/
          Flow res = 0;
          if (v == t) return lim;
          for (int &i = prog[v]; i < (int)g[v].size(); i++) {
              const int &d = g[v][i];
              if (residue(v, d) == 0 || level[v] >= level[d]) continue;
              const Flow aug = augment(d, std::min(lim, residue(v, d)));
              flow[v][d] += aug;
              flow[d][v] -= aug;
              res += aug;
              lim -= aug;
              if (lim == 0) break;
          }
          return res;
      }/*}}}*/
  };
  // Graph g(n);
  // ll a,b;cin>>a>>b;
  // g[a].emplace_back(a, b, 1);
  // g[b].emplace_back(b, a, 1);
  // snippet:dinic }}}


snippet split
  // snippet:split {{{
  vector<string> split(const string& s){
      ll n = sz(s);
      vector<string> res = {""};
      rep(i, n){
          if (s[i]==' '){ res.push_back(""); }
          else{ res.back() += s[i]; }
      }
      return res;
  }
  // snippet:split }}}


snippet rolling_hash
  // snippet:rolling_hash {{{
  template<class Z> Z rng(Z a, Z b) {
      auto tmp = mt19937(chrono::steady_clock::now().time_since_epoch().count());
      return uniform_int_distribution<Z>(a, b - 1)(tmp);
  }
  
  struct rolling_hash {
      // static constexpr uint64_t P0 = 4111144441, P1 = 4111444111;
      static constexpr uint64_t P0 = 1e9+7, P1 = 998244353;
      static uint64_t B0, B1;
      vector<ll> hash0, hash1, _bpow0, _bpow1;  // 1-index
      rolling_hash() {}
  
      template<class T = vector<int>>
      rolling_hash(T &vs) {
          init(vs, hash0, B0, P0, _bpow0); 
          init(vs, hash1, B1, P1, _bpow1); 
      }
      rolling_hash(string &s) {
          vector<int> vs;
          for (char c : s) vs.emplace_back(c);
          init(vs, hash0, B0, P0, _bpow0); 
          init(vs, hash1, B1, P1, _bpow1); 
      }
  
      template<class T>
      void init(T& vs, vector<ll>& hash, ll B, ll P, vector<ll>& _bpow) {
          int n = vs.size();
          hash.assign(n + 1, 0);
          _bpow.assign(n + 1, 1);
          for (int i = 0; i < n; i++) {
              hash[i + 1] = (hash[i] * B + vs[i]) % P;
              _bpow[i + 1] = _bpow[i] * B % P;
          }
      }
  
      pair<ll, ll> get_hash(int l, int r) { // [l, r)
          ll h0 = _get_hash(l, r, hash0, B0, P0, _bpow0);
          ll h1 = _get_hash(l, r, hash1, B1, P1, _bpow1);
          return {h0, h1};
      }
      ll _get_hash(int l, int r,  const vector<ll>& hash, ll B, ll P, const vector<ll>& _bpow) {
          ll res = (hash[r] - hash[l]*_bpow[r - l]) % P;
          res = (res < 0 ? res + P : res);
          assert(res>=0);
          return res;
      }
  };
  uint64_t rolling_hash::B0 = rng<ll>(1000000, rolling_hash::P0);
  uint64_t rolling_hash::B1 = rng<ll>(1000000, rolling_hash::P1);
  // snippet:rolling_hash }}}


snippet suffix_array
alias sa
  // snippet:sparse_table {{{
  template< class T = ll >
  struct sparse_table {
      vector< vector< T > > st;
      vector< int > lookup;
  
      sparse_table(const vector< T > &v) {
          int b = 0;
          while((1 << b) <= sz(v)) ++b;
          st.assign(b, vector< T >(1 << b));
          for(int i = 0; i < sz(v); i++) {
              st[0][i] = v[i];
          }
          for(int i = 1; i < b; i++) {
              for(int j = 0; j + (1 << i) <= (1 << b); j++) {
                  st[i][j] = min(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]);
              }
          }
          lookup.resize(v.size() + 1);
          for(int i = 2; i < sz(lookup); i++) {
              lookup[i] = lookup[i >> 1] + 1;
          }
      }
  
      inline T query(int l, int r) {  // [l, r)
          int b = lookup[r - l];
          return min(st[b][l], st[b][r - (1 << b)]);
      }
  };
  // snippet:sparse_table }}}
  
  // snippet:segment_tree {{{
  template <typename X> struct SegmentTree {  // {{{
      private:
          using F = function<X(X, X)>;
          using index = int;
          int n;  // 元の配列のサイズ
          int N;  // n以上の最小の2冪
          vector<X> node;
          F merge;
          X identity;
  
      public:
          SegmentTree() {}
          SegmentTree(vector<X> a, F f, X id) : merge(f), identity(id) {
              n = a.size();
              N = 1;
              while (N < n) N *= 2;
              node.resize(2 * N - 1, identity);
              for (int i = 0; i < n; i++) node[i + N - 1] = a[i];
              for (int i = N - 2; i >= 0; i--)
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
          }
          SegmentTree(int sz, F f, X id) : SegmentTree(vector<X>(sz, id), f, id) {}
  
          X& operator[](index i) { return node[i + N - 1]; }
  
          void set(index i, X val) {
              i += (N - 1);
              node[i] = val;
              while (i > 0) {
                  i = (i - 1) / 2;
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
              }
          }
  
          void add(index i, X val) {
              i += (N - 1);
              node[i] += val;
              while (i > 0) {
                  i = (i - 1) / 2;
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
              }
          }
  
          // query for [a, b)
          X query(index a, index b, int k = 0, index l = 0, index r = -1) {
              if (r < 0) r = N;
              if (r <= a || b <= l) return identity;
              if (a <= l && r <= b) return node[k];
  
              X vl = query(a, b, 2 * k + 1, l, (l + r) / 2);
              X vr = query(a, b, 2 * k + 2, (l + r) / 2, r);
              return merge(vl, vr);
          }
  
          index find_most_left(index l, const function<bool(X)>& is_ok){
              // lから右に探していってis_okが初めて成り立つようなindexを返す。
              // assume query(l, *) has monotonity
              // return index i s.t is_ok(query(l, i)) does not holds, but is_ok(query(l, i+1)) does.
              // if such i does not exist, return n
              index res = _find_most_left(l, is_ok, 0, 0, N, identity).first;
              assert(l <= res);
              return res;
          }
          pair<index, X> _find_most_left(index a, const function<bool(X)>& is_ok, int k, index l, index r, X left_value){
              // params:
                  // left_value = (a < l ? query(a, l) : ex)
              // return (index i, X v)
                  // i is the index in [a, n)^[l, r) s.t query(a, i+1) is ok but query(a, i) isn't ok. if such i does not exist, i = n
                  // v is the value s.t query(a, r)
  
              if (r <= a) return {n, identity};  // 区間が全く被っていない
              else if (a <= l && !is_ok(merge(left_value, node[k]))) return {n, merge(left_value, node[k])};
              else if (k >= N-1) return {k - (N-1), merge(left_value, node[k])};
              else{
                  auto [vl, xl] = _find_most_left(a, is_ok, 2 * k + 1, l, (l + r) / 2, left_value);
                  if (vl != n) return {vl, xl};
                  auto [vr, xr] = _find_most_left(a, is_ok, 2 * k + 2, (l + r) / 2, r, xl);
                  return {vr, xr};
              }
          }
  
          index find_most_right(index r, const function<bool(X)>& is_ok){
              // rから左に探していってis_okが初めて成り立つようなindexを返す。
              // assume query(*, r) has monotonity
              // return index i s.t is_ok(query(i+1, r+1)) does not holds, but is_ok(query(i, r+1)) does.
              // if such i does not exist, return -1
              index res = _find_most_right(r+1, is_ok, 0, 0, N, identity).first;
              assert(res <= r);
              return res;
          }
          pair<index, X> _find_most_right(index b, const function<bool(X)>& is_ok, int k, index l, index r, X right_value){
              if (b <= l) return {-1, identity};  // 区間が全く被っていない
              else if (r <= b && !is_ok(merge(node[k], right_value))) return {-1, merge(node[k], right_value)};
              else if (k >= N-1) return {k - (N-1), merge(node[k], right_value)};
              else{
                  auto [vr, xr] = _find_most_right(b, is_ok, 2 * k + 2, (l + r) / 2, r, right_value);
                  if (vr != -1) return {vr, xr};
                  auto [vl, xl] = _find_most_right(b, is_ok, 2 * k + 1, l, (l + r) / 2, xr);
                  return {vl, xl};
              }
          }
  
          #if defined(PCM) || defined(LOCAL)
          friend ostream& operator<<(ostream& os, SegmentTree<X>& sg) {  //
              os << "[";
              for (int i = 0; i < sg.n; i++) {
                  os << sg[i] << (i == sg.n - 1 ? "]\n" : ", ");
              }
              return os;
          }
          #endif
  };/*}}}*/
  // sample of initialize SegmentTree:
  // -----------------------------------------------
  // auto mymin=[](auto a, auto b){return min(a,b);};
  // SegmentTree<ll> seg(a, mymin, 1e18);
  
  // auto mymax=[](auto a, auto b){return max(a,b);};
  // SegmentTree<ll> seg(a, mymax, -1e18);
  
  // auto add=[](auto a, auto b){return a+b;};
  // SegmentTree<ll> seg(a, add, 0);
  
  // pair<int, int> get_nearest_index_of_smaller_element(int i){
  //     auto left = seg.find_most_right(i, [&](auto x){return x < a[i];});
  //     auto right = seg.find_most_left(i, [&](auto x){return x < a[i];});
  //     return {left, right};
  // }
  // -----------------------------------------------
  // snippet:segment_tree }}}
  
  // snippet:suffix_array {{{
  struct suffix_array { 
      vector<int> a;
      vector<int> pos;   // pos[j]: j位のsumffixはどこから始まるか
      vector<int> rank;  // rank[i]: s[i:]は何位か
      // pos = rank^-1
      vector<int> lcp_array;           // lcp_arry[j]: s[pos[j]:]とs[pos[j]+1:]のlcp
      SegmentTree<int> _seg_lcp_array;
      int n;
      string s;
  
      // constructor{{{
      suffix_array() {}
      suffix_array(vector<int>& a) : a(a), n(a.size()) { _build(); }
      suffix_array(string& s_): s(s_) {
          n = s.size();
          a.resize(n);
          rep(i, n) a[i] = s[i];
          _build();
      } /*}}}*/
  
      void _build() { /*{{{*/
          _build_order();
          _build_lcp_array();
      } /*}}}*/
  
      void _build_order() { /*{{{*/
          pos.resize(n);
          iota(all(pos), 0);
          rank = a;  // aでそのままスコア化
  
          for (int k = 1; k < n; k *= 2) {
              // kでのrankが生成されている前提で2*kでのrankを生成する
  
              auto _comp = [&](int l, int r) {
                  auto left = mp(rank[l], (l + k < n ? rank[l + k] : -1));
                  auto right = mp(rank[r], (r + k < n ? rank[r + k] : -1));
                  return left < right;
              };
              sort(all(pos), _comp);
  
              vector<int> next_rank(n);
              next_rank[pos[0]] = 0;
              int r = 0;
              rep(i, 1, n) {
                  if (_comp(pos[i - 1], pos[i])) r++;
                  next_rank[pos[i]] = r;
              }
              rank = next_rank;
          }
      } /*}}}*/
  
      void _build_lcp_array() { /*{{{*/
          lcp_array.resize(n);
          int con = 1;
          rep(l, 0, n) {
              if (rank[l] + 1 == n) {
                  lcp_array[rank[l]] = -1;
                  con = 1;
                  continue;
              }
  
              if (con > 0) con--;
              int r = pos[rank[l] + 1];
              while (l + con < n && r + con < n && a[l + con] == a[r + con]) {
                  con++;
              }
              lcp_array[rank[l]] = con;
          }
  
          auto mymin = [](auto a, auto b) { return min(a, b); };
          _seg_lcp_array = SegmentTree<int>(lcp_array, mymin, 1e9);
          // sparse_lcp_array = SparseTable<int>(lcp_array);
      } /*}}}*/
  
      int lcp(int i, int j) {  // longest cummon prefix length between s[i:] and s[j:]{{{
          if (rank[i]<rank[j])   return _seg_lcp_array.query(rank[i], rank[j]);
          else                   return _seg_lcp_array.query(rank[j], rank[i]);
          // if (rank[i] < rank[j]) return sparse_lcp_array.get(rank[i], rank[j]);
          // else                   return sparse_lcp_array.get(rank[j], rank[i]);
      } /*}}}*/
  
      #if defined(PCM) || defined(LOCAL)/*{{{*/
      friend ostream& operator<<(ostream& os, suffix_array& sa) {
          os << endl;
          rep(j_th, sa.n){
              int i = sa.pos[j_th];
              os << right << setw(4);
              os << j_th << ":" << sa.s.substr(i, sa.n-i) << endl;
          }
          return os;
      }
      #endif/*}}}*/
  };    
  // how to use
      // string s;cin>>s;
      // ll n = sz(s);
      // suffix_array sa(s);
      // dump(sa);
      // dump(sa.lcp_array);
      // sa.pos[j]  : j位のsuffixはどこから始まるか
      // sa.rank[i] : s[i:]は何位か
      // sa.lcp_arry[j] : return lcp(s[pos[j]:], s[pos[j+1]:])
      // sa.lcp(i, j) :   return lcp(s[i:], s[j:])
  // snippet:suffix_array }}}


