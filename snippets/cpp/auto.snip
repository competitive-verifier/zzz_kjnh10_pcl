snippet  gcd
  int gcd(int a, int b){
    if (b>a) swap(a,b);
    if (b==0) return a;
    return gcd(b, a%b);
  }
  


snippet  lcd
  int gcd(int a, int b){
    if (b>a) swap(a,b);
    if (b==0) return a;
    return gcd(b, a%b);
  }
  
  int lcd(int a, int b){
    return (a/gcd(a,b))*b;  // overflowしにくいように最初に割り算をする。
  }
  


snippet  reverse_int
  int gcd(int a, int b){
    if (b>a) swap(a,b);
    if (b==0) return a;
    return gcd(b, a%b);
  }
  
  int lcd(int a, int b){
    return (a/gcd(a,b))*b;  // overflowしにくいように最初に割り算をする。
  }
  
  int reverse_int(int number) {
    int reverse=0;
    while (number > 0) {
      reverse = reverse * 10 + number % 10;
      number /= 10;
    }
    return reverse;
  }
  


snippet  digitSum
  int digitSum(int x){/*{{{*/
    int res = 0;
    while (true) {
      res += x%10;
      x /= 10;
      if (x==0) { break; }
    }
    return res;
  }/*}}}*/
  


snippet  sieve
  vector<int> sieve(int n) {  // エラトステネスのふるい O(NloglogN){{{
    // 素数の集合を得たい場合はsort, uniqueをすればよい。
    vector<int> primes(n);
    for (int i = 2; i < n; ++i)
      primes[i] = i;
    for (int i = 2; i*i < n; ++i)
      if (primes[i])
        for (int j = i*i; j < n; j+=i)
          primes[j] = 0;
    return primes;
  }//}}}
  


snippet  prime_factor
  map<int, int> prime_factor(int n) { // 素因数分解 (o(√N)){{{
      map<int, int> res;
      for(int i = 2; i * i <= n; i++) {
          while(n % i == 0) {
              ++res[i];
              n /= i;
          }
      }
      if (n != 1) res[n] += 1;
      return res;
  }
  // (参考)http://pakapa104.hatenablog.com/entry/2016/02/09/230443
  //}}}
  


snippet  syakutori
    int res = 0;
    int sum = 0;
    int r = 0;
    for (int l=0; l<n; ++l) {
      auto isok=[&](){ // [l, r] e.g [l, r+1) is ok?
        if (sum + s[r]<=k) return true;
        else return false;
      };
      while (r<n && isok()) {
        sum += s[r];
        ++r;
      }
      chmax(res, (r-l));
  
      // 枝刈り（not needed）
      if (r==n) break;
  
      // leftをincrementする準備
      if (r==l) ++r;  // l,rが同時に動くのでsumは変動しない。
      else sum -= s[l];
    }
  


snippet  com
  // {{{
  const int MAX = 510000;
  const int MOD = 1000000007;
  
  ll fac[MAX], finv[MAX], inv[MAX];
  
  // 前処理
  void COMinit() {
      fac[0] = fac[1] = 1;
      finv[0] = finv[1] = 1;
      inv[1] = 1;
      for (int i = 2; i < MAX; i++){
          fac[i] = fac[i - 1] * i % MOD;
          inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;
          finv[i] = finv[i - 1] * inv[i] % MOD;
      }
  }
  
  // 二項係数計算
  ll COM(int n, int k){
      if (n < k) return 0;
      if (n < 0 || k < 0) return 0;
      return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;
  }
  


