snippet bit1
  template<typename T=int>
  struct BIT {
    public:
      vector<T> data;  // 1-indexed
  
      // constructor
      BIT(vector<T> v){  // v: 0-index vector
        data = vector<T>(sz(v)+1);
        rep(i, 1, sz(v)) add(i+1, v[i]);
      }
      BIT(int n){
        data = vector<T>(n+1);
      }
      //------------
  
      T sum(int idx){  // return sum of [1, r]
        T res = 0;
        for (int i = idx; i > 0; i -= i&-i) res += data[i];
        return res;
      }
  
      void add(int idx, T x){
        for (int i = idx; i <= (int)data.size(); i += i&-i){
          data[i] += x;
        }
      }
  
    private:
  };
  
  ostream& operator<<(ostream& stream, BIT<int> bit){
    int n = sz(bit.data);
    stream << "bit[";
    rep(i, 1, n){
      stream << bit.sum(i) << (i==n-1 ? "" : ", ");
    }
    stream << "]";
    return stream;
  }
  


snippet lcs
  #define MAX_N 5000
  #define MAX_M 5000
  int lcs(string s, string t){
    int n = sz(s);
    int m = sz(t);
    int dp[MAX_N+1][MAX_M+1]={};  // 1-index
  
    rep(i, n){
      rep(j, m){
        if (s[i]==t[j])
          chmax(dp[i+1][j+1], dp[i][j]+1);
        else{
          chmax(dp[i+1][j+1], dp[i][j+1]);
          chmax(dp[i+1][j+1], dp[i+1][j]);
        }
      }
    }
    return dp[n][m];
  }
  


snippet bit
  template<typename T=int> struct BIT {//{{{
    int n;
    vector<T> dat;
  
    BIT(int n=0){ //{{{
      initialize(n);
    } //}}}
  
    void initialize(int nin){ //{{{
      n = nin;
      dat.resize(n);
      for(int i = 0; i<n; i++) dat[i] = 0;
    } //}}}
  
    T sum(int i){ //{{{
      T s = 0;
      while(i >= 0){
        s += dat[i];
        i = (i & (i+1)) - 1;
      }
      return s;
    } //}}}
  
    T sum(int i, int j){ //{{{  [i, j]
      if(i > j) return 0;
      return sum(j) - sum(i-1);
    } //}}}
  
    void add(int i, T x){ //{{{
      while(i < n){
        dat[i] += x;
        i |= i+1;
      }
    } //}}}
  
    int lower_bound(T x){ // a[0]+...+a[ret] >= x{{{
      int ret = -1;
      int k = 1;
      while(2*k <= n) k <<= 1;
      for( ;k>0; k>>=1){
        if(ret+k < n && dat[ret+k] < x){
          x -= dat[ret+k];
          ret += k;
        }
      }
      return ret + 1;
    } //}}}
  }; //}}}
  


snippet mint2
  template<unsigned mod>/*{{{*/
  class mint {
  public:
    unsigned x;
    mint(): x(0) { }
    mint(signed y) : x(y >= 0 ? y % mod : mod - (-y) % mod) {}
    unsigned get() const { return x; }
  
    // 逆数
    mint inv() const {
      ll a = 1, p = x, e = mod-2;
      while(e > 0) {
        if(e%2 == 0) {p = (p*p) % mod; e /= 2;}
        else {a = (a*p) % mod; e--;}
      }
      a %= mod;
      return mint(a);
    }
    // e乗
    mint pow(ll e) {
      ll a = 1, p = x;
      while(e > 0) {
        if(e%2 == 0) {p = (p*p) % mod; e /= 2;}
        else {a = (a*p) % mod; e--;}
      }
      a %= mod;
      return mint(a);
    }
    // 2のx乗
    mint pow2() {
      ll a = 1, p = 2, e = x;
      while(e > 0) {
        if(e%2 == 0) {p = (p*p) % mod; e /= 2;}
        else {a = (a*p) % mod; e--;}
      }
      a %= mod;
      return mint(a);
    }
  
    // Comparators
    bool operator <(mint b) { return x < b.x; }
    bool operator >(mint b) { return x > b.x; }
    bool operator<=(mint b) { return x <= b.x; }
    bool operator>=(mint b) { return x >= b.x; }
    bool operator!=(mint b) { return x != b.x; }
    bool operator==(mint b) { return x == b.x; }
  
    // increment, decrement
    mint operator++() { x++; return *this; }
    mint operator--() { x--; return *this; }
  
    // Basic Operations
    mint &operator+=(mint that) {
      x = ((ll)x+that.x)%mod;
      return *this;
    }
    mint &operator-=(mint that) {
      x = ((((ll)x-that.x)%mod)+mod)%mod;
      return *this;
    }
    mint &operator*=(mint that) {
      x = (ll)x * that.x % mod;
      return *this;
    }
    // O(log(mod))かかるので注意
    mint &operator/=(mint that) {
      x = (ll)x * that.inv() % mod;
      return *this;
    }
    mint &operator%=(mint that) {
      x = (ll)x % that.x;
      return *this;
    }
    mint operator+(mint that)const{return mint(*this) += that;}
    mint operator-(mint that)const{return mint(*this) -= that;}
    mint operator*(mint that)const{return mint(*this) *= that;}
    mint operator/(mint that)const{return mint(*this) /= that;}
    mint operator%(mint that)const{return mint(*this) %= that;}
  };
  typedef mint<1000000007> mint;
  ostream& operator<<(ostream& os, const mint& a){
    os << a.x;
    return os;
  }
  /*}}}*/
  


snippet mint
  int mod = 1e9+7;
  struct mint { //逆元などを使いたければmint2{{{
    int x;
    mint(int x=0):x((x%mod+mod)%mod){}
    mint& operator+=(const mint a) {
      (x += a.x) %= mod;
      return *this;
    }
    mint& operator-=(const mint a) {
      (x += mod-a.x) %= mod;
      return *this;
    }
    mint& operator*=(const mint a) {
      (x *= a.x) %= mod;
      return *this;
    }
    mint operator+(const mint a) const {
      mint res(*this);
      return res+=a;
    }
    mint operator-(const mint a) const {
      mint res(*this);
      return res-=a;
    }
    mint operator*(const mint a) const {
      mint res(*this);
      return res*=a;
    }
  };
  ostream& operator<<(ostream& os, const mint& a){
    os << a.x;
    return os;
  } //}}}
  


snippet zip
  // zip: a = [3, 10, 5, 5, 2]
  vector<int> unzipper; // [2, 3, 5, 10]
  map<int, int> zipper; // {2:0, 3:2, 5:3, 10:4}
  vector<int> zipped; // [2, 4, 3, 3, 0]
  auto zip=[&](vector<int> a){ //{{{
    int n = sz(a);
    unzipper = vector<int>(n); zipped = vector<int>(n);
    rep(i, n) { unzipper[i]=a[i]; }
    uni(unzipper);
    rep(i, sz(unzipper)){ zipper[unzipper[i]] = i; }
    rep(i, n){ zipped[i] = zipper[a[i]]; }
    return 0;
  }; /// }}}
  zip(/*your vector*/);
  dump(unzipper); dump(zipper); dump(zipped);
  


snippet bellman_ford
  struct Edge {
    int to, cost;  // 辺の接続先頂点, 辺の重み
    Edge(int to, int cost) : to(to), cost(cost) {}
  };
  
  typedef vector<vector<Edge> > Graph;  // 隣接リストの型
  Graph graph;  // グラフの辺を格納した構造体
  // graph[v][i]は頂点vから出るi番目の辺Edge
  
  const int INF = 100000000;
  
  vector<int> dist; // 最短距離
  
  // 戻り値がtrueなら負の閉路を含む
  bool bellman_ford(int n, int s) { // nは頂点数、sは開始頂点
    dist = vector<int>(n, INF);
    dist[s] = 0; // 開始点の距離は0
    for (int i = 0; i < n; i++) {
      for (int v = 0; v < n; v++) {
        for (int k = 0; k < (int)graph[v].size(); k++) {
          Edge e = graph[v][k];
          if (dist[v] != INF && dist[e.to] > dist[v] + e.cost) {
            dist[e.to] = dist[v] + e.cost;
            if (i == n - 1) return true; // n回目にも更新があるなら負の閉路が存在
          }
        }
      }
    }
    return false;
  }
  
  // int main() {
  //   int n, m;
  //   cin >> n >> m;
  //
  //   graph = Graph(n);
  //  
  //   for (int i = 0; i < m; i++) {
  //     int from, to, cost;
  //     cin >> from >> to >> cost;
  //     graph[from].push_back(Edge(to, cost));
  //   }
  //  
  //   bellman_ford(n, 0);
  //  
  //   for (int i = 0; i < n; i++) {
  //     if (dist[i] != INF)
  //       cout << "0から" << i << "へのコスト: " << dist[i] << endl;
  //   }
  //  
  //   return 0;
  // }
  


snippet gcd
  int gcd(int a, int b){
    if (b>a) swap(a,b);
    if (b==0) return a;
    return gcd(b, a%b);
  }
  


snippet lcm
  int gcd(int a, int b){
    if (b>a) swap(a,b);
    if (b==0) return a;
    return gcd(b, a%b);
  }
  
  int lcm(int a, int b){
    return (a/gcd(a,b))*b;  // overflowしにくいように最初に割り算をする。
  }
  


snippet reverse_int
  int gcd(int a, int b){
    if (b>a) swap(a,b);
    if (b==0) return a;
    return gcd(b, a%b);
  }
  
  int lcm(int a, int b){
    return (a/gcd(a,b))*b;  // overflowしにくいように最初に割り算をする。
  }
  
  int reverse_int(int number) {
    int reverse=0;
    while (number > 0) {
      reverse = reverse * 10 + number % 10;
      number /= 10;
    }
    return reverse;
  }
  


snippet digitSum
  int digitSum(int x){/*{{{*/
    int res = 0;
    while (true) {
      res += x%10;
      x /= 10;
      if (x==0) { break; }
    }
    return res;
  }/*}}}*/
  


snippet sieve
  vector<int> sieve(int n) {  // エラトステネスのふるい O(NloglogN){{{
    // 素数の集合を得たい場合はsort, uniqueをすればよい。
    vector<int> primes(n);
    for (int i = 2; i < n; ++i)
      primes[i] = i;
    for (int i = 2; i*i < n; ++i)
      if (primes[i])
        for (int j = i*i; j < n; j+=i)
          primes[j] = 0;
    return primes;
  }//}}}
  


snippet is_prime
  bool is_prime(int n) {/*{{{*/
    for (int i = 2; i * i <= n; i++) {
      if (n % i == 0) return false;
    }
    return n != 1;
  }/*}}}*/
  


snippet prime_factor
  map<int, int> prime_factor(int n) { // 素因数分解 (o(√N)){{{
    map<int, int> res;  // vectorで持つことも考えられる。
    for(int i = 2; i * i <= n; i++) {
      while(n % i == 0) {
        ++res[i];
        n /= i;
      }
    }
    if (n != 1) res[n] += 1;
    return res;
  }
  // (参考)http://pakapa104.hatenablog.com/entry/2016/02/09/230443
  //}}}
  


snippet divisor
  vi divisor(int n){  // 約数全列挙{{{
    vi p,q;
    for(int i=1; i*i<=n; i++){
      if (n%i==0){
        p.pb(i);
        if (i*i!=n) q.pb(n/i);
      }
    }
    reverse(all(q));
    p.insert(p.end(), all(q));
    return p;
  }//}}}
  


snippet slide_min
  template< typename T >  //{{{
  vector<T> slide_min(const vector<T> &v, int k) {
    deque< int > deq;
    vector< T > ret;
    int m = sz(v);
    rep(i, m){
      while(!deq.empty() && v[deq.back()] >= v[i]) {
        deq.pop_back();
      }
      deq.push_back(i);
      if(i - k + 1 >= 0) {
        ret.emplace_back(v[deq.front()]);
        if(deq.front() == i - k + 1) deq.pop_front();
      }
    }
    return ret;  // sz(res) == m-k+1, last index is m-k
  }  //}}}
  


snippet syakutori
    int res = 0;
    int sum = 0;
    int r = 0;
    for (int l=0; l<n; ++l) {
      auto isok=[&](){ // [l, r] e.g [l, r+1) is ok?
        if (sum + s[r]<=k) return true;
        else return false;
      };
      while (r<n && isok()) {
        sum += s[r];
        ++r;
      }
      chmax(res, (r-l));
  
      // leftをincrementする準備
      if (r==l) ++r;  // l,rが同時に動くのでsumは変動しない。
      else sum -= s[l];
    }
  


snippet bsearch
  int left = 0;
  int right = 1000000001;
  auto isright = [&](int x) {
    //
    return true;
  };
  while (right-left>1){
    int mid = (right+left)/2;
    if (isright(mid)) { right = mid;}
    else{ left = mid; }
  }
  dump(right);
  


snippet dijkstra
  
  using COST = int;  // TODO: update
  using POS = pair<int, int>;  // TODO: update
  using EDGE = pair<POS, COST>;
  struct GRAPH{
    map<POS, vector<EDGE>> all_edges;
    vector<POS> all_nodes;
  
    void add_edge(POS from, POS to, COST cost){
      all_edges[from].emplace_back(mp(to, cost));
    }
  
    auto operator[](POS pos){
      return all_edges[pos];
    }
  };
  auto& operator<<(auto& stream, GRAPH G){
    stream << G.all_edges;
    return stream;
  }
  
  map<POS, COST> dijkstra(GRAPH& G, POS start){
    map<POS, COST> d;  // 最短距離
    each(node, G.all_nodes) {d[node] = INF;}
  
    PQ<pair<COST, POS>> q;
    q.push(mp(0LL, start));
    while (!q.empty()){
      auto cp = q.top(); q.pop();
      auto cost = cp.first;
      auto pos = cp.second;
  
      if (cost < d[pos]) {
        d[pos] = cost;
        for (const auto &el:G[pos]){
          auto ncost = cost + el.second;
          auto npos = el.first;
          q.push(mp(ncost, npos));
        }
      }
    }
    return d;
  }
  
  // int sample(){
  //   // init and build G
  //   GRAPH G;
  //
  //   int n,m;cin>>n>>m;
  //   rep(i, n) G.all_nodes.pb(i);  // add node
  //   rep(i, m){
  //     POS from, to;
  //     COST cost;
  //     cin>>from>>to>>cost;
  //     from--;to--;
  //     G.add_edge(from, to, cost);
  //     G.add_edge(to, from, cost);  // TODO: if directed, remove this line
  //   }
  //
  //   // calc min distance by G
  //   POS start=...;
  //   POS goal=...;
  //   auto d = dijkstra(G, start);
  //   cout << d[goal] << endl;
  //   return 0;
  // }
  


snippet cout
  cout << ${0:TARGET} << endl;
  


snippet couts
  rep(i, sz(${1:x})) cout << $1[i] << (i!=sz($1)-1 ? " " : "\n");
  


snippet ?
    (${1} ? ${2} : ${3})
  


snippet inv
  vector<int> ${1}(n);
  rep(i, n) {
    cin>>$1[i];
  }
  dump($1);${0}
  


snippet invv
  vector<vector<int>> ${1}(h, vector<int>(w));
  rep(i, h){
    rep(j,w){
      cin>>$1[i][j];
    }
  }
  


snippet invvs
  vector<vector<int>> ${1}(h, vector<int>(w));
  rep(i, h){
    string tmp;cin>>tmp;
    rep(j,w){
      if (tmp[j]=='#') $1[i][j]=1;
      else             $1[i][j]=0; 
    }
  }
  


snippet rep
  rep(${0}){
  }
  


snippet rrep
  rrep(${0}){
  }
  


snippet for
  for(int i=0; i<n; i++){${0}
  }
  


snippet if
  if (${0}) {
  }
  


snippet else
  else{${0}
  }
  


snippet elif
  else if(${0}){
  }
  


snippet while
  while (${0}){
  }
  


snippet reprep
  rep(${1}) rep(${2}){${0}
  }
  


snippet d
  dump(${0});
  


snippet af
  assert(false);
  


snippet sortkey
  sort(all(${0}), [&](auto &left, auto &right){return left.second < right.second;});
  


snippet perm
  do{
    ${0};
  } while (next_permutation(all(x)));
  


snippet to_bin
  string to_bin(int n, int d){
    // nをd桁の2進数で表示する。
    stringstream ss;
    ss << bitset<20>(n);
    return ss.str().substr(20-d, d);
  }
  


snippet warsharll
  // init
  int d[N][N]={};  // 必要があればglobalに
  rep(i, N)rep(j, N){
    d[i][j] = (i==j ? 0 : INF);
  }
  
  // input
  ${0};
  
  // calc
  rep(k, N){
    rep(i, N){
      rep(j, N){
        chmin(d[i][j], d[i][k]+d[k][j]);
      }
    }
  }
  dump_2d(d, N, N);
  


snippet digitdp
  rep(i, sz(S)){  //桁数
    rep(leq, 2){  //未満確定フラグ
      int lim = leq ? 9 : S[i]-'0';
      rep(d, lim+1){
        dp[leq || d<lim][i] += dp[leq][i-1];
      }
    }
  }
  


snippet rangesum
  int rangesum(int l, int r){
    // a[]: accumulative sum
    l = max(0, l);
    // r = min(0, n-1);
    if (l > r) return 0;
    return a[r] - (l-1>=0 ? a[l-1] : 0);
  }
  


snippet asv
  // acumulative sum vector {{{
  template<typename T=int>
  struct asvector : public vector<T> {
    using vector<T>::vector;
    vector<T> cum; //accumulative sum
    bool is_accumulated = false;
  
    public:
    T rsum(int l, int r) {  // return sum of [l, r] of data.
      if (!is_accumulated)
        _accumulate();
      l = std::max(0LL, l);
      r = std::min(r, sz(cum)-1);
      return _calc_rangesum(l, r);
    }
  
    T rsum(int r) {  // return sum of [0, r] of data.
      if (!is_accumulated)
        _accumulate();
      int l = 0;
      r = std::min(r, sz(cum)-1);
      return _calc_rangesum(l, r);
    }
  
    void _accumulate(){
      cum = vector<T>(*this);
      for(T i=1; i<sz(cum); i++){
        cum[i] = cum[i-1] + (*this)[i];
      }
      is_accumulated = true;
    }
  
    void push_back(T x){
      (*this).emplace_back(x);
      is_accumulated = false;
    }
  
    private:
    T _calc_rangesum(int l, int r) {
      if (l > r)
        return 0;
      else
        return cum[r] - (l-1>=0 ? cum[l-1] : 0);
    }
  };
  using asvi = asvector<int>;
  //}}}
  


snippet sandbox
  using namespace std;
  #include <bits/stdc++.h>
  #include <iostream>
  
  int main(){
    return 0;
  }
  


snippet remove_leading_zeros
  str.erase(0, min(str.find_first_not_of('0'), str.size()-1));
  


snippet pow2
  int p[500001];  // power of 2 {{{
  p[0] = 1;
  rep(i, 1, 500002){
    p[i] = p[i-1]*2;
    p[i] %= MOD;
  }
  // }}}
  


snippet pow
  int pow_(int b, int x){ //{{{
    if (x==1) return b%M;
    if (x%2==0){
      int t = pow_(b, x/2);
      return (t*t)%M;
    }
    else{
      return pow_(b, x-1)*b%M;
    }
  } //}}}
  


snippet lambda
alias f
  auto f=[&](){
  };
  


snippet dxdy
  int dx[]={1, -1, 0, 0};
  int dy[]={0, 0, 1, -1};
  


snippet ostream
alias <<
  ostream& operator<<(ostream& os, const ${1:type}& ${2}){
    os << ${3};
    return os;
  }
  


snippet POS
alias pos
  struct POS{ 
    int node, level;
    POS(int n, int l) : node(n), level(l){};
  };
  bool operator<(auto &left, auto &right){
    if (left.node != right.node) return (left.node < right.node);
    else return left.level < right.level;
  }
  auto& operator<<(auto& stream, POS pos){
    stream << "pos(" << pos.node << "," << pos.level << ")";
    return stream;
  }
  


snippet kruskal
  // {{{
  template<typename T>
  struct Kruskal{
    
    struct edge{
      int from,to;
      T cost;
      int used;
      edge(){}
      edge(int from,int to,T cost):
        from(from),to(to),cost(cost),used(0){}
      bool operator<(const edge& e) const{
        return cost<e.cost;
      }
    };
  
    int n;
    vector<int> p,r;
    vector<edge> edges;
  
    Kruskal(){}
    Kruskal(int n):n(n){}
  
    void init(int n){
      r.assign(n,1);
      p.resize(n);
      iota(p.begin(),p.end(),0);
    }
    
    int find(int x){
      return (x==p[x]?x:p[x]=find(p[x]));
    }
  
    bool same(int x,int y){
      return find(x)==find(y);
    }
  
    void unite(int x,int y){
      x=find(x);y=find(y);
      if(x==y) return;
      if(r[x]<r[y]) swap(x,y);
      r[x]+=r[y];
      p[y]=x;
    }
  
    void add_edge(int u,int v,T c){
      edges.emplace_back(u,v,c);
    }
    
    T build(){
      sort(edges.begin(),edges.end());
      init(n);
      T res=0;
      for(auto &e:edges){
        if(!same(e.from,e.to)){
          res+=e.cost;
          unite(e.from,e.to);
          e.used=1;
        }
      }
      return res;
    }
  };
  // int main(){
  //   int V,E;
  //   scanf("%d %d",&V,&E);
  //   Kruskal<int> ksk(V);
  //   for(int i=0;i<E;i++){
  //     int a,b,c;
  //     scanf("%d %d %d",&a,&b,&c);
  //     ksk.add_edge(a,b,c);
  //   }
  //   printf("%d\n",ksk.build());
  //   return 0;
  // }
  //}}}
  


snippet com
  const int MAX = 510000;
  const int MOD = 1000000007;
  // Calculate COM(MAX, k) for k<=MAX by O(1) after COMinit() by O(MAX)
  // {{{
  ll fac[MAX], finv[MAX], inv[MAX];
  
  // 前処理
  void COMinit() {
      fac[0] = fac[1] = 1;
      finv[0] = finv[1] = 1;
      inv[1] = 1;
      for (int i = 2; i < MAX; i++){
          fac[i] = fac[i - 1] * i % MOD;
          inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;
          finv[i] = finv[i - 1] * inv[i] % MOD;
      }
  }
  
  // 二項係数計算
  ll COM(int n, int k){
      if (n < k) return 0;
      if (n < 0 || k < 0) return 0;
      return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;
  }
  //}}}
  


snippet unionfind
  struct UnionFind {
    vector<int> data;  // size defined only for root node
    int count;
  
    UnionFind(int size) : data(size, -1), count(size){ }
  
    bool merge(int x, int y) {
      x=root(x); y=root(y);
      if (x!=y) {
        if (data[y]<data[x]) swap(x, y);
        data[x]+=data[y]; data[y]=x;
        count--;
      }
      return x != y;
    }
    int root(int x) {
      return (data[x]<0 ? x : data[x]=root(data[x]));
    }
    bool same(int x,int y){
      return root(x)==root(y);
    }
    int size(int x) {
      return -data[root(x)];
    }
  };
  


snippet kmp
  // kmp をやるための前計算
  vector<int> makeTable(const string& s) {
    int n = s.size();
    vector<int> ret(n+1);
    ret[0] = -1;
    int j = -1;
    for (int i = 0; i < n; i++) {
      while (j >= 0 && s[i] != s[j]) j = ret[j];
      ret[i+1] = ++j;
    }
    return ret;
  }
  
  // str の中に word とマッチする場所のリストを返す
  // ret のそれぞれの要素 el は, 「str[el] からの文字列が word と一致する」ことを示す
  vector<int> kmp(const string& str, const string& word) {
    vector<int> table = makeTable(word), ret;
    int m = 0, i = 0, n = str.size();
    while (m+i < n) {
      if (word[i] == str[m+i]) {
        if (++i == (int)(word.size())) {
          ret.push_back(m);
          m = m+i-table[i];
          i = table[i];
        }
      } else {
        m = m+i-table[i];
        if (i > 0) i = table[i];
      }
    }
    return ret;
  }
  


snippet template
  // template version 1.11
  using namespace std;
  #include <iostream>
  #include <bits/stdc++.h>
  
  // varibable settings {{{
  #define infile "../test/sample-1.in"
  #define int long long
  const int INF=1e18;
  const int MOD=1e9+7;
  // }}}
  
  // define basic macro {{{
  #define _overload3(_1,_2,_3,name,...) name
  #define _rep(i,n) repi(i,0,n)
  #define repi(i,a,b) for(int i=(int)(a);i<(int)(b);++i)
  #define rep(...) _overload3(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)
  #define _rrep(i,n) rrepi(i,0,n)
  #define rrepi(i,a,b) for(int i=(int)((b)-1);i>=(int)(a);--i)
  #define rrep(...) _overload3(__VA_ARGS__,rrepi,_rrep,)(__VA_ARGS__)
  #define each(i,a) for (auto&& i : a)
  #define all(x) (x).begin(),(x).end()
  #define sz(x) ((int)(x).size())
  #define pb(a) push_back(a)
  #define mp(a, b) make_pair(a, b)
  #define uni(x) sort(all(x));x.erase(unique(all(x)),x.end())
  #define ub upper_bound
  #define lb lower_bound
  #define posl(A, x) (lower_bound(all(A), x)-A.begin())
  #define posu(A, x) (upper_bound(all(A),x)-A.begin())
  template<class T> inline void chmax(T &a, const T &b) { if((a) < (b)) (a) = (b); }
  template<class T> inline void chmin(T &a, const T &b) { if((a) > (b)) (a) = (b); }
  
  typedef long long ll;
  typedef vector<int> vi;
  typedef vector<vi> vvi;
  typedef long double ld;
  typedef pair<int,int> pii;
  typedef tuple<int,int,int> iii;
  
  template<typename T> using PQ = priority_queue<T, vector<T>, greater<T>>;
  struct Fast { Fast(){ std::cin.tie(0); ios::sync_with_stdio(false); } } fast;
  
  #if defined(PCM) || defined(LOCAL)
    #include "/home/koji0708/go/src/github.com/kjnh10/pcl/template/codes/lib/dump.hpp"
  #else
    #define dump(...) 42
    #define dump_1d(...) 42
    #define dump_2d(...) 42
  #endif
  //}}}
  
  int solve(){
    return 0;
  }
  
  signed main() { //{{{
  #ifdef INPUT_FROM_FILE
    std::ifstream in(infile);
    std::cin.rdbuf(in.rdbuf());
  #endif
    solve();
    return 0;
  } //}}}
  


snippet SegmentTree2DRMQ
alias 2drmq
  struct segtree {
      int H, W;
      vector<vector<int>> dat;
      segtree(){}
      segtree(vector<vector<int>> &f) {
          H = W = 1;
          while(H < (int)f.size()) H <<= 1;
          while(W < (int)f[0].size()) W <<= 1;
          dat.assign(2*H-1,vector<int>(2*W-1,INF));
          init(f);
      }
      void init(vector<vector<int>> &f) {
          for (int i = 0; i < (int)f.size(); i++)
              for (int j = 0; j < (int)f[0].size(); j++)
                  dat[i+H-1][j+W-1] = f[i][j];
          dump("hello");
          for (int i = 2*H-2; i > H-2; i--)
              for (int j = W-2; j >= 0; j--)
                  dat[i][j] = min(dat[i][2*j+1], dat[i][2*j+2]);
          dump("hello1");
          for (int i = H-2; i >= 0; i--)
              for (int j = 0; j < 2*W-1; j++)
                  dat[i][j] = min(dat[2*i+1][j], dat[2*i+2][j]);
          dump("hello2");
      }
      int minimum(int li, int lj, int ri, int rj) { return minimum_h(li,lj,ri,rj,0,H,0); }
      int minimum_h(int li, int lj, int ri, int rj, int si, int ti, int k) {
          if(ri <= si or ti <= li) return INF;
          if(li <= si and ti <= ri) return minimum_w(lj,rj,0,W,k,0);
          const int mi = (si+ti)/2;
          return min(minimum_h(li,lj,ri,rj,si,mi,2*k+1), minimum_h(li,lj,ri,rj,mi,ti,2*k+2));
      }
      int minimum_w(int lj, int rj, int sj, int tj, int i, int k) {
          if(rj <= sj or tj <= lj) return INF;
          if(lj <= sj and tj <= rj) return dat[i][k];
          const int mj = (sj+tj)/2;
          return min(minimum_w(lj,rj,sj,mj,i,2*k+1),minimum_w(lj,rj,mj,tj,i,2*k+2));
      }
  };
  


snippet SegmentTreeRSQ
alias rsq
  struct SegmentTree {
  private:
      int n;
      vector<int> node;
  public:
      SegmentTree(vector<int> v) {
          int sz = (int)v.size();
          n = 1; while(n < sz) n *= 2;
          node.resize(2*n-1, 0);
   
          for(int i=0; i<sz; i++) node[i+n-1] = v[i];
          for(int i=n-2; i>=0; i--) node[i] = node[i*2+1] + node[i*2+2];
      }
   
      void add(int k, int val) {
          k += (n - 1);
          node[k] += val;
   
          while(k > 0) {
              k = (k - 1) / 2;
              node[k] = node[2*k+1] + node[2*k+2];
          }
      }
   
      // get sum of [l r)
      int getsum(int a, int b, int k=0, int l=0, int r=-1) {
          if(r < 0) r = n;
          if(b <= l || r <= a) return 0;
          if(a <= l && r <= b) return node[k];
   
          int vl = getsum(a, b, 2*k+1, l, (l+r)/2);
          int vr = getsum(a, b, 2*k+2, (l+r)/2, r);
          return vl + vr;
      }
  };
  


snippet SegmentTreeRMQ
alias rmq
  struct SegmentTree {
    private:
      int n;
      vector<int> node;
  
    public:
      SegmentTree(vector<int> v) {
        int sz = v.size();
        n = 1; while(n < sz) n *= 2;
        node.resize(2*n-1, INF);
        for(int i=0; i<sz; i++) node[i+n-1] = v[i];
        for(int i=n-2; i>=0; i--) node[i] = min(node[2*i+1], node[2*i+2]);
      }
  
      void update(int x, int val) {
        x += (n - 1);
        node[x] = val;
        while(x > 0) {
          x = (x - 1) / 2;
          node[x] = min(node[2*x+1], node[2*x+2]);
        }
      }
  
      // get min of [l, r)
      int getmin(int a, int b, int k=0, int l=0, int r=-1) {
        if(r < 0) r = n;
        if(r <= a || b <= l) return INF;
        if(a <= l && r <= b) return node[k];
  
        int vl = getmin(a, b, 2*k+1, l, (l+r)/2);
        int vr = getmin(a, b, 2*k+2, (l+r)/2, r);
        return min(vl, vr);
      }
  };
  


