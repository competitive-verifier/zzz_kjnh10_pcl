snippet bit1
  template<typename T=int>
  struct BIT {
    public:
      vector<T> data;  // 1-indexed
  
      // constructor
      BIT(vector<T> v){  // v: 0-index vector
        data = vector<T>(sz(v)+1);
        rep(i, 1, sz(v)) add(i+1, v[i]);
      }
      BIT(int n){
        data = vector<T>(n+1);
      }
      //------------
  
      T sum(int idx){  // return sum of [1, r]
        T res = 0;
        for (int i = idx; i > 0; i -= i&-i) res += data[i];
        return res;
      }
  
      void add(int idx, T x){
        for (int i = idx; i <= (int)data.size(); i += i&-i){
          data[i] += x;
        }
      }
  
    private:
  };
  
  ostream& operator<<(ostream& stream, BIT<int> bit){
    int n = sz(bit.data);
    stream << "bit[";
    rep(i, 1, n){
      stream << bit.sum(i) << (i==n-1 ? "" : ", ");
    }
    stream << "]";
    return stream;
  }
  


snippet bit
  
  template<typename T=int> struct bit {//{{{
    int n;
    vector<T> dat;
    vector<T> raw;
  
    bit(int _n=0){ //{{{
      n = _n;
      dat = vector<T>(n);
      raw = vector<T>(n);
    } //}}}
  
    bit(vector<T> a){ // {{{
      n = (int)a.size();
      dat = vector<T>(n);
      raw = vector<T>(n);
      for(int i = 0; i<n; i++){
        add(i, a[i]);
        raw[i] = a[i];
      }
    } //}}}
  
    T rsum(int i){ //{{{ [0, i]
      T s = 0;
      while(i >= 0){
        s += dat[i];
        i = (i & (i+1)) - 1;
      }
      return s;
    } //}}}
  
    T sum(int l, int r){ //{{{  [l, r)
      if(l > r-1) return 0;
      return rsum(r-1) - rsum(l-1);
    } //}}}
  
    void add(int i, T x){ //{{{
      raw[i] += x;
      while(i < n){
        dat[i] += x;
        i |= i+1;
      }
    } //}}}
  
    int lower_bound(T x){ // a[0]+...+a[ret] >= x{{{
      int ret = -1;
      int k = 1;
      while(2*k <= n) k <<= 1;
      for( ;k>0; k>>=1){
        if(ret+k < n && dat[ret+k] < x){
          x -= dat[ret+k];
          ret += k;
        }
      }
      return ret + 1;
    } //}}}
  
    friend ostream& operator<<(ostream &os, bit<T>& b){ //{{{
      os << endl << "  raw:" << b.raw << endl;
      vector<T> acum;
      rep(i, b.n){
        acum.pb(b.sum(i));
      }
      os << "  acm:" << acum << endl;
      return os;
    } //}}}
  }; //}}}
  


snippet RectangleSum
  
  template <typename T>
  struct RectangleSum {
    vector<vector<T>> sum;
    T GetSum(int left, int right, int top, int bottom) { //[left, right], [top, bottom]{{{
      T res = sum[bottom][right];
      if (left > 0) res -= sum[bottom][left - 1];
      if (top > 0) res -= sum[top - 1][right];
      if (left > 0 && top > 0) res += sum[top - 1][left - 1];
      return res;
    }/*}}}*/
  
    RectangleSum(const vector<vector<T>> &s) {/*{{{*/
      int h = s.size();
      int w = s[0].size();
      sum.resize(h);
      for (int i = 0; i < h; i ++) sum[i].resize(w, 0);
      for (int y = 0; y < h; y ++) {
        for (int x = 0; x < w; x ++) {
          sum[y][x] = s[y][x];
          if (y > 0) sum[y][x] += sum[y - 1][x];
          if (x > 0) sum[y][x] += sum[y][x - 1];
          if (y > 0 && x > 0) sum[y][x] -= sum[y - 1][x - 1];
        }
      }
    }/*}}}*/
  };
  


snippet Pos
alias pos
  struct Pos{
    int x,y;
    Pos(int _x, int _y) : x(_x), y(_y){
    }
    Pos() {
      x = 0; y = 0;
    }
    bool in(int a, int b, int c, int d){ // x in [a, b) && y in [c, d)
      if (a<=x && x<b && c<=y && y<d) return true;
      else return false;
    }
  
    bool operator<(const Pos &r) const { return (x!=r.x ? x<r.x : y<r.y); }
    bool operator>(const Pos &r) const { return (x!=r.x ? x>r.x : y>r.y); }
    bool operator==(const Pos &r) const { return (x==r.x && y==r.y); }
  
    friend ostream& operator<<(ostream& stream, Pos p){
      stream << "(" << p.x <<  "," << p.y << ")";
      return stream;
    }
  };
  


snippet zip
  // zip: a = [3, 10, 5, 5, 2]
  vector<int> unzipper; // [2, 3, 5, 10]
  map<int, int> zipper; // {2:0, 3:2, 5:3, 10:4}
  vector<int> zipped; // [2, 4, 3, 3, 0]
  auto zip=[&](vector<int> a){ //{{{
  	int n = sz(a);
  	unzipper = vector<int>(n); zipped = vector<int>(n);
  	rep(i, n) { unzipper[i]=a[i]; }
  	uni(unzipper);
  	rep(i, sz(unzipper)){ zipper[unzipper[i]] = i; }
  	rep(i, n){ zipped[i] = zipper[a[i]]; }
  	return 0;
  }; /// }}}
  zip(/*your vector*/);
  dump(unzipper); dump(zipper); dump(zipped);
  


snippet gcd
  int gcd(int a, int b){
    if (b>a) swap(a,b);
    if (b==0) return a;
    return gcd(b, a%b);
  }
  


snippet lcm
  int gcd(int a, int b){
    if (b>a) swap(a,b);
    if (b==0) return a;
    return gcd(b, a%b);
  }
  
  int lcm(int a, int b){
    return (a/gcd(a,b))*b;  // overflowしにくいように最初に割り算をする。
  }
  


snippet reverse_int
  int gcd(int a, int b){
    if (b>a) swap(a,b);
    if (b==0) return a;
    return gcd(b, a%b);
  }
  
  int lcm(int a, int b){
    return (a/gcd(a,b))*b;  // overflowしにくいように最初に割り算をする。
  }
  
  int reverse_int(int number) {
    int reverse=0;
    while (number > 0) {
      reverse = reverse * 10 + number % 10;
      number /= 10;
    }
    return reverse;
  }
  


snippet digitSum
  int digitSum(int x){/*{{{*/
    int res = 0;
    while (true) {
      res += x%10;
      x /= 10;
      if (x==0) { break; }
    }
    return res;
  }/*}}}*/
  


snippet is_prime
  bool is_prime(int n) {/*{{{*/
    for (int i = 2; i * i <= n; i++) {
      if (n % i == 0) return false;
    }
    return n != 1;
  }/*}}}*/
  


snippet prime_factor
  map<int, int> prime_factor(int n) { // 素因数分解 (o(√N)){{{
    map<int, int> res;  // vectorで持つことも考えられる。
    for(int i = 2; i * i <= n; i++) {
      while(n % i == 0) {
        ++res[i];
        n /= i;
      }
    }
    if (n != 1) res[n] += 1;
    return res;
  }
  // (参考)http://pakapa104.hatenablog.com/entry/2016/02/09/230443
  //}}}
  


snippet divisor
  vi divisor(int n){  // 約数全列挙{{{
    vi p,q;
    for(int i=1; i*i<=n; i++){
      if (n%i==0){
        p.pb(i);
        if (i*i!=n) q.pb(n/i);
      }
    }
    reverse(all(q));
    p.insert(p.end(), all(q));
    return p;
  }//}}}
  


snippet sieve
  
  struct Sieve {
    // エラトステネスのふるい O(NloglogN)
    int n;
    vector<int> f;
    vector<int> primes;  // [2, 3, 5, .......]
    Sieve(int n=1):n(n), f(n+1) {/*{{{*/
      f[0] = f[1] = -1;
      for (ll i = 2; i <= n; ++i) {
        if (f[i]) continue;
        primes.push_back(i);
        f[i] = i;
        for (ll j = i*i; j <= n; j += i) {
          if (!f[j]) f[j] = i;
        }
      }
    }/*}}}*/
    bool isPrime(int x) { return f[x] == x;}
    vector<int> factorList(int x) {/*{{{*/
      vector<int> res;
      while (x != 1) {
        res.push_back(f[x]);
        x /= f[x];
      }
      return res;
    }/*}}}*/
    vector<pii> factor(int x) {/*{{{*/
      vector<int> fl = factorList(x);
      if (fl.size() == 0) return {};
      vector<pii> res(1, mp(fl[0], 0));
      for (int p : fl) {
        if (res.back().first == p) {
          res.back().second++;
        } else {
          res.emplace_back(p, 1);
        }
      }
      return res;
    }/*}}}*/
  };
  
  // Sieve sv(1e6);
  // sv.factor(x);  // 素因数分解
  


snippet mint2
  template<unsigned mod>/*{{{*/
  class mint {
  public:
    unsigned x;
    mint(): x(0) { }
    mint(signed y) : x(y >= 0 ? y % mod : mod - (-y) % mod) {}
    unsigned get() const { return x; }
  
    // 逆数
    mint inv() const {
      ll a = 1, p = x, e = mod-2;
      while(e > 0) {
        if(e%2 == 0) {p = (p*p) % mod; e /= 2;}
        else {a = (a*p) % mod; e--;}
      }
      a %= mod;
      return mint(a);
    }
    // e乗
    mint pow(ll e) {
      ll a = 1, p = x;
      while(e > 0) {
        if(e%2 == 0) {p = (p*p) % mod; e /= 2;}
        else {a = (a*p) % mod; e--;}
      }
      a %= mod;
      return mint(a);
    }
    // 2のx乗
    mint pow2() {
      ll a = 1, p = 2, e = x;
      while(e > 0) {
        if(e%2 == 0) {p = (p*p) % mod; e /= 2;}
        else {a = (a*p) % mod; e--;}
      }
      a %= mod;
      return mint(a);
    }
  
    // Comparators
    bool operator <(mint b) { return x < b.x; }
    bool operator >(mint b) { return x > b.x; }
    bool operator<=(mint b) { return x <= b.x; }
    bool operator>=(mint b) { return x >= b.x; }
    bool operator!=(mint b) { return x != b.x; }
    bool operator==(mint b) { return x == b.x; }
  
    // increment, decrement
    mint operator++() { x++; return *this; }
    mint operator--() { x--; return *this; }
  
    // Basic Operations
    mint &operator+=(mint that) {
      x = ((ll)x+that.x)%mod;
      return *this;
    }
    mint &operator-=(mint that) {
      x = ((((ll)x-that.x)%mod)+mod)%mod;
      return *this;
    }
    mint &operator*=(mint that) {
      x = (ll)x * that.x % mod;
      return *this;
    }
    // O(log(mod))かかるので注意
    mint &operator/=(mint that) {
      x = (ll)x * that.inv() % mod;
      return *this;
    }
    mint &operator%=(mint that) {
      x = (ll)x % that.x;
      return *this;
    }
    mint operator+(mint that)const{return mint(*this) += that;}
    mint operator-(mint that)const{return mint(*this) -= that;}
    mint operator*(mint that)const{return mint(*this) *= that;}
    mint operator/(mint that)const{return mint(*this) /= that;}
    mint operator%(mint that)const{return mint(*this) %= that;}
  };
  typedef mint<1000000007> mint;
  ostream& operator<<(ostream& os, const mint& a){
    os << a.x;
    return os;
  }
  /*}}}*/
  


snippet slide_min
  template< typename T >  //{{{
  vector<T> slide_min(const vector<T> &v, int k) {
    deque< int > deq;
    vector< T > ret;
    int m = sz(v);
    rep(i, m){
      while(!deq.empty() && v[deq.back()] >= v[i]) {
        deq.pop_back();
      }
      deq.push_back(i);
      if(i - k + 1 >= 0) {
        ret.emplace_back(v[deq.front()]);
        if(deq.front() == i - k + 1) deq.pop_front();
      }
    }
    return ret;  // sz(res) == m-k+1, last index is m-k
  }  //}}}
  


snippet syakutori
    int res = 0;
    int sum = 0;
  
    auto isok=[&](int r){ // [l, r] e.g [l, r+1) is ok?
      if (sum + s[r-1]<=k) return true;
      else               return false;
    };
  
    int r = 0;
    for (int l=0; l<n; ++l) {
      while (r<n && isok(r+1)) {
        sum += s[r];
        ++r;
      }
      chmax(res, (r-l));
  
      // leftをincrementする準備
      if (r==l) ++r;  // l,rが同時に動くのでsumは変動しない。
      else sum -= s[l];
    }
  


snippet bsearch
  int left = 0;
  int right = 1000000001;
  auto isright = [&](int x) {
    //
    return true;
  };
  while (right-left>1){
    int mid = (right+left)/2;
    if (isright(mid)) { right = mid;}
    else{ left = mid; }
  }
  dump(right);
  


snippet cout
  cout << ${0:TARGET} << endl;
  


snippet couts
  rep(i, sz(${1:x})) cout << $1[i] << (i!=sz($1)-1 ? " " : "\n");
  


snippet ?
    (${1} ? ${2} : ${3})
  


snippet inv
  vector<int> ${1}(n);
  rep(i, n) {
    cin>>$1[i];
  }
  dump($1);${0}
  


snippet invv
  vector<vector<int>> ${1}(h, vector<int>(w));
  rep(i, h){
    rep(j,w){
      cin>>$1[i][j];
    }
  }
  


snippet invvs
  vector<vector<int>> ${1}(h, vector<int>(w));
  rep(i, h){
    string tmp;cin>>tmp;
    rep(j,w){
      if (tmp[j]=='#') $1[i][j]=1;
      else             $1[i][j]=0; 
    }
  }
  


snippet rep
  rep(${0}){
  }
  


snippet rrep
  rrep(${0}){
  }
  


snippet for
  for(int i=0; i<n; i++){${0}
  }
  


snippet if
  if (${0}) {
  }
  


snippet else
  else{${0}
  }
  


snippet elif
  else if(${0}){
  }
  


snippet while
  while (${0}){
  }
  


snippet reprep
  rep(${1}) rep(${2}){${0}
  }
  


snippet d
  dump(${0});
  


snippet af
  assert(false);
  


snippet sortkey
  sort(all(${0}), [&](auto &left, auto &right){return left.second < right.second;});
  


snippet perm
  do{
    ${0};
  } while (next_permutation(all(x)));
  


snippet to_bin
  #define N 61
  string to_bin(int n, int d){
    // nをd桁の2進数で表示する。
    stringstream ss;
    ss << bitset<N>(n);
    return ss.str().substr(N-d, d);
  }
  // int d = (32 - __builtin_clz(n));  // 桁数
  // int f = N - d; to_bin()で返ってきた文字列で最初に1が立っているindex
  


snippet warsharll
  // init
  int d[N][N]={};  // 必要があればglobalに
  rep(i, N)rep(j, N){
    d[i][j] = (i==j ? 0 : INF);
  }
  
  // input
  ${0};
  
  // calc
  rep(k, N){
    rep(i, N){
      rep(j, N){
        chmin(d[i][j], d[i][k]+d[k][j]);
      }
    }
  }
  dump_2d(d, N, N);
  


snippet digitdp
  rep(i, sz(S)){  //桁数
    rep(leq, 2){  //未満確定フラグ
      int lim = leq ? 9 : S[i]-'0';
      rep(d, lim+1){
        dp[leq || d<lim][i] += dp[leq][i-1];
      }
    }
  }
  


snippet rangesum
  int rangesum(int l, int r){
    // a[]: accumulative sum
    l = max(0, l);
    // r = min(0, n-1);
    if (l > r) return 0;
    return a[r] - (l-1>=0 ? a[l-1] : 0);
  }
  


snippet asv
  // acumulative sum vector {{{
  template<typename T>
  struct asvector {
    vector<T> cum; //accumulative sum
    asvector(vector<T> a): cum(a){  // {{{  // constructor
      rep(i, 1, sz(a))  cum[i]+=cum[i-1];
    } // }}}
  
    T rsum(int l, int r) {  // return sum of [l, r) of data.  {{{
      l = max(0LL, l);
      r = min(r, sz(cum));
      if (l<=r){
        return cum[r-1] - (l-1>=0 ? cum[l-1] : 0);
      }
      else{
        return 0;
      }
    } // }}}
  
    T& operator[](int i) { // {{{
      return cum[i]; 
    } // }}}
  
    friend ostream& operator<<(ostream &os, asvector<T>& as){//{{{
      os << as.cum; return os;
    } //}}}
  };
  //}}}
  


snippet sandbox
  using namespace std;
  #include <bits/stdc++.h>
  #include <iostream>
  
  int main(){
    return 0;
  }
  


snippet remove_leading_zeros
  str.erase(0, min(str.find_first_not_of('0'), str.size()-1));
  


snippet pow2
  int p[500001];  // power of 2 {{{
  p[0] = 1;
  rep(i, 1, 500002){
    p[i] = p[i-1]*2;
    p[i] %= MOD;
  }
  // }}}
  


snippet pow
  int pow_(int b, int x){ //{{{
    if (x==1) return b%M;
    if (x%2==0){
      int t = pow_(b, x/2);
      return (t*t)%M;
    }
    else{
      return pow_(b, x-1)*b%M;
    }
  } //}}}
  


snippet lambda
alias f
  auto f = [&](){
  };
  


snippet dfs_lambda
  auto dfs = [&](const auto& dfs, int x, int v) -> void {
    // 処理
    dfs(dfs, nx, nv);
  };
  


snippet dxdy
  int dx[]={1, -1, 0, 0};
  int dy[]={0, 0, 1, -1};
  


snippet ostream
alias <<
  ostream& operator<<(ostream& os, const ${1:type}& ${2}){
    os << ${3};
    return os;
  }
  


snippet query
  int query(){
  
    cerr << endl;
    return 0;
  }
  
  signed main(){
    int Q;cin>>Q;
    rep(_, Q){
      query();
    }
    return 0;
  }
  


snippet random_generator
  uint64_t rng() {
    static mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());
    return uniform_int_distribution<uint64_t>(0, -1)(mt);
  }
  


snippet bitall
  rep(mask, 1<<n){
    vi vmask(n);
    rep(i, n){
      if (mask&(1<<i)) vmask[i] = 1;
    }
    cerrendl;
    dump(vmask);
    rep(i, n){
      if (vmask[i]){
      }
      else{
      }
    }
  }
  


snippet printf
  printf("%.12f\n", ${1});
  


snippet sep
alias <<
  << " " << ${1}
  


snippet event_sort
  
  struct Event {
    Event(int t_, int s_, int e_, int isIn_) : t(t_), s(s_), e(e_), isIn(isIn_) {}
    int t;
    int s, e;
    int isIn;
  
    bool operator<(const Event& rhs) {
      if (t == rhs.t)
        return isIn < rhs.isIn;
  
      return t < rhs.t;
    }
  };
  
  void event_sort(vector<int>& s, vector<int>& e) {
    // 回収はl, rは掃除するversion
    multiset<int> e_set;
    int n = sz(s);
  
    vector<Event> events;
    for (int i = 0; i < n; i++) {
      events.emplace_back(s[i], s[i], e[i], 1);
      events.emplace_back(e[i] + 1, s[i], e[i], 0);
    }
  
    sort(all(events));
  
    for (int i = 0; i < 2 * n; i++) {
      if (events[i].isIn) {
        e_set.insert(events[i].e);
      }
      else {
        e_set.erase(e_set.find(events[i].e));
      }
    }
  }
  


snippet com
  const int MAX = 510000;
  // Calculate COM(MAX, k) for k<=MAX by O(1) after COMinit() by O(MAX)
  // {{{
  ll fac[MAX], finv[MAX], inv[MAX];
  
  // 前処理
  void COMinit() {
      fac[0] = fac[1] = 1;  // 階乗
      finv[0] = finv[1] = 1; // 階乗の逆元
      inv[1] = 1;  // 逆元
      for (int i = 2; i < MAX; i++){
          fac[i] = fac[i - 1] * i % mod;
          inv[i] = mod - inv[mod%i] * (mod / i) % mod;
          finv[i] = finv[i - 1] * inv[i] % mod;
      }
  }
  
  // 二項係数計算
  ll COM(int n, int k){
      if (n < k) return 0;
      if (n < 0 || k < 0) return 0;
      return fac[n] * (finv[k] * finv[n - k] % mod) % mod;
  }
  //}}}
  


snippet dfs
  
  stack<int> st;
  vector<int> used(n);
  
  st.push(0);
  while (!st.empty()){
    auto u = st.top();st.pop();
    if (used[u]) continue;
    used[u] = 1;
  
    each(v, g[u]){
      if (used[v]) continue;
      // if (d[u]+cost>=d[v]) continue;
      // d[v] = d[u]+cost;
      st.push(v);
    }
  }
  


snippet bfs
  
  queue<int> q;
  vector<int> used(n);
  
  q.push(0);
  while (!q.empty()){
    auto u = q.front();q.pop();
    if (used[u]) continue;
    used[u] = 1;
  
    each(v, g[u]){
      // process
      q.push(v);
    }
  }
  


snippet 01bfs
  
  deque<int> dq;
  vector<int> used(n);
  
  dq.push_back(0);
  while (!dq.empty()){
    auto u = dq.front();dq.pop_front();
    if (used[u]) continue;
    used[u] = 1;
  
    each(v, g[u]){
      // process
      q.push_back(v);
    }
  }
  


snippet template
  // template version 1.11
  using namespace std;
  #include <bits/stdc++.h>
  
  // varibable settings {{{
  #define int long long
  #define infile "../test/sample-1.in"
  // }}}
  // define basic macro {{{
  #define _overload3(_1,_2,_3,name,...) name
  #define _rep(i,n) repi(i,0,n)
  #define repi(i,a,b) for(int i=(int)(a);i<(int)(b);++i)
  #define rep(...) _overload3(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)
  #define _rrep(i,n) rrepi(i,0,n)
  #define rrepi(i,a,b) for(int i=(int)((b)-1);i>=(int)(a);--i)
  #define rrep(...) _overload3(__VA_ARGS__,rrepi,_rrep,)(__VA_ARGS__)
  #define each(i,a) for (auto&& i : a)
  #define all(x) (x).begin(),(x).end()
  #define sz(x) ((int)(x).size())
  #define pb(a) push_back(a)
  #define mp(a, b) make_pair(a, b)
  #define uni(x) sort(all(x));x.erase(unique(all(x)),x.end())
  #define ub upper_bound
  #define lb lower_bound
  #define posl(A, x) (lower_bound(all(A), x)-A.begin())
  #define posu(A, x) (upper_bound(all(A),x)-A.begin())
  template<class T> inline void chmax(T &a, const T &b) { if((a) < (b)) (a) = (b); }
  template<class T> inline void chmin(T &a, const T &b) { if((a) > (b)) (a) = (b); }
  
  typedef long long ll;
  typedef vector<int> vi;
  typedef vector<vi> vvi;
  typedef long double ld;
  typedef pair<int,int> pii;
  typedef tuple<int,int,int> iii;
  
  template<typename T> using PQ = priority_queue<T, vector<T>, greater<T>>;
  struct Fast { Fast(){ std::cin.tie(0); ios::sync_with_stdio(false); } } fast;
  
  #if defined(PCM) || defined(LOCAL)
    #include "/home/koji0708/go/src/github.com/kjnh10/pcl/template/codes/lib/dump.hpp"
  #else
    #define dump(...) 42
    #define dump_1d(...) 42
    #define dump_2d(...) 42
  #endif
  //}}}
  
  #include "mint.cpp"
  


snippet mint
  int mod = 1e9+7;
  struct mint { //{{{
    int x;
    mint(int x=0):x((x%mod+mod)%mod){}
  
    // ?= operator
    mint& operator+=(const mint a) { (x += a.x) %= mod; return *this; }
    mint& operator-=(const mint a) { (x += mod-a.x) %= mod; return *this; }
    mint& operator*=(const mint a) { (x *= a.x) %= mod; return *this; }
    mint&operator/=(const mint&rhs){return *this*=rhs.inv();}
  
    mint operator+(const mint a) const { mint res(*this); return res+=a; }
    mint operator-(const mint a) const { mint res(*this); return res-=a; }
    mint operator*(const mint a) const { mint res(*this); return res*=a; }
    mint operator/(const mint&rhs)const{return mint(*this)/=rhs;}
  
    mint pow(int n)const{
      mint res(1),x(*this);
      if (n<0){
        n = -n;
        x =(*this).inv();
      }
      while(n){
        if(n&1)res*=x;
        x*=x;
        n>>=1;
      }
      return res;
    }
    mint inv()const{return pow(mod-2);}
    /*mint inv()const{
      int x,y;
      int g=extgcd(v,mod,x,y);
      assert(g==1);
      if(x<0)x+=mod;
      return mint(x);
      }*/
    friend ostream& operator<<(ostream&os,const mint&m){
      return os<<m.x;
    }
    bool operator<(const mint&r)const{return x<r.x;}
    bool operator==(const mint&r)const{return x==r.x;}
  };
  //}}}
  


snippet napsack
    int n,h;
    cin>>h>>n;
    vector<int> v(n),w(n);
    rep(i,n) cin>>v[i]>>w[i];
  
    vector<int> dp(h+1, INF);
    dp[0]=0;
    rep(i,n) rep(j,h+1){ // 個数制限なし
    // rep(i,n) rrep(j,h+1){ // 01 napsack
      chmin(dp[min(j+v[i], h)], dp[j]+w[i]);  // jから配る
    }
    cout<<dp[h]<<endl;
  


snippet topological_sort
alias tps
  template<class node>
  using graph = vector<vector<node>>;
  
  template<class node>
  pair<vector<node>, int> topological_sort(const graph<node>& G){
    int V = sz(G);  // node数
    vector<node> ans;  // sort後の結果を格納
    vector<int> h(V); // 頂点ごとの入次数
    stack<node> st;  // 入次数が0になっている頂点の集合
    int max_len = 0; // 最長経路の長さ
  /*{{{*/
    // 入次数を計算する。
    rep(v, V){
      for(auto to: G[v]){
        h[to]++;
      }
    }
  
    // 最初に入次数0になっている頂点を集める。
    rep(v, V){
      if (h[v]==0){
        st.push(v); 
        ans.push_back(v);
      }
    }
  
    // 入次数0の頂点をansに追加しそこから出て行く辺は削除していく。O(V+E)
    while(!st.empty()){
      stack<node> nex_st;
      while(!st.empty()){
        node v = st.top();st.pop();
        for(auto to: G[v]){
          h[to]--;
          if (h[to]==0){
            ans.push_back(to);
            nex_st.push(to);
          }
        }
      }
      max_len++;
      st = nex_st;
    }
  /*}}}*/
    return make_pair(ans, max_len);  // ans.size()<Vなら閉路がありDAGではない。閉路内の頂点はstに入り得ないので。
  }
  


snippet gridgraph
  
    // grid graphを通常のグラフに格納する。
    // (i, j) -> i*w + j
    // u -> (u/w, u%w)
  
    int h,w;cin>>h>>w;
    int n = h*w;
    vvi block(h, vi(w));
    rep(i, h){
      string s;cin>>s;
      rep(j, w){
        block[i][j] = (s[j]=='.'?0:1);
      }
    }
  
    vvi g(n);
    // Graph G;
  
    int di[]={1, -1, 0, 0};
    int dj[]={0, 0, 1, -1};
    rep(i, h)rep(j, w){
      if (block[i][j]) continue;  // blockから出る辺はない
      int u = i*w+j;
  
      rep(k, 4){
        int ni = i+di[k];
        int nj = j+dj[k];
        int v = ni*w + nj;
        if (is_in(ni, 0, h) && is_in(nj, 0, w)){
          if (block[ni][nj]) continue;  // blockに入る辺はない
          g[u].pb(v);
          // G.add_edge(u, v, 1);
          // 自分から生える辺だけでよい。そうしないと二重辺になってしまう。
        }
      }
    }
  


snippet double_sweep
  
  int double_sweep(const auto & g){/*{{{*/
    int n = sz(g);
    int x = 0;
    int max_d = 0;
    auto dfs = [&](const auto& dfs, auto& d, int u, int cost) -> void {
      each(v, g[u]){
        if (d[v]<INF) continue;
        d[v] = cost+1;
        if (d[v]>max_d){
          chmax(max_d, d[v]);
          x = v;
        }
        dfs(dfs, d, v, cost+1);
      }
    };
  
    vi d0(n, INF); d0[0] = 0;  // distance from 0
    dfs(dfs, d0, 0, 0);
    vi dx(n, INF); dx[x] = 0;  // distance from x
    int a = x;  // 保存
  
    max_d = 0;
    dfs(dfs, dx, x, 0);
    int b = x;
  
    return max_d; // d(a,b) == max_d;
  }/*}}}*/
  


snippet bellman_ford
  struct Edge {
    int to, cost;  // 辺の接続先頂点, 辺の重み
    Edge(int to, int cost) : to(to), cost(cost) {}
  };
  
  typedef vector<vector<Edge> > Graph;  // 隣接リストの型
  Graph graph;  // グラフの辺を格納した構造体
  // graph[v][i]は頂点vから出るi番目の辺Edge
  
  const int INF = 100000000;
  
  vector<int> dist; // 最短距離
  
  // 戻り値がtrueなら負の閉路を含む
  bool bellman_ford(int n, int s) { // nは頂点数、sは開始頂点
    dist = vector<int>(n, INF);
    dist[s] = 0; // 開始点の距離は0
    for (int i = 0; i < n; i++) {
      for (int v = 0; v < n; v++) {
        for (int k = 0; k < (int)graph[v].size(); k++) {
          Edge e = graph[v][k];
          if (dist[v] != INF && dist[e.to] > dist[v] + e.cost) {
            dist[e.to] = dist[v] + e.cost;
            if (i == n - 1) return true; // n回目にも更新があるなら負の閉路が存在
          }
        }
      }
    }
    return false;
  }
  
  // int main() {
  //   int n, m;
  //   cin >> n >> m;
  //
  //   graph = Graph(n);
  //  
  //   for (int i = 0; i < m; i++) {
  //     int from, to, cost;
  //     cin >> from >> to >> cost;
  //     graph[from].push_back(Edge(to, cost));
  //   }
  //  
  //   bellman_ford(n, 0);
  //  
  //   for (int i = 0; i < n; i++) {
  //     if (dist[i] != INF)
  //       cout << "0から" << i << "へのコスト: " << dist[i] << endl;
  //   }
  //  
  //   return 0;
  // }
  


snippet dijkstra
  
  using Pos = int;  // TODO: update if needed
  
  using Cost = int;  // TODO: update if needed
  Cost zerocost = 0LL;  // TODO: update if needed
  Cost infcost = INF;  // TODO: update if needed
  // using Cost = pii;
  // Cost zerocost = mp(0, 0);
  // Cost infcost = mp(INF, INF);
  
  struct Edge {
    Pos to;/*{{{*/
    Cost cost;
    Edge(Pos to, Cost cost): to(to), cost(cost) {
    }
    friend auto& operator<<(auto &os, const Edge& e){
      os << e.to << " " << e.cost;
      return os;
    }/*}}}*/
  };
  struct Graph{
    unordered_map<Pos, vector<Edge>> all_edges;//Posがpiiでなくintならunordredの方が早い{{{
    void add_edge(Pos from, Pos to, Cost cost){
      all_edges[from].emplace_back(to, cost);
    }
  
    auto operator[](Pos pos) {
      return all_edges[pos];
    }
  
    friend auto& operator<<(auto &os, const Graph& G){
      os << G.all_edges;
      return os;
    }/*}}}*/
  };
  struct Dist {
    unordered_map<Pos, Cost> data;/*{{{*/
    Cost operator[](Pos pos){
      if (data.find(pos)!=data.end()) return data[pos];
      else                      return infcost;
    }/*}}}*/
  };
  Dist dijkstra(Graph& G, Pos start) {
    vector<Pos> starts = {start};
    return dijkstra(G, starts);
  };
  
  Dist dijkstra(Graph& G, vector<Pos> starts) {  // 多点スタート
    Dist d;  // 最短距離{{{
    PQ<pair<Cost, Pos>> pq;
    each(start, starts){
      d.data[start] = zerocost;
      pq.push(mp(zerocost, start));
    }
    while (!pq.empty()){
      auto cp = pq.top(); pq.pop();
      auto cost = cp.first;
      auto u = cp.second;
      for (const auto &edge: G[u]){
        Pos v = edge.to;
        Cost ncost = cost+edge.cost;
        if (ncost < d[v]){
          d.data[u] = cost;
          pq.push(mp(ncost, v));
        }
      }
    }
    return d;/*}}}*/
  };
  
  // int sample(){
    // init and build G
    // Graph G;
    //
    // int n,m;cin>>n>>m;
    // rep(i, m){
    //   Pos from, to;
    //   Cost cost;
    //   cin>>from>>to>>cost;
    //   from--;to--;
    //   G.add_edge(from, to, cost);
    //   G.add_edge(to, from, cost);  // TODO: if directed, remove this line
    // }
    //
    // // calc min distance by G
    // auto d = dijkstra(G, {start});
    // cout << d[{goal}] << endl;  // 到達不可能ならd[goal] -> INF
    // return 0;
  // }
  


snippet kruskal
  // {{{
  template<typename T>
  struct Kruskal{
    
    struct edge{
      int from,to;
      T cost;
      int used;
      edge(){}
      edge(int from,int to,T cost):
        from(from),to(to),cost(cost),used(0){}
      bool operator<(const edge& e) const{
        return cost<e.cost;
      }
    };
  
    int n;
    vector<int> p,r;
    vector<edge> edges;
  
    Kruskal(){}
    Kruskal(int n):n(n){}
  
    void init(int n){
      r.assign(n,1);
      p.resize(n);
      iota(p.begin(),p.end(),0);
    }
    
    int find(int x){
      return (x==p[x]?x:p[x]=find(p[x]));
    }
  
    bool same(int x,int y){
      return find(x)==find(y);
    }
  
    void unite(int x,int y){
      x=find(x);y=find(y);
      if(x==y) return;
      if(r[x]<r[y]) swap(x,y);
      r[x]+=r[y];
      p[y]=x;
    }
  
    void add_edge(int u,int v,T c){
      edges.emplace_back(u,v,c);
    }
    
    T build(){
      sort(edges.begin(),edges.end());
      init(n);
      T res=0;
      for(auto &e:edges){
        if(!same(e.from,e.to)){
          res+=e.cost;
          unite(e.from,e.to);
          e.used=1;
        }
      }
      return res;
    }
  };
  // int main(){
  //   int V,E;
  //   scanf("%d %d",&V,&E);
  //   Kruskal<int> ksk(V);
  //   for(int i=0;i<E;i++){
  //     int a,b,c;
  //     scanf("%d %d %d",&a,&b,&c);
  //     ksk.add_edge(a,b,c);
  //   }
  //   printf("%d\n",ksk.build());
  //   return 0;
  // }
  //}}}
  


snippet StronglyConnectedComponents
alias scc
  using Graph = vector< vector< int > >;
  struct StronglyConnectedComponents {
    // how to use
    // StronglyConnectedComponents scc(g); // g: Graph
    // scc.build();
    // dump(scc.comp, scc.dag);
  
    const Graph &g; //{{{
    vector< int > comp;  // comp[i]: iが属する強連結成分が何番目の成分か
    Graph dag;  // 縮約されたDAG graph. sizeをとれば強連結成分の個数が分かる。
    Graph _rg;  // reversed graph
    vector< int > _order; // order[i]: 行きがけの番号
    vector< int > _used;
  
    StronglyConnectedComponents(Graph &g)
      : g(g), comp(g.size(), -1), _rg(g.size()), _used(g.size()) {
      for(int i = 0; i < sz(g); i++) {
        for(auto e : g[i]) {
          _rg[(int) e].emplace_back(i);
        }
      }
    }
  
    int operator[](int k) {
      return comp[k];
    }
  
    void build() {
      for(int i = 0; i < sz(g); i++) _dfs(i);
      reverse(begin(_order), end(_order));
      int cnt = 0;
      for(int i : _order) if(comp[i] == -1) _rdfs(i, cnt), cnt++;
  
      dag.resize(cnt);
      for(int i = 0; i < sz(g); i++) {
        for(auto &to : g[i]) {
          int x = comp[i], y = comp[to];
          if(x == y) continue;
          dag[x].push_back(y);
        }
      }
    }
  
    void _dfs(int idx) {
      if(_used[idx]) return;
      _used[idx] = true;
      for(int to : g[idx]) _dfs(to);
      _order.push_back(idx);
    }
  
    void _rdfs(int idx, int cnt) {
      if(comp[idx] != -1) return;
      comp[idx] = cnt;
      for(int to : _rg[idx]) _rdfs(to, cnt);
    } //}}}
  };
  


snippet union_find
  struct union_find {
    vector<int> data;  // size defined only for root node
    int count;
    union_find(int size) : data(size, -1), count(size){ }
    bool merge(int x, int y) {/*{{{*/
      x=root(x); y=root(y);
      if (x!=y) {
        if (data[y]<data[x]) swap(x, y);
        data[x]+=data[y]; data[y]=x;
        count--;
      }
      return x != y;
    }/*}}}*/
    int root(int x) { return (data[x]<0 ? x : data[x]=root(data[x])); }
    bool same(int x,int y){ return root(x)==root(y); }
    int size(int x) { return -data[root(x)]; }
  };
  


snippet generalized_baybe_step_giant_step
alias gbsgs
  int mod = 1e9+7;
  struct mint { //{{{
    int x;
    mint(int x=0):x((x%mod+mod)%mod){}
  
    // ?= operator
    mint& operator+=(const mint a) { (x += a.x) %= mod; return *this; }
    mint& operator-=(const mint a) { (x += mod-a.x) %= mod; return *this; }
    mint& operator*=(const mint a) { (x *= a.x) %= mod; return *this; }
    mint&operator/=(const mint&rhs){return *this*=rhs.inv();}
  
    mint operator+(const mint a) const { mint res(*this); return res+=a; }
    mint operator-(const mint a) const { mint res(*this); return res-=a; }
    mint operator*(const mint a) const { mint res(*this); return res*=a; }
    mint operator/(const mint&rhs)const{return mint(*this)/=rhs;}
  
    mint pow(int n)const{
      mint res(1),x(*this);
      if (n<0){
        n = -n;
        x =(*this).inv();
      }
      while(n){
        if(n&1)res*=x;
        x*=x;
        n>>=1;
      }
      return res;
    }
    mint inv()const{return pow(mod-2);}
    /*mint inv()const{
      int x,y;
      int g=extgcd(v,mod,x,y);
      assert(g==1);
      if(x<0)x+=mod;
      return mint(x);
      }*/
    friend ostream& operator<<(ostream&os,const mint&m){
      return os<<m.x;
    }
    bool operator<(const mint&r)const{return x<r.x;}
    bool operator==(const mint&r)const{return x==r.x;}
  };
  //}}}
  
  
  int bsgs(int a, int b){ //{{{
    // find x s.t a^x = b in (mod)
  
    if (b>=mod) return -1;
    if (1%mod==b) return 0;
  
    int h = (int)sqrt(mod)+1; // h s.t x = p*h-r (0<=r<h and 0<=p<=h)
  
    unordered_map<int, vector<int>> rs; // rs[v]: vector of r s.t b*a^r==v
    mint bar = b;
    rep(r, 0, h){
      rs[bar.x].pb(r);
      bar *= a;
    }
    bool looped = false;
    each(el, rs) if (sz(el.second)>1) looped = true;
  
    mint ah = mint(a).pow(h);
    rep(p, 1, h+1){
      int aph = ah.pow(p).x;
      if (rs.find(aph)!=rs.end()){
        reverse(all(rs[aph]));
        each(r, rs[aph]){
          if ((p*h-r)>=0 && mint(a).pow(p*h-r)==b) return p*h-r;
        }
      }
      if (looped) return -1;
    }
  
    return -1;
  } //}}}
  


snippet baybe_step_giant_step
alias bsgs
  int mod = 1e9+7;
  struct mint { //{{{
    int x;
    mint(int x=0):x((x%mod+mod)%mod){}
  
    // ?= operator
    mint& operator+=(const mint a) { (x += a.x) %= mod; return *this; }
    mint& operator-=(const mint a) { (x += mod-a.x) %= mod; return *this; }
    mint& operator*=(const mint a) { (x *= a.x) %= mod; return *this; }
    mint&operator/=(const mint&rhs){return *this*=rhs.inv();}
  
    mint operator+(const mint a) const { mint res(*this); return res+=a; }
    mint operator-(const mint a) const { mint res(*this); return res-=a; }
    mint operator*(const mint a) const { mint res(*this); return res*=a; }
    mint operator/(const mint&rhs)const{return mint(*this)/=rhs;}
  
    mint pow(int n)const{
      mint res(1),x(*this);
      if (n<0){
        n = -n;
        x =(*this).inv();
      }
      while(n){
        if(n&1)res*=x;
        x*=x;
        n>>=1;
      }
      return res;
    }
    mint inv()const{return pow(mod-2);}
    /*mint inv()const{
      int x,y;
      int g=extgcd(v,mod,x,y);
      assert(g==1);
      if(x<0)x+=mod;
      return mint(x);
      }*/
    friend ostream& operator<<(ostream&os,const mint&m){
      return os<<m.x;
    }
    bool operator<(const mint&r)const{return x<r.x;}
    bool operator==(const mint&r)const{return x==r.x;}
  };
  //}}}
  
  
  int bsgs(int a, int b){ //{{{
    if (b>=mod) {
      return -1;
    }
  
    // find x s.t a^x = b in (mod)
    mint x;
    int sq = sqrt(mod);
    // x = p*sq + r  (0<=r<sq and 0<=p<=sq)
  
    map<int, int> minr; // minr[v]: min(r s.t a^r=v)
    mint ar = 1;
    rep(r, 0, sq){
      if (minr.find(ar.x)==minr.end()) minr[ar.x] = r;
      ar *= a;
    }
  
    mint A = mint(a).pow(-sq);
    rep(p, 0, sq+1){
      int Ab = (A.pow(p)*b).x;
      if (minr.find(Ab)!=minr.end()){
        int r = minr[Ab];
        return p*sq + r;
      }
    }
  
    return -1;
  } //}}}
  


snippet lcs
  #define MAX_N 5000
  #define MAX_M 5000
  int lcs(string s, string t){
    int n = sz(s);
    int m = sz(t);
    int dp[MAX_N+1][MAX_M+1]={};  // 1-index
  
    rep(i, n){
      rep(j, m){
        if (s[i]==t[j])
          chmax(dp[i+1][j+1], dp[i][j]+1);
        else{
          chmax(dp[i+1][j+1], dp[i][j+1]);
          chmax(dp[i+1][j+1], dp[i+1][j]);
        }
      }
    }
    return dp[n][m];
  }
  


snippet kmp
  
  // Morris-Pratt
  template<typename T> struct KMP {
    int n;
    T pattern;
    vector<int> a;
    KMP() {}/*{{{*/
    KMP(const T& pattern): pattern(pattern) {
      n = pattern.size();
      a = vector<int>(n+1);
      a[0] = -1;
      int j = -1;
      for (int i = 0; i < n; ++i) {
        while (j != -1 && pattern[j] != pattern[i]) j = a[j];
        j++;
        a[i+1] = j;
      }
    }/*}}}*/
    int operator[](int i) { return a[i];}
    vector<int> findAll(const T& s) {/*{{{*/
      vector<int> res;
      int j = 0;
      for (int i = 0; i < sz(s); ++i) {
        while (j != -1 && pattern[j] != s[i]) j = a[j];
        j++;
        if (j == n) {
          res.push_back(i-j+1);
          j = a[j];
        }
      }
      return res;
    }/*}}}*/
  };
  
  // KMP<vector<int>> kmp({1,2,3});
  // KMP<string> kmp("abc");
  


snippet SegmentTree2DRMQ
alias 2drmq
  struct segtree {
      int H, W;
      vector<vector<int>> dat;
      segtree(){}
      segtree(vector<vector<int>> &f) {
          H = W = 1;
          while(H < (int)f.size()) H <<= 1;
          while(W < (int)f[0].size()) W <<= 1;
          dat.assign(2*H-1,vector<int>(2*W-1,INF));
          init(f);
      }
      void init(vector<vector<int>> &f) {
          for (int i = 0; i < (int)f.size(); i++)
              for (int j = 0; j < (int)f[0].size(); j++)
                  dat[i+H-1][j+W-1] = f[i][j];
          dump("hello");
          for (int i = 2*H-2; i > H-2; i--)
              for (int j = W-2; j >= 0; j--)
                  dat[i][j] = min(dat[i][2*j+1], dat[i][2*j+2]);
          dump("hello1");
          for (int i = H-2; i >= 0; i--)
              for (int j = 0; j < 2*W-1; j++)
                  dat[i][j] = min(dat[2*i+1][j], dat[2*i+2][j]);
          dump("hello2");
      }
      int minimum(int li, int lj, int ri, int rj) { return minimum_h(li,lj,ri,rj,0,H,0); }
      int minimum_h(int li, int lj, int ri, int rj, int si, int ti, int k) {
          if(ri <= si or ti <= li) return INF;
          if(li <= si and ti <= ri) return minimum_w(lj,rj,0,W,k,0);
          const int mi = (si+ti)/2;
          return min(minimum_h(li,lj,ri,rj,si,mi,2*k+1), minimum_h(li,lj,ri,rj,mi,ti,2*k+2));
      }
      int minimum_w(int lj, int rj, int sj, int tj, int i, int k) {
          if(rj <= sj or tj <= lj) return INF;
          if(lj <= sj and tj <= rj) return dat[i][k];
          const int mj = (sj+tj)/2;
          return min(minimum_w(lj,rj,sj,mj,i,2*k+1),minimum_w(lj,rj,mj,tj,i,2*k+2));
      }
  };
  


snippet SegmentTree
alias rmq
  
  template<typename T, typename F>
  struct SegmentTree { // {{{
    private:
      int n; 
      int N;  // 
      vector<T> node;
      F merge;
      T identity;
  
    public:
      SegmentTree(vector<T> a, F f, T id):merge(f), identity(id) {
        n = a.size();
        N = 1; while(N < n) N *= 2;
        node.resize(2*N-1, identity);
        for(int i=0; i<n; i++) node[i+N-1] = a[i];
        for(int i=N-2; i>=0; i--) node[i] = merge(node[2*i+1], node[2*i+2]);
      }
      SegmentTree(int n, F f, T id) : SegmentTree(vector<T>(n, id), f, id) {}
  
      T& operator[](int i) { return node[i+N-1]; }
  
      void update(int x, T val) {
        x += (N - 1);
        node[x] = val;
        while(x > 0) {
          x = (x - 1) / 2;
          node[x] = merge(node[2*x+1], node[2*x+2]);
        }
      }
  
      // query for [l, r)
      T query(int a, int b, int k=0, int l=0, int r=-1) {
        if(r < 0) r = N;
        if(r <= a || b <= l) return identity;
        if(a <= l && r <= b) return node[k];
  
        T vl = query(a, b, 2*k+1, l, (l+r)/2);
        T vr = query(a, b, 2*k+2, (l+r)/2, r);
        return merge(vl, vr);
      }
  
      friend ostream& operator<<(ostream &os, SegmentTree<T, F>& sg){ //
        os << "[";
        for(int i=0; i<sg.n; i++){
          os << sg[i] << (i==sg.n-1?"]\n":", ");
        }
        return os;
      }
  };
  // }}}
  // Sample:
    // -----------------------------------------------
    // auto mymin=[](auto a, auto b){return min(a,b);};
    // SegmentTree<int, decltype(mymin)> seg(a, mymin, 1e18);
  
    // auto mymax=[](auto a, auto b){return max(a,b);};
    // SegmentTree<int, decltype(mymax)> seg(a, mymax, -1e18);
  
    // auto add=[](auto a, auto b){return a+b;};
    // SegmentTree<int, decltype(add)> seg(a, add, 0);
    // -----------------------------------------------
  


