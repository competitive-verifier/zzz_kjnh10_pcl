snippet bsearch
  int left = 0;
  int right = 1000000001;
  auto isright = [&](int x) {
      cerrendl;
      //
      bool ans = (cond ? true : false);
      dump(x, ans);
      return ans;
  };
  while (right - left > 1) {
      int mid = (right + left) / 2;
      if (isright(mid)) {
          right = mid;
      } else {
          left = mid;
      }
  }
  dump(right);
  


snippet bit
  template <typename T = int>
  struct bit {  //{{{
      int n;
      vector<T> dat;
      vector<T> raw;
  
      bit(int _n = 0) {  //{{{
          n = _n;
          dat = vector<T>(n);
          raw = vector<T>(n);
      }  //}}}
  
      bit(vector<T> a) {  // {{{
          n = (int)a.size();
          dat = vector<T>(n);
          raw = vector<T>(n);
          for (int i = 0; i < n; i++) {
              add(i, a[i]);
              raw[i] = a[i];
          }
      }  //}}}
  
      T _rsum(int i) {  //{{{ [0, i]
          T s = 0;
          while (i >= 0) {
              s += dat[i];
              i = (i & (i + 1)) - 1;
          }
          return s;
      }  //}}}
  
      T sum(int l, int r) {  //{{{  [l, r)
          if (l > r - 1) return 0;
          return _rsum(r - 1) - _rsum(l - 1);
      }  //}}}
  
      void add(int i, T x) {  //{{{
          raw[i] += x;
          while (i < n) {
              dat[i] += x;
              i |= i + 1;
          }
      }  //}}}
  
      int lower_bound(T x) {  // a[0]+...+a[ret] >= x{{{
          int ret = -1;
          int k = 1;
          while (2 * k <= n) k <<= 1;
          for (; k > 0; k >>= 1) {
              if (ret + k < n && dat[ret + k] < x) {
                  x -= dat[ret + k];
                  ret += k;
              }
          }
          return ret + 1;
      }  //}}}
  
      friend ostream& operator<<(ostream& os, bit<T>& b) {  //{{{
          os << endl << "  raw:" << b.raw << endl;
          vector<T> acum;
          rep(i, b.n) { acum.pb(b.sum(i)); }
          os << "  acm:" << acum << endl;
          return os;
      }  //}}}
  };     //}}}
  


snippet lis
  int lis(vector<int>& x) { /*{{{*/
      int n = sz(x);
      vector<int> dp(n, INF);
      int res = 0;
      rep(i, n) {
          int j = lb(all(dp), x[i]) - dp.begin();
          chmax(res, j + 1);
          dp[j] = x[i];
      }
      // dump(dp);
      return res;
  } /*}}}*/
  


snippet syakutori
  int res = 0;
  int sum = 0;
  
  auto isok = [&](int r) {  // [l, r] e.g [l, r+1) is ok?
      if (sum + s[r - 1] <= k)
          return true;
      else
          return false;
  };
  
  int r = 0;
  for (int l = 0; l < n; ++l) {
      while (r < n && isok(r + 1)) {
          sum += s[r];
          ++r;
      }
      chmax(res, (r - l));
  
      // leftをincrementする準備
      if (r == l)
          ++r;  // l,rが同時に動くのでsumは変動しない。
      else
          sum -= s[l];
  }
  


snippet slide_min
  template <typename T>  //{{{
  vector<T> slide_min(const vector<T> &v, int k) {
      deque<int> deq;
      vector<T> ret;
      int m = sz(v);
      rep(i, m) {
          while (!deq.empty() && v[deq.back()] >= v[i]) {
              deq.pop_back();
          }
          deq.push_back(i);
          if (i - k + 1 >= 0) {
              ret.emplace_back(v[deq.front()]);
              if (deq.front() == i - k + 1) deq.pop_front();
          }
      }
      return ret;  // sz(res) == m-k+1, last index is m-k
  }  //}}}
  


snippet SegmentTree2DRMQ
alias 2drmq
  struct segtree {
      int H, W;
      vector<vector<int>> dat;
      segtree() {}
      segtree(vector<vector<int>> &f) {
          H = W = 1;
          while (H < (int)f.size()) H <<= 1;
          while (W < (int)f[0].size()) W <<= 1;
          dat.assign(2 * H - 1, vector<int>(2 * W - 1, INF));
          init(f);
      }
      void init(vector<vector<int>> &f) {
          for (int i = 0; i < (int)f.size(); i++)
              for (int j = 0; j < (int)f[0].size(); j++)
                  dat[i + H - 1][j + W - 1] = f[i][j];
          dump("hello");
          for (int i = 2 * H - 2; i > H - 2; i--)
              for (int j = W - 2; j >= 0; j--)
                  dat[i][j] = min(dat[i][2 * j + 1], dat[i][2 * j + 2]);
          dump("hello1");
          for (int i = H - 2; i >= 0; i--)
              for (int j = 0; j < 2 * W - 1; j++)
                  dat[i][j] = min(dat[2 * i + 1][j], dat[2 * i + 2][j]);
          dump("hello2");
      }
      int minimum(int li, int lj, int ri, int rj) {
          return minimum_h(li, lj, ri, rj, 0, H, 0);
      }
      int minimum_h(int li, int lj, int ri, int rj, int si, int ti, int k) {
          if (ri <= si or ti <= li) return INF;
          if (li <= si and ti <= ri) return minimum_w(lj, rj, 0, W, k, 0);
          const int mi = (si + ti) / 2;
          return min(minimum_h(li, lj, ri, rj, si, mi, 2 * k + 1),
                     minimum_h(li, lj, ri, rj, mi, ti, 2 * k + 2));
      }
      int minimum_w(int lj, int rj, int sj, int tj, int i, int k) {
          if (rj <= sj or tj <= lj) return INF;
          if (lj <= sj and tj <= rj) return dat[i][k];
          const int mj = (sj + tj) / 2;
          return min(minimum_w(lj, rj, sj, mj, i, 2 * k + 1),
                     minimum_w(lj, rj, mj, tj, i, 2 * k + 2));
      }
  };
  


snippet segment_tree_lazy
alias lazy
  template <typename T, typename E>
  struct segment_tree_lazy {  //{{{
      // T: 値の型
      // E: update作用素
      using F = function<T(T, T)>;
      using G = function<T(T, E)>;
      using H = function<E(E, E)>;
      int n, height;
      F f;   // 区間のマージ
      G g;   // 更新をどのように行うか
      H h;   // 複数の更新のまとめ方
      T ti;  // 値の単位元
      E ei;  // 恒等置換
      vector<T> dat;
      vector<E> laz;
      segment_tree_lazy() {}
      segment_tree_lazy(F f, G g, H h, T ti, E ei)
          : f(f), g(g), h(h), ti(ti), ei(ei) {}
  
      void init(int n_) { /*{{{*/
          n = 1;
          height = 0;
          while (n < n_) n <<= 1, height++;
          dat.assign(2 * n, ti);
          laz.assign(2 * n, ei);
      } /*}}}*/
  
      void build(const vector<T> &v) { /*{{{*/
          int n_ = v.size();
          init(n_);
          for (int i = 0; i < n_; i++) dat[n + i] = v[i];
          for (int i = n - 1; i; i--)
              dat[i] = f(dat[(i << 1) | 0], dat[(i << 1) | 1]);
      } /*}}}*/
  
      inline T reflect(int k) { /*{{{*/
          return laz[k] == ei ? dat[k] : g(dat[k], laz[k]);
      } /*}}}*/
  
      inline void propagate(int k) { /*{{{*/
          if (laz[k] == ei) return;
          laz[(k << 1) | 0] = h(laz[(k << 1) | 0], laz[k]);
          laz[(k << 1) | 1] = h(laz[(k << 1) | 1], laz[k]);
          dat[k] = reflect(k);
          laz[k] = ei;
      } /*}}}*/
  
      inline void thrust(int k) { /*{{{*/
          for (int i = height; i; i--) propagate(k >> i);
      } /*}}}*/
  
      inline void recalc(int k) { /*{{{*/
          while (k >>= 1)
              dat[k] = f(reflect((k << 1) | 0), reflect((k << 1) | 1));
      } /*}}}*/
  
      void update(int a, int b, E x) { /*{{{*/
          if (a >= b) return;
          thrust(a += n);
          thrust(b += n - 1);
          for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {
              if (l & 1) laz[l] = h(laz[l], x), l++;
              if (r & 1) --r, laz[r] = h(laz[r], x);
          }
          recalc(a);
          recalc(b);
      } /*}}}*/
  
      void set_val(int a, T x) { /*{{{*/
          thrust(a += n);
          dat[a] = x;
          laz[a] = ei;
          recalc(a);
      } /*}}}*/
  
      T query(int a, int b) { /*{{{*/
          if (a >= b) return ti;
          thrust(a += n);
          thrust(b += n - 1);
          T vl = ti, vr = ti;
          for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {
              if (l & 1) vl = f(vl, reflect(l++));
              if (r & 1) vr = f(reflect(--r), vr);
          }
          return f(vl, vr);
      } /*}}}*/
  
      template <typename C>
      int find(int st, C &check, T &acc, int k, int l, int r) { /*{{{*/
          if (l + 1 == r) {
              acc = f(acc, reflect(k));
              return check(acc) ? k - n : -1;
          }
          propagate(k);
          int m = (l + r) >> 1;
          if (m <= st) return find(st, check, acc, (k << 1) | 1, m, r);
          if (st <= l && !check(f(acc, dat[k]))) {
              acc = f(acc, dat[k]);
              return -1;
          }
          int vl = find(st, check, acc, (k << 1) | 0, l, m);
          if (~vl) return vl;
          return find(st, check, acc, (k << 1) | 1, m, r);
      } /*}}}*/
  
      template <typename C>
      int find(int st, C &check) { /*{{{*/
          T acc = ti;
          return find(st, check, acc, 1, 0, n);
      } /*}}}*/
  };    //}}}
  // Sample:
  // -----------------------------------------------
  // init
  // auto f=[](int ta,int tb){return max(ta,tb);};  // how to merge
  // auto g=[](int t,int e){return t+e;};  // how to update
  // int ti=0,ei=0;
  // segment_tree_lazy<int, int> lseg(f,g,g,ti,ei);
  // const int sz = 1<<20;
  // lseg.build(vector<int>(sz,0));
  
  // how to use
  // rep(i, n) lseg.set_val(i, a[i]);
  // lseg.update(l, r, x); // [l, r)
  // lseg.query(l, r); // [l, r)
  // -----------------------------------------------
  


snippet event_sort
  struct Event {
      Event(int t_, int s_, int e_, int isIn_)
          : t(t_), s(s_), e(e_), isIn(isIn_) {}
      int t;
      int s, e;
      int isIn;
  
      bool operator<(const Event& rhs) {
          if (t == rhs.t) return isIn < rhs.isIn;
  
          return t < rhs.t;
      }
  };
  
  void event_sort(vector<int>& s, vector<int>& e) {
      // 回収はl, rは掃除するversion
      multiset<int> e_set;
      int n = sz(s);
  
      vector<Event> events;
      for (int i = 0; i < n; i++) {
          events.emplace_back(s[i], s[i], e[i], 1);
          events.emplace_back(e[i] + 1, s[i], e[i], 0);
      }
  
      sort(all(events));
  
      for (int i = 0; i < 2 * n; i++) {
          if (events[i].isIn) {
              e_set.insert(events[i].e);
          } else {
              e_set.erase(e_set.find(events[i].e));
          }
      }
  }
  


snippet RectangleSum
  template <typename T>
  struct RectangleSum {
      vector<vector<T>> sum;
      T GetSum(int left, int right, int top,
               int bottom) {  //[left, right], [top, bottom]{{{
          T res = sum[bottom][right];
          if (left > 0) res -= sum[bottom][left - 1];
          if (top > 0) res -= sum[top - 1][right];
          if (left > 0 && top > 0) res += sum[top - 1][left - 1];
          return res;
      } /*}}}*/
  
      RectangleSum(const vector<vector<T>> &s) { /*{{{*/
          int h = s.size();
          int w = s[0].size();
          sum.resize(h);
          for (int i = 0; i < h; i++) sum[i].resize(w, 0);
          for (int y = 0; y < h; y++) {
              for (int x = 0; x < w; x++) {
                  sum[y][x] = s[y][x];
                  if (y > 0) sum[y][x] += sum[y - 1][x];
                  if (x > 0) sum[y][x] += sum[y][x - 1];
                  if (y > 0 && x > 0) sum[y][x] -= sum[y - 1][x - 1];
              }
          }
      } /*}}}*/
  };
  


snippet napsack
      int n, h;
      cin >> h >> n;
      vector<int> v(n), w(n);
      rep(i, n) cin >> v[i] >> w[i];
  
      vector<int> dp(h + 1, INF);
      dp[0] = 0;
      rep(i, n) rep(j, h + 1) {  // 個数制限なし
                                 // rep(i,n) r_rep(j,h+1){ // 01 napsack
          chmin(dp[min(j + v[i], h)], dp[j] + w[i]);  // jから配る
      }
      cout << dp[h] << endl;
  


snippet cout
  cout << ${0:TARGET} << endl;
  


snippet couts
  rep(i, sz(${1:x})) cout << $1[i] << (i!=sz($1)-1 ? " " : "\n");
  


snippet ?
  (${1} ? ${2} : ${3})
  


snippet inv
  vector<int> ${1}(n);
  rep(i, n) {
      cin>>$1[i];
  }
  dump($1);${0}
  


snippet invv
  vector<vector<int>> ${1}(h, vector<int>(w));
  rep(i, h){
      rep(j,w){
          cin>>$1[i][j];
      }
  }
  


snippet invvs
  vector<vector<int>> ${1}(h, vector<int>(w));
  rep(i, h){
      string tmp;cin>>tmp;
      rep(j,w){
          if (tmp[j]=='#') $1[i][j]=1;
          else             $1[i][j]=0; 
      }
  }
  


snippet rep
  rep(${0}){
  }
  


snippet r_rep
  r_rep(${0}){
  }
  


snippet for
  for(int i=0; i<n; i++){${0}
  }
  


snippet for_iter
  for(auto iter=begin(${1}); iter!=end($1); ++iter){${0}
  }
  


snippet for_riter
  for(auto riter=rbegin(${1}); riter!=rend($1); ++riter){${0}
  }
  


snippet if
  if (${0}) {
  }
  


snippet else
  else{${0}
  }
  


snippet elif
  else if(${0}){
  }
  


snippet while
  while(${0}){
  }
  


snippet reprep
  rep(${1}) rep(${2}){${0}
  }
  


snippet d
  dump(${0});
  


snippet af
  assert(false);
  


snippet sortkey
  sort(all(${0}), [&](auto &l, auto &r){return l.second < r.second;});
  


snippet perm
  vi p(n);
  iota(all(p), 0LL);
  do{
      dump(p);
      vi ma(a);
      rep(i, n) ma[i] = a[p[i]];
      dump(ma);
  } while (next_permutation(all(p)));
  


snippet to_bin
  #define N 61
  string to_bin(int n, int d){
      // nをd桁の2進数で表示する。
      stringstream ss;
      ss << bitset<N>(n);
      return ss.str().substr(N-d, d);
  }
  // int d = (32 - __builtin_clz(n));  // 最大桁のd: (2^d)
  // int f = N - d; to_bin()で返ってきた文字列で最初に1が立っているindex
  


snippet warsharll
  // init
  vector<vector<int>> d(n, vector<int>(n, INF));
  rep(i, n)rep(j, n){
      if (i==j) d[i][j] = 0;
  }
  
  // input
  ${0};
  
  // calc
  rep(k, n){
      rep(i, n){
          rep(j, n){
              chmin(d[i][j], d[i][k]+d[k][j]);
          }
      }
  }
  dump_2d(d, n, n);
  


snippet digitdp
  int n = sz(s);
  vector<vector<int>> dp(2, vector<int>(n));
  dp[0][0] = 1;
  rep(i, 1, n+1){  //桁数
      rep(leq, 2){  //未満確定フラグ
          int lim = leq ? 9 : s[i-1]-'0';
          rep(d, lim+1){
              dp[leq || d<lim][i] += dp[leq][i-1];
          }
      }
  }
  


snippet rangesum
  int rangesum(int l, int r){
      // a[]: accumulative sum
      l = max(0, l);
      // r = min(0, n-1);
      if (l > r) return 0;
      return a[r] - (l-1>=0 ? a[l-1] : 0);
  }
  


snippet asv
  // acumulative sum vector {{{
  template<typename T>
  struct asvector {
      vector<T> cum; //accumulative sum
      asvector(vector<T> a): cum(a){  // {{{  // constructor
          rep(i, 1, sz(a))  cum[i]+=cum[i-1];
      } // }}}
  
      T sum(int l, int r) {  // return sum of [l, r) of data.  {{{
          l = max(0LL, l);
          r = min(r, sz(cum));
          if (l<r){
              return cum[r-1] - (l-1>=0 ? cum[l-1] : 0);
          }
          else{
              return 0;
          }
      } // }}}
  
      T& operator[](int i) { // {{{
          return cum[i]; 
      } // }}}
  
      friend ostream& operator<<(ostream &os, asvector<T>& as){//{{{
          os << as.cum; return os;
      } //}}}
  };
  //}}}
  


snippet remove_leading_zeros
  str.erase(0, min(str.find_first_not_of('0'), str.size()-1));
  


snippet pow2
  int p[500001];  // power of 2 {{{
  p[0] = 1;
  rep(i, 1, 500002){
      p[i] = p[i-1]*2;
      p[i] %= MOD;
  }
  // }}}
  


snippet pow
  int pow_(int b, int x){ //{{{
      if (x==1) return b%M;
      if (x%2==0){
          int t = pow_(b, x/2);
          return (t*t)%M;
      }
      else{
          return pow_(b, x-1)*b%M;
      }
  } //}}}
  


snippet lambda
alias f
  auto f = [&](){
  };
  


snippet dfs_lambda
  vector<int> used(n);
  auto dfs = [&](const auto& dfs, int u) -> void {
      used[u] = 1;
      each(e, g[u]){
          if (used[e.to]) continue;
          dfs(dfs, e.to);
      }
  };
  dfs(dfs, 0);
  


snippet dxdy
  int dx[]={1, -1, 0, 0};
  int dy[]={0, 0, 1, -1};
  


snippet ostream
  ostream& operator<<(ostream& os, const ${1:type}& ${2}){
      os << ${3};
      return os;
  }
  


snippet query
  int query(){
      cerrendl;
  
      return 0;
  }
  
  signed main(){
      int Q;cin>>Q;
      rep(_, Q){
          query();
      }
      check_input();
      return 0;
  }
  


snippet random_generator
  uint64_t rng() {
      static mt19937 x(chrono::steady_clock::now().time_since_epoch().count());
      return uniform_int_distribution<uint64_t>(0, -1)(x);
  }
  


snippet bitall
  rep(mask, 1<<n){
      vi vmask(n);
      rep(i, n){
          if (mask&(1<<i)) vmask[i] = 1;
      }
      cerrendl;
      dump(vmask);
      rep(i, n){
          if (vmask[i]){
          }
          else{
          }
      }
  }
  


snippet printf
  printf("%.12f\n", ${1});
  


snippet sep
alias <<
  << " " << ${1}
  


snippet interactive
  int counter = 0;
  int query(int u, int v){/*{{{*/
      dump('q', u+1, v+1);
      counter++;
      if (counter>n/2) assert(false);
  
      cout << "?" << " " << u << " " << v << endl;
      fflush(stdout);
  
      // int res = tr.lca(u, v);
      int res; cin>>res;
  
      return res;
  }/*}}}*/
  
  void ans(int u){/*{{{*/
      cout << "!" << " " << u+1 << endl;
  }/*}}}*/
  


snippet pairsort
  template<class T>
  void pairsort(vector<T>& x, vector<T>& y){
      int n = sz(x);
      vector<tuple<T, T>> t(n);
      rep(i, n){
          t[i] = make_tuple(x[i], y[i]);
      }
      sort(all(t));
      rep(i, n){
          x[i] = get<0>(t[i]);
          y[i] = get<1>(t[i]);
      }
  }
  


snippet make_vector
  template<class T> vector<vector<vector<T>>> make_vector_2d(int n1, int n2, T init_value){
      return vector<vector<T>>(n1, vector<T>(n2, init_value));
  }
  
  
  template<class T> vector<vector<vector<T>>> make_vector_3d(int n1, int n2, int n3, T init_value){
      return vector<vector<vector<T>>>(n1, vector<vector<T>>(n2, vector<T>(n3, init_value)));
  }
  // auto dp = make_vector_2d<mint>(n, k, 0);  // like int dp[n][k];
  // auto dp = make_vector_3d<mint>(n, k, m, 0);  // like int dp[n][k][m];
  


snippet erase_loop
  for(auto iter=begin(s); iter!=end(s);){
      // 処理
  
      // 終了処理
      if (*iter%3==0 || *iter==1) {  // delete
          iter = s.erase(iter);
      }
      else{  // non-delete
          ++iter;
      }
  }
  


snippet erase_loop_reverse
  for(auto riter=rbegin(s); riter!=rend(s);){
      // 処理
  
      // 終了処理
      if (*riter%3==0 || *riter==1) {
          auto iter = riter.base(); --iter; // iterに変換
          iter = s.erase(iter); // 要素を削除。これが終了した時点ではiterは削除要素の右を指している。
          riter = reverse_iterator(iter); // reverseすると左に１個進むのでちょうどよい。
      }
      else{
          riter++;
      }
  }
  


snippet dfs
  stack<int> st;
  vector<int> used(n);
  
  st.push(0);
  while (!st.empty()) {
      auto u = st.top();
      st.pop();
      if (used[u]) continue;
      used[u] = 1;
  
      each(v, g[u]) {
          if (used[v]) continue;
          // if (d[u]+cost>=d[v]) continue;
          // d[v] = d[u]+cost;
          st.push(v);
      }
  }
  


snippet bfs
  queue<int> q;
  vector<int> used(n);
  
  q.push(0);
  while (!q.empty()) {
      auto u = q.front();
      q.pop();
      if (used[u]) continue;
      used[u] = 1;
  
      each(v, g[u]) {
          // process
          q.push(v);
      }
  }
  


snippet 01bfs
  deque<int> dq;
  vector<int> used(n);
  
  dq.push_back(0);
  while (!dq.empty()) {
      auto u = dq.front();
      dq.pop_front();
      if (used[u]) continue;
      used[u] = 1;
  
      each(v, g[u]) {
          // process
          q.push_back(v);
      }
  }
  


snippet gcd
  int gcd(int a, int b) {
      if (b > a) swap(a, b);
      if (b == 0) return a;
      return gcd(b, a % b);
  }
  


snippet lcm
  int gcd(int a, int b) {
      if (b > a) swap(a, b);
      if (b == 0) return a;
      return gcd(b, a % b);
  }
  
  int lcm(int a, int b) {
      return (a / gcd(a, b)) * b;  // overflowしにくいように最初に割り算をする。
  }
  


snippet reverse_int
  int gcd(int a, int b) {
      if (b > a) swap(a, b);
      if (b == 0) return a;
      return gcd(b, a % b);
  }
  
  int lcm(int a, int b) {
      return (a / gcd(a, b)) * b;  // overflowしにくいように最初に割り算をする。
  }
  
  int reverse_int(int number) {
      int reverse = 0;
      while (number > 0) {
          reverse = reverse * 10 + number % 10;
          number /= 10;
      }
      return reverse;
  }
  


snippet digitSum
  int digitSum(int x) { /*{{{*/
      int res = 0;
      while (true) {
          res += x % 10;
          x /= 10;
          if (x == 0) {
              break;
          }
      }
      return res;
  } /*}}}*/
  


snippet is_prime
  bool is_prime(int n) { /*{{{*/
      for (int i = 2; i * i <= n; i++) {
          if (n % i == 0) return false;
      }
      return n != 1;
  } /*}}}*/
  


snippet prime_factor
  map<int, int> prime_factor(int n) {  // 素因数分解 (o(√N)){{{
      map<int, int> res;  // vectorで持つことも考えられる。
      for (int i = 2; i * i <= n; i++) {
          while (n % i == 0) {
              ++res[i];
              n /= i;
          }
      }
      if (n != 1) res[n] += 1;
      return res;
  }
  // (参考)http://pakapa104.hatenablog.com/entry/2016/02/09/230443
  //}}}
  


snippet divisor
  vi divisor(int n) {  // 約数全列挙{{{
      vi p, q;
      for (int i = 1; i * i <= n; i++) {
          if (n % i == 0) {
              p.pb(i);
              if (i * i != n) q.pb(n / i);
          }
      }
      reverse(all(q));
      p.insert(p.end(), all(q));
      return p;
  }  //}}}
  


snippet sieve
  struct Sieve {
      // エラトステネスのふるい O(NloglogN)
      int n;                              // n]
      vector<int> f;                      // [1, 2, 3, 2, 5, 2, 7, 2, 3, ....]
      vector<int> primes;                 // [2, 3, 5, .......]
      Sieve(int n = 1) : n(n), f(n + 1) { /*{{{*/
          f[0] = f[1] = -1;
          for (ll i = 2; i <= n; ++i) {
              if (f[i]) continue;
              primes.push_back(i);
              f[i] = i;
              for (ll j = i * i; j <= n; j += i) {
                  if (!f[j]) f[j] = i;
              }
          }
      } /*}}}*/
      bool isPrime(int x) { return f[x] == x; }
  
      vector<int> factor_list(int x) { /*{{{*/
          vector<int> res;
          if (x < n) {
              while (x != 1) {
                  res.push_back(f[x]);
                  x /= f[x];
              }
          } else {
              for (int i = 0; primes[i] * primes[i] <= x; i++) {
                  while (x % primes[i] == 0) {
                      res.pb(primes[i]);
                      x /= primes[i];
                  }
              }
              if (x != 1) res.pb(x);
          }
  
          return res;  // [2, 3, 3, 5, 5, 5.....]
      }                /*}}}*/
  
      vector<pii> factor(int x) { /*{{{*/
          vector<int> fl = factor_list(x);
          if (fl.size() == 0) return {};
          vector<pii> res(1, mp(fl[0], 0));
          for (int p : fl) {
              if (res.back().first == p) {
                  res.back().second++;
              } else {
                  res.emplace_back(p, 1);
              }
          }
          return res;  // [(2,1), (3,2), (5,3), .....]
      }                /*}}}*/
  };
  
  // Sieve sv(1e6);
  // sv.factor(x);  // 素因数分解
  


snippet pascal
  template <class T>
  vector<vector<T>> pascal(int N) {  // {{{
      vector<vector<T>> com(N + 1, vector<T>(N + 1));
      com[0][0] = 1;
      rep(i, 1, N + 1) {
          // パスカルの三角形は0-indexdで段を数えるとよい。
          // com[i]を計算。
          rep(j, 0, i + 1) {
              if (j - 1 >= 0) com[i][j] += com[i - 1][j - 1];
              com[i][j] += com[i - 1][j];
              // com[i][j] /= 2.0;  // probability version
          }
      }
      return com;
  }  // }}}
  


snippet generalized_baybe_step_giant_step
alias gbsgs
  int mod = 1e9 + 7;
  // int mod = 998244353;
  struct mint {  //{{{
      int x;
      mint(int x = 0) : x((x % mod + mod) % mod) {}
  
      // ?= operator
      mint& operator+=(const mint a) {
          (x += a.x) %= mod;
          return *this;
      }
      mint& operator-=(const mint a) {
          (x += mod - a.x) %= mod;
          return *this;
      }
      mint& operator*=(const mint a) {
          (x *= a.x) %= mod;
          return *this;
      }
      mint& operator/=(const mint& rhs) {
          if (rhs.x == 0) throw runtime_error("mint zero division");
          return *this *= rhs.inv();
      }
  
      mint operator+(const mint a) const {
          mint res(*this);
          return res += a;
      }
      mint operator-(const mint a) const {
          mint res(*this);
          return res -= a;
      }
      mint operator*(const mint a) const {
          mint res(*this);
          return res *= a;
      }
      mint operator/(const mint a) const {
          mint res(*this);
          return res /= a;
      }
  
      mint pow(int n) const {
          mint res(1), x(*this);
          if (n < 0) {
              n = -n;
              x = (*this).inv();
          }
          while (n) {
              if (n & 1) res *= x;
              x *= x;
              n >>= 1;
          }
          return res;
      }
  
      mint inv() const {
          if (x == 0) throw runtime_error("inv does not exist");
          return pow(mod - 2);
      }
      // mint inv()const{
      //     int x,y;
      //     int g=extgcd(v,mod,x,y);
      //     assert(g==1);
      //     if(x<0)x+=mod;
      //     return mint(x);
      // }
  
      bool operator<(const mint& r) const { return x < r.x; }
      bool operator==(const mint& r) const { return x == r.x; }
  };
  istream& operator>>(istream& is, const mint& a) { return is >> a.x; }
  ostream& operator<<(ostream& os, const mint& a) { return os << a.x; }
  //}}}
  
  int bsgs(int a, int b) {  //{{{
      // find x s.t a^x = b in (mod)
  
      if (b >= mod) return -1;
      if (1 % mod == b) return 0;
  
      int h = (int)sqrt(mod) + 1;  // h s.t x = p*h-r (0<=r<h and 0<=p<=h)
  
      unordered_map<int, vector<int>> rs;  // rs[v]: vector of r s.t b*a^r==v
      mint bar = b;
      rep(r, 0, h) {
          rs[bar.x].pb(r);
          bar *= a;
      }
      bool looped = false;
      each(el, rs) if (sz(el.second) > 1) looped = true;
  
      mint ah = mint(a).pow(h);
      rep(p, 1, h + 1) {
          int aph = ah.pow(p).x;
          if (rs.find(aph) != rs.end()) {
              reverse(all(rs[aph]));
              each(r, rs[aph]) {
                  if ((p * h - r) >= 0 && mint(a).pow(p * h - r) == b)
                      return p * h - r;
              }
          }
          if (looped) return -1;
      }
  
      return -1;
  }  //}}}
  


snippet baybe_step_giant_step
alias bsgs
  int mod = 1e9 + 7;
  // int mod = 998244353;
  struct mint {  //{{{
      int x;
      mint(int x = 0) : x((x % mod + mod) % mod) {}
  
      // ?= operator
      mint& operator+=(const mint a) {
          (x += a.x) %= mod;
          return *this;
      }
      mint& operator-=(const mint a) {
          (x += mod - a.x) %= mod;
          return *this;
      }
      mint& operator*=(const mint a) {
          (x *= a.x) %= mod;
          return *this;
      }
      mint& operator/=(const mint& rhs) {
          if (rhs.x == 0) throw runtime_error("mint zero division");
          return *this *= rhs.inv();
      }
  
      mint operator+(const mint a) const {
          mint res(*this);
          return res += a;
      }
      mint operator-(const mint a) const {
          mint res(*this);
          return res -= a;
      }
      mint operator*(const mint a) const {
          mint res(*this);
          return res *= a;
      }
      mint operator/(const mint a) const {
          mint res(*this);
          return res /= a;
      }
  
      mint pow(int n) const {
          mint res(1), x(*this);
          if (n < 0) {
              n = -n;
              x = (*this).inv();
          }
          while (n) {
              if (n & 1) res *= x;
              x *= x;
              n >>= 1;
          }
          return res;
      }
  
      mint inv() const {
          if (x == 0) throw runtime_error("inv does not exist");
          return pow(mod - 2);
      }
      // mint inv()const{
      //     int x,y;
      //     int g=extgcd(v,mod,x,y);
      //     assert(g==1);
      //     if(x<0)x+=mod;
      //     return mint(x);
      // }
  
      bool operator<(const mint& r) const { return x < r.x; }
      bool operator==(const mint& r) const { return x == r.x; }
  };
  istream& operator>>(istream& is, const mint& a) { return is >> a.x; }
  ostream& operator<<(ostream& os, const mint& a) { return os << a.x; }
  //}}}
  
  int bsgs(int a, int b) {  //{{{
      if (b >= mod) {
          return -1;
      }
  
      // find x s.t a^x = b in (mod)
      mint x;
      int sq = sqrt(mod);
      // x = p*sq + r  (0<=r<sq and 0<=p<=sq)
  
      map<int, int> minr;  // minr[v]: min(r s.t a^r=v)
      mint ar = 1;
      rep(r, 0, sq) {
          if (minr.find(ar.x) == minr.end()) minr[ar.x] = r;
          ar *= a;
      }
  
      mint A = mint(a).pow(-sq);
      rep(p, 0, sq + 1) {
          int Ab = (A.pow(p) * b).x;
          if (minr.find(Ab) != minr.end()) {
              int r = minr[Ab];
              return p * sq + r;
          }
      }
  
      return -1;
  }  //}}}
  


snippet gridgraph
      // grid graphを通常のグラフに格納する。
      int h, w;
      cin >> h >> w;
      int n = h * w;  // 頂点数
      vvi block(h, vi(w));
      rep(i, h) {
          string s;
          cin >> s;
          rep(j, w) { block[i][j] = (s[j] == '#' ? 1 : 0); }
      }
  
      Graph g(n);
  
      auto nid = [&](int i, int j){return (i*w + j);};
      auto pos = [&](int u) -> pair<int, int> { return {u/w, u%w}; };
      // int u = nid(i, j);
      // auto [i,j] = pos(u);
  
      int di[] = {1, -1, 0, 0};
      int dj[] = {0, 0, 1, -1};
  
      // 下と右のみ. rep(k, 4)をrep(k, 2)に変更するのも忘れない。
      // int di[] = {1, 0};
      // int dj[] = {0, 1};
      rep(i, h) rep(j, w) {
          if (block[i][j]) continue;  // blockから出る辺はない
          rep(k, 4) {
              int ni = i + di[k];
              int nj = j + dj[k];
              if (is_in(ni, 0, h) && is_in(nj, 0, w)) {
                  if (block[ni][nj]) continue;  // blockに入る辺はない
                  g.add_edge(nid(i, j), nid(ni, nj));
                  // 自分から生える辺だけでよい。そうしないと二重辺になってしまう。
              }
          }
      }
  


snippet reroot
      tree tr(n);
      rep(i, n - 1) {
          int u, v;
          cin >> u >> v;
          u--;
          v--;
          tr.add_edge(u, v);
      }
      tr.build(0);
  
      vector<map<int, int>> dp(n);
      // dp[u][v]: uの親をvとするような向きで木を見た時のuを頂点とする部分木の情報
  
      // first dfs
      r_rep(i, 1, n) {
          // 葉からdp
          int u = tr.dfstrv[i];
          dp[u][tr.par[u]] = col[u];  // TODO: update: 子供がいない場合
          each(ch, tr.children[u]) {
              dp[u][tr.par[u]] += max(0LL, dp[ch][u]);  // TODO: update
          }
      }
      dump_2d(dp, n, n);
  
      // second dfs
      rep(i, 0, n) {
          cerrendl;
          // uを頂点とする部分木の情報dp[u][*]を配る。
          int u = tr.dfstrv[i];
          int m = sz(tr.adj[u]);
  
          vector<int> lcum(m + 2);
          vector<int> rcum(m + 2);
          {  // 前処理
              vector<int> child_info(m + 2);
              rep(j, 1, m + 1) {
                  int v = tr.adj[u][j - 1];
                  child_info[j] = max(dp[v][u], 0LL);  // TODO: update
              }
              lcum[0] = 0;
              lcum[m + 1] = 0;  // 単位元を番兵に  // TODO: update
              rcum[0] = 0;
              rcum[m + 1] = 0;  // 単位元を番兵に  // TODO: update
              rep(j, 1, m + 1) {
                  lcum[j] = lcum[j - 1] + child_info[j];  // TODO: update
              }
              r_rep(j, 1, m + 1) {
                  rcum[j] = rcum[j + 1] + child_info[j];  // TODO: update
              }
              dump(child_info);
          }
  
          dump(lcum);
          dump(rcum);
          rep(j, 1, m + 1) {
              int v = tr.adj[u][j - 1];
              dp[u][v] = lcum[j - 1] + rcum[j + 1];  // TODO: update
              dp[u][v] += col[u];  // 追加条件  // TODO: update
              dump(u, v, j, dp[u][v], lcum[j - 1], rcum[j + 1], col[u]);
          }
      }
      dump_2d(dp, n, n);
  
      // answer
      vector<int> ans;
      rep(u, n) {
          int res = col[u];  // TODO: update
          each(v, tr.adj[u]) {
              res += max(0LL, dp[v][u]);  // TODO: update
          }
          ans.push_back(res);
      }
      rep(i, sz(ans)) cout << ans[i] << (i != sz(ans) - 1 ? " " : "\n");
  


snippet lcs
  #define MAX_N 5000
  #define MAX_M 5000
  int lcs(string s, string t) {
      int n = sz(s);
      int m = sz(t);
      int dp[MAX_N + 1][MAX_M + 1] = {};  // 1-index
  
      rep(i, n) {
          rep(j, m) {
              if (s[i] == t[j])
                  chmax(dp[i + 1][j + 1], dp[i][j] + 1);
              else {
                  chmax(dp[i + 1][j + 1], dp[i][j + 1]);
                  chmax(dp[i + 1][j + 1], dp[i + 1][j]);
              }
          }
      }
      return dp[n][m];
  }
  


snippet suffix_array
  template <typename T>
  struct SegmentTree {  // {{{
     private:
      using F = function<T(T, T)>;
      int n;  // 元の配列のサイズ
      int N;  // n以上の最小の2冪
      vector<T> node;
      F merge;
      T identity;
  
     public:
      SegmentTree() {}
      SegmentTree(vector<T> a, F f, T id) : merge(f), identity(id) {
          n = a.size();
          N = 1;
          while (N < n) N *= 2;
          node.resize(2 * N - 1, identity);
          for (int i = 0; i < n; i++) node[i + N - 1] = a[i];
          for (int i = N - 2; i >= 0; i--)
              node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
      }
      SegmentTree(int n, F f, T id) : SegmentTree(vector<T>(n, id), f, id) {}
  
      T& operator[](int i) { return node[i + N - 1]; }
  
      void update(int x, T val) {
          x += (N - 1);
          node[x] = val;
          while (x > 0) {
              x = (x - 1) / 2;
              node[x] = merge(node[2 * x + 1], node[2 * x + 2]);
          }
      }
  
      void add(int x, T val) {
          x += (N - 1);
          node[x] += val;
          while (x > 0) {
              x = (x - 1) / 2;
              node[x] = merge(node[2 * x + 1], node[2 * x + 2]);
          }
      }
  
      // query for [l, r)
      T query(int a, int b, int k = 0, int l = 0, int r = -1) {
          if (r < 0) r = N;
          if (r <= a || b <= l) return identity;
          if (a <= l && r <= b) return node[k];
  
          T vl = query(a, b, 2 * k + 1, l, (l + r) / 2);
          T vr = query(a, b, 2 * k + 2, (l + r) / 2, r);
          return merge(vl, vr);
      }
  
      friend ostream& operator<<(ostream& os, SegmentTree<T>& sg) {  //
          os << "[";
          for (int i = 0; i < sg.n; i++) {
              os << sg[i] << (i == sg.n - 1 ? "]\n" : ", ");
          }
          return os;
      }
  };
  // }}}
  template <class MeetSemiLattice>
  struct SparseTable { /*{{{*/
      vector<vector<MeetSemiLattice> > dat;
      vector<int> height;
  
      SparseTable() {}
      SparseTable(const vector<MeetSemiLattice>& vec) { init(vec); }
      void init(const vector<MeetSemiLattice>& vec) {
          int n = (int)vec.size(), h = 0;
          while ((1 << h) < n) ++h;
          dat.assign(h, vector<MeetSemiLattice>(1 << h));
          height.assign(n + 1, 0);
          for (int i = 2; i <= n; i++) height[i] = height[i >> 1] + 1;
          for (int i = 0; i < n; ++i) dat[0][i] = vec[i];
          for (int i = 1; i < h; ++i)
              for (int j = 0; j < n; ++j)
                  dat[i][j] = min(dat[i - 1][j],
                                  dat[i - 1][min(j + (1 << (i - 1)), n - 1)]);
      }
  
      MeetSemiLattice get(int a, int b) {
          if (a == b) return INF;
          return min(dat[height[b - a]][a],
                     dat[height[b - a]][b - (1 << height[b - a])]);
      }
  };                    /*}}}*/
  struct suffix_array { /*{{{*/
      vector<int> a;
      vector<int> pos;   // pos[j]: j位のsumffixはどこから始まるか
      vector<int> rank;  // rank[i]: s[i:]は何位か
      // pos = rank^-1
      vector<int> lcp_array;           // lcp_arry[j]: s[j:]とs[j+1:]のlcp
      SegmentTree<int> seg_lcp_array;  // lcp_arry[j]: s[j:]とs[j+1:]のlcp
      SparseTable<int> sparse_lcp_array;
      int n;
  
      // constructor{{{
      suffix_array() {}
      suffix_array(vector<int>& a) : a(a), n(a.size()) { _build(); }
      suffix_array(string& s) {
          n = s.size();
          a.resize(n);
          rep(i, n) a[i] = s[i];
          _build();
      } /*}}}*/
  
      void _build() { /*{{{*/
          _build_order();
          _build_lcp_array();
      } /*}}}*/
  
      void _build_order() { /*{{{*/
          pos.resize(n);
          iota(all(pos), 0);
          rank = a;  // aでそのままスコア化
  
          for (int k = 1; k < n; k *= 2) {
              // kでのrankが生成されている前提で2*kでのrankを生成する
  
              auto _comp = [&](int l, int r) {
                  auto left = mp(rank[l], (l + k < n ? rank[l + k] : -1));
                  auto right = mp(rank[r], (r + k < n ? rank[r + k] : -1));
                  return left < right;
              };
              sort(all(pos), _comp);
  
              vector<int> next_rank(n);
              next_rank[pos[0]] = 0;
              int r = 0;
              rep(i, 1, n) {
                  if (_comp(pos[i - 1], pos[i])) r++;
                  next_rank[pos[i]] = r;
              }
              rank = next_rank;
          }
      } /*}}}*/
  
      void _build_lcp_array() { /*{{{*/
          lcp_array.resize(n);
          int con = 1;
          rep(l, 0, n) {
              if (rank[l] + 1 == n) {
                  lcp_array[rank[l]] = -1;
                  con = 1;
                  continue;
              }
  
              if (con > 0) con--;
              int r = pos[rank[l] + 1];
              while (l + con < n && r + con < n && a[l + con] == a[r + con]) {
                  con++;
              }
              lcp_array[rank[l]] = con;
          }
  
          auto mymin = [](auto a, auto b) { return min(a, b); };
          seg_lcp_array = SegmentTree<int>(lcp_array, mymin, 1e18);
          sparse_lcp_array = SparseTable<int>(lcp_array);
      } /*}}}*/
  
      int lcp(int i,
              int j) {  // longest cummon prefix length between s[i:] and s[j:]{{{
          // if (rank[i]<rank[j]) return seg_lcp_array.query(rank[i], rank[j]);
          // else                 return seg_lcp_array.query(rank[j], rank[i]);
          if (rank[i] < rank[j])
              return sparse_lcp_array.get(rank[i], rank[j]);
          else
              return sparse_lcp_array.get(rank[j], rank[i]);
      } /*}}}*/
  };    /*}}}*/
  
  // sample: abc141E
  // int n;cin>>n;
  // string s;cin>>s;
  // suffix_array sa(s);
  //
  // int ans = 0;
  // rep(i, n)rep(j, n){
  //   chmax(ans, min(j-i, sa.lcp(i, j)));
  // }
  // cout << ans << endl;
  


snippet kmp
  // Morris-Pratt
  template <typename T>
  struct KMP {
      int n;
      T pattern;
      vector<int> a;
      KMP() {} /*{{{*/
      KMP(const T& pattern) : pattern(pattern) {
          n = pattern.size();
          a = vector<int>(n + 1);
          a[0] = -1;
          int j = -1;
          for (int i = 0; i < n; ++i) {
              while (j != -1 && pattern[j] != pattern[i]) j = a[j];
              j++;
              a[i + 1] = j;
          }
      } /*}}}*/
      int operator[](int i) { return a[i]; }
      vector<int> findAll(const T& s) { /*{{{*/
          vector<int> res;
          int j = 0;
          for (int i = 0; i < sz(s); ++i) {
              while (j != -1 && pattern[j] != s[i]) j = a[j];
              j++;
              if (j == n) {
                  res.push_back(i - j + 1);
                  j = a[j];
              }
          }
          return res;
      } /*}}}*/
  };
  
  // KMP<vector<int>> kmp({1,2,3});
  // KMP<string> kmp("abc");
  


snippet header
  // snippet:header {{{
  #ifndef HEADER_H
  #define HEADER_H
  
  // template version 2.0
  using namespace std;
  #include <bits/stdc++.h>
  
  // varibable settings
  #define int long long
  const int INF = 1e18;
  
  #define _overload3(_1, _2, _3, name, ...) name
  #define _rep(i, n) repi(i, 0, n)
  #define repi(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)
  #define rep(...) _overload3(__VA_ARGS__, repi, _rep, )(__VA_ARGS__)
  #define _rrep(i, n) rrepi(i, 0, n)
  #define rrepi(i, a, b) for (int i = (int)((b)-1); i >= (int)(a); --i)
  #define r_rep(...) _overload3(__VA_ARGS__, rrepi, _rrep, )(__VA_ARGS__)
  #define each(i, a) for (auto &&i : a)
  #define all(x) (x).begin(), (x).end()
  #define sz(x) ((int)(x).size())
  #define pb(a) push_back(a)
  #define mp(a, b) make_pair(a, b)
  #define mt(...) make_tuple(__VA_ARGS__)
  #define ub upper_bound
  #define lb lower_bound
  #define lpos(A, x) (lower_bound(all(A), x) - A.begin())
  #define upos(A, x) (upper_bound(all(A), x) - A.begin())
  template <class T>
  inline void chmax(T &a, const T &b) {
      if ((a) < (b)) (a) = (b);
  }
  template <class T>
  inline void chmin(T &a, const T &b) {
      if ((a) > (b)) (a) = (b);
  }
  
  #define divceil(a, b) ((a) + (b)-1) / (b)
  #define is_in(x, a, b) ((a) <= (x) && (x) < (b))
  #define uni(x)    \
      sort(all(x)); \
      x.erase(unique(all(x)), x.end())
  #define slice(l, r) substr(l, r - l)
  
  typedef long long ll;
  typedef vector<int> vi;
  typedef vector<vi> vvi;
  typedef long double ld;
  typedef pair<int, int> pii;
  typedef tuple<int, int, int> iii;
  
  template <typename T>
  using PQ = priority_queue<T, vector<T>, greater<T>>;
  struct Fast {
      Fast() {
          std::cin.tie(0);
          ios::sync_with_stdio(false);
      }
  } fast;
  void check_input() {
      assert(cin.eof() == 0);
      int tmp;
      cin >> tmp;
      assert(cin.eof() == 1);
  }
  
  #if defined(PCM) || defined(LOCAL)
  #else
  #define dump(...) ;
  #define dump_1d(...) ;
  #define dump_2d(...) ;
  #define cerrendl ;
  #endif
  
  #endif /* HEADER_H */
  // snippet:header }}}
  


snippet segment_tree
alias rmq
  // snippet:segment_tree {{{
  template <typename T> struct SegmentTree {  // {{{
      private:
          using F = function<T(T, T)>;
          int n;  // 元の配列のサイズ
          int N;  // n以上の最小の2冪
          vector<T> node;
          F merge;
          T identity;
  
      public:
          SegmentTree() {}
          SegmentTree(vector<T> a, F f, T id) : merge(f), identity(id) {
              n = a.size();
              N = 1;
              while (N < n) N *= 2;
              node.resize(2 * N - 1, identity);
              for (int i = 0; i < n; i++) node[i + N - 1] = a[i];
              for (int i = N - 2; i >= 0; i--)
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
          }
          SegmentTree(int n, F f, T id) : SegmentTree(vector<T>(n, id), f, id) {}
  
          T& operator[](int i) { return node[i + N - 1]; }
  
          void update(int i, T val) {
              i += (N - 1);
              node[i] = val;
              while (i > 0) {
                  i = (i - 1) / 2;
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
              }
          }
  
          void add(int i, T val) {
              i += (N - 1);
              node[i] += val;
              while (i > 0) {
                  i = (i - 1) / 2;
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
              }
          }
  
          // query for [l, r)
          T query(int a, int b, int k = 0, int l = 0, int r = -1) {
              if (r < 0) r = N;
              if (r <= a || b <= l) return identity;
              if (a <= l && r <= b) return node[k];
  
              T vl = query(a, b, 2 * k + 1, l, (l + r) / 2);
              T vr = query(a, b, 2 * k + 2, (l + r) / 2, r);
              return merge(vl, vr);
          }
  
          #if defined(PCM) || defined(LOCAL)
          friend ostream& operator<<(ostream& os, SegmentTree<T>& sg) {  //
              os << "[";
              for (int i = 0; i < sg.n; i++) {
                  os << sg[i] << (i == sg.n - 1 ? "]\n" : ", ");
              }
              return os;
          }
          #endif
  };/*}}}*/
  // sample of initialize SegmentTree:
  // -----------------------------------------------
  // auto mymin=[](auto a, auto b){return min(a,b);};
  // SegmentTree<ll> seg(a, mymin, 1e18);
  
  // auto mymax=[](auto a, auto b){return max(a,b);};
  // SegmentTree<ll> seg(a, mymax, -1e18);
  
  // auto add=[](auto a, auto b){return a+b;};
  // SegmentTree<ll> seg(a, add, 0);
  // -----------------------------------------------
  // snippet:segment_tree }}}
  


snippet zipper
  struct zipper {                             /*{{{*/
      unordered_map<long long, int> zip_map;  // [2:0, 3:1, 5:2, 10:3]
      vector<long long> _unzipper;            // [2, 3, 5, 10]
      bool _is_build = false;
  
      zipper(long long inf_value = INF) { /*{{{*/
          _unzipper.push_back(-inf_value);
          _unzipper.push_back(inf_value);
      }                                                        /*}}}*/
      zipper(vector<long long> a, long long inf_value = INF) { /*{{{*/
          int n = sz(a);
          _unzipper = vector<long long>(n);
          rep(i, n) { _unzipper[i] = a[i]; }
          _unzipper.push_back(-inf_value);
          _unzipper.push_back(inf_value);
          build();
      }                              /*}}}*/
      void add_value(long long lv) { /*{{{*/
          _unzipper.push_back(lv);
          _is_build = false;
      }              /*}}}*/
      void build() { /*{{{*/
          uni(_unzipper);
          zip_map.clear();
          rep(i, sz(_unzipper)) { zip_map[_unzipper[i]] = i; }
          _is_build = true;
      }                              /*}}}*/
      int get_zipped(long long lv) { /*{{{*/
          if (!_is_build) assert(false);
          return zip_map[lv];
      }                                               /*}}}*/
      vector<int> get_zipped(vector<long long> lvs) { /*{{{*/
          if (!_is_build) assert(false);
          int n = sz(lvs);
          vector<int> res(n);
          rep(i, n) res[i] = zip_map[lvs[i]];
          return res;
      }                              /*}}}*/
      int operator()(long long lv) { /*{{{*/
          if (!_is_build) assert(false);
          return zip_map[lv];
      }                         /*}}}*/
      long long unzip(int sv) { /*{{{*/
          if (!_is_build) assert(false);
          return _unzipper[sv];
      }                              /*}}}*/
  #if defined(PCM) || defined(LOCAL) /*{{{*/
      friend ostream& operator<<(ostream& os, const zipper& zp) {
          os << endl;
          os << "_is_build: " << zp._is_build << endl;
          os << "zip_map:   " << zp.zip_map << endl;
          return os;
      }
  #endif /*}}}*/
  };     /*}}}*/
  // How to use {{{
  // construct
  // auto z = zipper(x); // x: vector<long long>;
  // auto z = zipper(x, 30*INF);
  
  // auto z = zipper();
  // auto z = zipper();
  // z.add_value(3);
  // z.add_value(5);
  // z.add_value(10);
  // z.add_value(100000000);
  // z.build();
  
  // other method
  // z(x[i]); -> zipped x[i]
  // z.unzip(z(x[i])) -> x[i];
  // z.get_zipped(x) -> zipped x
  // }}}
  


snippet combination
  int mod = 1e9 + 7;
  // int mod = 998244353;
  struct mint {  //{{{
      int x;
      mint(int x = 0) : x((x % mod + mod) % mod) {}
  
      // ?= operator
      mint& operator+=(const mint a) {
          (x += a.x) %= mod;
          return *this;
      }
      mint& operator-=(const mint a) {
          (x += mod - a.x) %= mod;
          return *this;
      }
      mint& operator*=(const mint a) {
          (x *= a.x) %= mod;
          return *this;
      }
      mint& operator/=(const mint& rhs) {
          if (rhs.x == 0) throw runtime_error("mint zero division");
          return *this *= rhs.inv();
      }
  
      mint operator+(const mint a) const {
          mint res(*this);
          return res += a;
      }
      mint operator-(const mint a) const {
          mint res(*this);
          return res -= a;
      }
      mint operator*(const mint a) const {
          mint res(*this);
          return res *= a;
      }
      mint operator/(const mint a) const {
          mint res(*this);
          return res /= a;
      }
  
      mint pow(int n) const {
          mint res(1), x(*this);
          if (n < 0) {
              n = -n;
              x = (*this).inv();
          }
          while (n) {
              if (n & 1) res *= x;
              x *= x;
              n >>= 1;
          }
          return res;
      }
  
      mint inv() const {
          if (x == 0) throw runtime_error("inv does not exist");
          return pow(mod - 2);
      }
      // mint inv()const{
      //     int x,y;
      //     int g=extgcd(v,mod,x,y);
      //     assert(g==1);
      //     if(x<0)x+=mod;
      //     return mint(x);
      // }
  
      bool operator<(const mint& r) const { return x < r.x; }
      bool operator==(const mint& r) const { return x == r.x; }
  };
  istream& operator>>(istream& is, const mint& a) { return is >> a.x; }
  ostream& operator<<(ostream& os, const mint& a) { return os << a.x; }
  //}}}
  
  struct combination {  // {{{
      vector<mint> fact, ifact;
      combination(int n) : fact(n + 1), ifact(n + 1) {
          assert(n < mod);
          fact[0] = 1;
          for (int i = 1; i <= n; ++i) fact[i] = fact[i - 1] * i;
          ifact[n] = fact[n].inv();
          for (int i = n; i >= 1; --i) ifact[i - 1] = ifact[i] * i;
      }
      mint operator()(int n, int k) {
          if (k < 0 || k > n) return 0;
          return fact[n] * ifact[k] * ifact[n - k];
      }
  }  // }}}
  com(500001);
  


snippet mint
  int mod = 1e9 + 7;
  // int mod = 998244353;
  struct mint {  //{{{
      int x;
      mint(int x = 0) : x((x % mod + mod) % mod) {}
  
      // ?= operator
      mint& operator+=(const mint a) {
          (x += a.x) %= mod;
          return *this;
      }
      mint& operator-=(const mint a) {
          (x += mod - a.x) %= mod;
          return *this;
      }
      mint& operator*=(const mint a) {
          (x *= a.x) %= mod;
          return *this;
      }
      mint& operator/=(const mint& rhs) {
          if (rhs.x == 0) throw runtime_error("mint zero division");
          return *this *= rhs.inv();
      }
  
      mint operator+(const mint a) const {
          mint res(*this);
          return res += a;
      }
      mint operator-(const mint a) const {
          mint res(*this);
          return res -= a;
      }
      mint operator*(const mint a) const {
          mint res(*this);
          return res *= a;
      }
      mint operator/(const mint a) const {
          mint res(*this);
          return res /= a;
      }
  
      mint pow(int n) const {
          mint res(1), x(*this);
          if (n < 0) {
              n = -n;
              x = (*this).inv();
          }
          while (n) {
              if (n & 1) res *= x;
              x *= x;
              n >>= 1;
          }
          return res;
      }
  
      mint inv() const {
          if (x == 0) throw runtime_error("inv does not exist");
          return pow(mod - 2);
      }
      // mint inv()const{
      //     int x,y;
      //     int g=extgcd(v,mod,x,y);
      //     assert(g==1);
      //     if(x<0)x+=mod;
      //     return mint(x);
      // }
  
      bool operator<(const mint& r) const { return x < r.x; }
      bool operator==(const mint& r) const { return x == r.x; }
  };
  istream& operator>>(istream& is, const mint& a) { return is >> a.x; }
  ostream& operator<<(ostream& os, const mint& a) { return os << a.x; }
  //}}}
  


snippet P2
alias pair
  template<class T>/*{{{*/
  struct P2 {
      T x, y;
      P2(T _x, T _y) : x(_x), y(_y) {}
      P2() {
          x = 0;
          y = 0;
      }
      bool operator<(const P2 &r) const {
          return (x != r.x ? x < r.x : y < r.y);
      }
      bool operator>(const P2 &r) const {
          return (x != r.x ? x > r.x : y > r.y);
      }
      bool operator==(const P2 &r) const { return (x == r.x && y == r.y); }
  
      friend ostream &operator<<(ostream &stream, P2 p) {
          stream << "(" << p.x << "," << p.y << ")";
          return stream;
      }
  
      P2 operator-() const {  // 単項演算子
          return P2(-x, -y);
      }
  
      P2& operator+=(const P2& r){
          x += r.x;
          y += r.y;
          return *this;
      }
      P2& operator-=(const P2& r){
          x -= r.x;
          y -= r.y;
          return *this;
      }
  
      P2 operator+(const P2& r) const {
          P2 res(*this);
          return res += r;
      }
      P2 operator-(const P2& r) const {
          P2 res(*this);
          return res -= r;
      }
  
      template<class U=ll>
      P2 operator*(U v) const {
          P2 res(*this);
          res.x *= v;
          res.y *= v;
          return res;
      }
      template<class U=ll>
      P2 operator/(U v) const {
          P2 res(*this);
          res.x /= v;
          res.y /= v;
          return res;
      }
  
      bool in(T a, T b, T c, T d) {  // x in [a, b) && y in [c, d)
          if (a <= x && x < b && c <= y && y < d)
              return true;
          else
              return false;
      }
  
  };/*}}}*/
  


snippet topological_sort
alias tps
  // snippet:topological_sort {{{
  using Pos = int;
  tuple<bool, vector<Pos>, int> topological_sort(const Graph<>& g) {
      vector<Pos> res;  // sort後の結果を格納
      vector<int> h(g.n);  // 頂点ごとの入次数
      stack<Pos> st;    // 入次数が0になっている頂点の集合
      int max_len = 0;   // 最長経路の長さ
  
      // 入次数を計算する。
      rep(u, g.n) {
          for (const auto& edge : g[u]) {
              h[edge.to]++;
          }
      }
  
      // 最初に入次数0になっている頂点を集める。
      rep(u, g.n) {
          if (h[u] == 0) {
              st.push(u);
              res.push_back(u);
          }
      }
  
      // 入次数0の頂点をresに追加しそこから出て行く辺は削除していく。O(g.n+E)
      while (!st.empty()) {
          stack<Pos> nex_st;
          while (!st.empty()) {
              Pos u = st.top(); st.pop();
              for (const auto& edge : g[u]) {
                  h[edge.to]--;
                  if (h[edge.to] == 0) {
                      res.push_back(edge.to);
                      nex_st.push(edge.to);
                  }
              }
          }
          max_len++;
          st = nex_st;
      }
      
      bool is_valid = (sz(res)==g.n ? true : false);
      return {is_valid, res, max_len};  // res.size()<g.nなら閉路がありDAGではない。閉路内の頂点はstに入り得ないので。
  }
  // snippet:topological_sort }}}
  


snippet StronglyConnectedComponents
alias scc
  // snippet:segment_tree {{{
  template <typename T> struct SegmentTree {  // {{{
      private:
          using F = function<T(T, T)>;
          int n;  // 元の配列のサイズ
          int N;  // n以上の最小の2冪
          vector<T> node;
          F merge;
          T identity;
  
      public:
          SegmentTree() {}
          SegmentTree(vector<T> a, F f, T id) : merge(f), identity(id) {
              n = a.size();
              N = 1;
              while (N < n) N *= 2;
              node.resize(2 * N - 1, identity);
              for (int i = 0; i < n; i++) node[i + N - 1] = a[i];
              for (int i = N - 2; i >= 0; i--)
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
          }
          SegmentTree(int n, F f, T id) : SegmentTree(vector<T>(n, id), f, id) {}
  
          T& operator[](int i) { return node[i + N - 1]; }
  
          void update(int i, T val) {
              i += (N - 1);
              node[i] = val;
              while (i > 0) {
                  i = (i - 1) / 2;
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
              }
          }
  
          void add(int i, T val) {
              i += (N - 1);
              node[i] += val;
              while (i > 0) {
                  i = (i - 1) / 2;
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
              }
          }
  
          // query for [l, r)
          T query(int a, int b, int k = 0, int l = 0, int r = -1) {
              if (r < 0) r = N;
              if (r <= a || b <= l) return identity;
              if (a <= l && r <= b) return node[k];
  
              T vl = query(a, b, 2 * k + 1, l, (l + r) / 2);
              T vr = query(a, b, 2 * k + 2, (l + r) / 2, r);
              return merge(vl, vr);
          }
  
          #if defined(PCM) || defined(LOCAL)
          friend ostream& operator<<(ostream& os, SegmentTree<T>& sg) {  //
              os << "[";
              for (int i = 0; i < sg.n; i++) {
                  os << sg[i] << (i == sg.n - 1 ? "]\n" : ", ");
              }
              return os;
          }
          #endif
  };/*}}}*/
  // sample of initialize SegmentTree:
  // -----------------------------------------------
  // auto mymin=[](auto a, auto b){return min(a,b);};
  // SegmentTree<ll> seg(a, mymin, 1e18);
  
  // auto mymax=[](auto a, auto b){return max(a,b);};
  // SegmentTree<ll> seg(a, mymax, -1e18);
  
  // auto add=[](auto a, auto b){return a+b;};
  // SegmentTree<ll> seg(a, add, 0);
  // -----------------------------------------------
  // snippet:segment_tree }}}
  
  // snippet:UnionFind {{{
  struct UnionFind {
      vector<int> data;  // size defined only for root node
      int count;         // count of groups
  
      UnionFind() {}
      UnionFind(int size) : data(size, -1), count(size) {}
      bool merge(int x, int y) { /*{{{*/
          x = root(x);
          y = root(y);
          if (x != y) {
              if (data[y] < data[x]) swap(x, y);
              data[x] += data[y];
              data[y] = x;
              count--;
          }
          return x != y;
      } /*}}}*/
      int root(int x) { return (data[x] < 0 ? x : data[x] = root(data[x])); }
      bool same(int x, int y) { return root(x) == root(y); }
      int size(int x) { return -data[root(x)]; }
  
  #if defined(PCM) || defined(LOCAL)  // {{{
      friend ostream& operator<<(ostream& os, UnionFind& uf) {
          map<int, vector<int>> group;
          rep(i, sz(uf.data)) { group[uf.root(i)].pb(i); }
          os << endl;
          each(g, group) { os << g << endl; }
          return os;
      }
  #endif  // }}}
  };
  // snippet:UnionFind }}}
  
  // snippet:tree {{{
  template<class Cost=ll>
  struct tree { 
      int n;
      vector<int> par;   // par[i]: dfs木における親
      vector<Cost> cost;  // par[i]: dfs木における親への辺のコスト
      vector<int> dfstrv;  // dfstrv[i]: dfs木でi番目に訪れるノード。dpはこれを逆順に回す
      vector<int> ord;    // ord[u]: uのdfs木における訪問順
      vector<int> end;    // end[u]: uのdfs終了時のカウンター
      vector<int> psize;  // psize[u]: uのpartial tree size
      // uの部分木は[ord[u], end[u])
      // ordとdfstrvは逆変換
      vector<int> depth;   // depth[i]: dfs木でのiの深さ
      vector<Cost> ldepth;  //  ldepth[i]: dfs木でのrootからの距離
      vector<vector<pair<int, Cost>>> g;  // 辺(隣接リスト)
      vector<vector<int>> adj;           // 辺(隣接リスト)
      vector<vector<int>> children;
      vector<int> euler_tour;
      vector<int> et_fpos;    // euler_tour first occurence position
      SegmentTree<int> _seg;  // seg(map(ord, euler_tour), mymin, 1e18)
      vector<int> head_of_comp;
      int _counter = 0;
  
      tree(){};/*{{{*/
      tree(int n)
          : n(n),
            par(n),
            cost(n),
            ord(n),
            end(n),
            psize(n),
            depth(n),
            ldepth(n),
            g(n),
            adj(n),
            children(n),
            et_fpos(n),
            head_of_comp(n){};/*}}}*/
      void add_edge(int u, int v, Cost cost) { /*{{{*/
          g[u].emplace_back(v, cost);
          g[v].emplace_back(u, cost);
          adj[u].emplace_back(v);
          adj[v].emplace_back(u);
      }                             /*}}}*/
      void add_edge(int u, int v) { /*{{{*/
          g[u].emplace_back(v, 1);
          g[v].emplace_back(u, 1);
          adj[u].emplace_back(v);
          adj[v].emplace_back(u);
      }                      /*}}}*/
      void build(int root) { /*{{{*/
          _counter = 0;
          // par[root] = -1;
          // cost[root] = -1;
          _dfs_psize(root, -1);
          _dfs_tree(root, -1, root);
          _dfs_et(root);
          vector<int> ini(2 * n - 1);
          rep(i, 2 * n - 1) ini[i] = ord[euler_tour[i]];
          _seg = SegmentTree<int>(
              ini, [](auto a, auto b) { return min(a, b); }, 1e18);
      }                                /*}}}*/
      int _dfs_psize(int u, int pre) { /*{{{*/
          psize[u] = 1;
          each(el, g[u]) {
              int v = el.first;
              if (v == pre) continue;
              psize[u] += _dfs_psize(v, u);
          }
          return psize[u];
      }                                               /*}}}*/
      void _dfs_tree(int u, int pre, int head_node) { /*{{{*/
          dfstrv.pb(u);
          ord[u] = _counter;
          if (pre != -1) {
              depth[u] = depth[pre] + 1;
              ldepth[u] = ldepth[pre] + cost[u];
          }
  
          _counter++;
          {
              // set most heavy child to top
              int max_psize = 0;
              int most_heavy_i = -1;
              rep(i, sz(g[u])) {
                  if (g[u][i].first == pre) continue;
                  if (psize[g[u][i].first] > max_psize) {
                      most_heavy_i = i;
                      max_psize = psize[g[u][i].first];
                  }
              }
              if (most_heavy_i != -1) swap(g[u][most_heavy_i], g[u][0]);
          }
  
          head_of_comp[u] = head_node;
          rep(i, sz(g[u])) {
              int v = g[u][i].first;
              if (v == pre) continue;
  
              children[u].pb(v);
              par[v] = u;
              cost[v] = g[u][i].second;
  
              if (i == 0)
                  _dfs_tree(v, u, head_node);  // continue components
              else
                  _dfs_tree(v, u, v);  // new
          }
          end[u] = _counter;
      }                     /*}}}*/
      void _dfs_et(int u) { /*{{{*/
          et_fpos[u] = euler_tour.size();
          euler_tour.pb(u);
          each(v, children[u]) {
              _dfs_et(v);
              euler_tour.pb(u);
          }
      }                       /*}}}*/
      int lca(int u, int v) { /*{{{*/
          if (u == v) return u;
          if (et_fpos[u] > et_fpos[v]) swap(u, v);
          return dfstrv[_seg.query(et_fpos[u], et_fpos[v])];
      }                        /*}}}*/
      int dist(int u, int v) { /*{{{*/
          int p = lca(u, v);
          return depth[u] + depth[v] - 2 * depth[p];
      }                          /*}}}*/
      Cost ldist(int u, int v) {  // length dist{{{
          int p = lca(u, v);
          return ldepth[u] + ldepth[v] - 2 * ldepth[p];
      }                           /*}}}*/
      pair<int, int> diameter() { /*{{{*/
          int u, v;
          Cost max_len = *max_element(all(ldepth));
          rep(i, n) {
              if (ldepth[i] == max_len) {
                  u = i;
                  break;
              }
          }
          Cost md = -1;
          rep(i, n) {
              Cost d = ldist(u, i);
              if (d > md) {
                  v = i;
                  md = d;
              }
          }
          return mp(u, v);
      }                                                /*}}}*/
      vector<pair<int, int>> hld_path(int u, int v) {  //{{{
          // 閉区間をvectorで返す
          vector<pair<int, int>> res;
          while (head_of_comp[u] != head_of_comp[v]) {
              if (depth[head_of_comp[u]] < depth[head_of_comp[v]]) {
                  res.push_back({ord[head_of_comp[v]], ord[v]});
                  v = par[head_of_comp[v]];
              } else {
                  res.push_back({ord[head_of_comp[u]], ord[u]});
                  u = par[head_of_comp[u]];
              }
          }
          res.push_back({min(ord[u], ord[v]), max(ord[u], ord[v])});
          return res;
      }                              //}}}
  #if defined(PCM) || defined(LOCAL) /*{{{*/
      friend ostream& operator<<(ostream& os, const tree& tr) {
          os << endl;
          os << "par:         " << tr.par << endl;
          os << "cost:        " << tr.cost << endl;
          os << "dfstrv:      " << tr.dfstrv << endl;
          os << "ord:         " << tr.ord << endl;
          os << "end:         " << tr.end << endl;
          os << "depth:       " << tr.depth << endl;
          os << "children:    " << tr.children << endl;
          os << "euler_tour:  " << tr.euler_tour << endl;
          os << "et_fpos:     " << tr.et_fpos << endl;
          os << "head_of_comp:" << tr.head_of_comp << endl;
          return os;
      }
  #endif /*}}}*/
  }; 
  // snippet:tree }}}
  
  // snippet:Graph {{{
  template<class Cost=ll>
  struct Graph {
      using Pos = int;  // int以外には対応しない。
      struct Edge {/*{{{*/
          Pos from, to;
          Cost cost;
          int idx;
          Edge(){};
          Edge(Pos from, Pos to, Cost cost, int idx)
              : from(from), to(to), cost(cost), idx(idx) {}
          friend ostream& operator<<(ostream& os, const Edge& e) {
              // os << "(f:" << e.from << ", t:" << e.to << ", c:" << e.cost << ", i" << e.idx << ")";  // detailed
              os << "(" << e.from << "," << e.to << ")";
              return os;
          }
      };/*}}}*/
  
      int n;  // 頂点数
      vector<vector<Edge>> adj_list;
      auto operator[](Pos pos) const { return adj_list[pos]; }
      vector<Edge> edges;
      tree<Cost> tr;
      Pos root;
      vector<int> _used_in_dfs;
      vector<int> lowlink;
      Cost zerocost;
      Cost infcost;
  
      Graph() {}
      Graph(int _n) : n(_n), adj_list(_n), tr(n), _used_in_dfs(n), zerocost(0LL), infcost(INF) { }
      Graph(int _n, Cost zc, Cost ic) : n(_n), adj_list(_n), tr(n), _used_in_dfs(n), zerocost(zc), infcost(ic) { }
  
      void add_edge(Pos from, Pos to, Cost cost, int idx=-1) {/*{{{*/
          adj_list[from].emplace_back(from, to, cost, idx);
          edges.emplace_back(from, to, cost, idx);
      }
      void add_edge(Pos from, Pos to) {  // for ll
          adj_list[from].emplace_back(from, to, 1, -1);
          edges.emplace_back(from, to, 1, -1);
      }/*}}}*/
  
      void build_tree(Pos _root) {/*{{{*/
          root = _root;
          _dfs_tree(root);
          tr.build(root);
          _make_lowlink();
      }/*}}}*/
  
      vector<int> make_bipartite() {/*{{{*/
          UnionFind buf(2 * n);
          rep(u, n) {
              each(e, adj_list[u]) {
                  buf.merge(u, e.to + n);
                  buf.merge(e.to, u + n);
              }
          }
  
          vector<int> res(n, -1);
          rep(u, n) {
              if (buf.same(u, u + n)) return res;
          }
          rep(u, n) {
              if (buf.same(0, u)) res[u] = 0;
              else res[u] = 1;
          }
          return res;
      }/*}}}*/
  
      void _dfs_tree(Pos u) {/*{{{*/
          _used_in_dfs[u] = 1;
          each(e, adj_list[u]) {
              if (_used_in_dfs[e.to]) continue;
              tr.add_edge(u, e.to, e.cost);
              _dfs_tree(e.to);
          }
      }/*}}}*/
  
      void _make_lowlink() {/*{{{*/
          lowlink = vector<Pos>(n, INF);
          r_rep(i, n) {
              Pos u = tr.dfstrv[i];
              chmin(lowlink[u], tr.ord[u]);
  
              each(e, adj_list[u]) {
                  if (e.to == tr.par[u])
                      continue;
                  else if (tr.ord[e.to] < tr.ord[u]) {
                      chmin(lowlink[u], tr.ord[e.to]);
                  } else {
                      chmin(lowlink[u], lowlink[e.to]);
                  }
              }
          }
      }/*}}}*/
  
      vector<Pos> get_articulation_points() {/*{{{*/
          if (sz(lowlink) == 0) throw("make_lowlik() beforehand");
  
          vector<Pos> res;
          if (sz(tr.children[root]) > 1) {
              res.push_back(root);
          }
          rep(u, 0, n) {
              if (u == root) continue;
              bool is_kan = false;
              each(v, tr.children[u]) {
                  if (tr.ord[u] <= lowlink[v]) {
                      is_kan = true;
                  }
              }
              if (is_kan) res.push_back(u);
          }
          return res;
      }/*}}}*/
  
      vector<Edge> get_bridges() {/*{{{*/
          if (sz(lowlink) == 0) throw("make_lowlik() beforehand");
          vector<Edge> res;
          each(edge, edges){
              if (tr.ord[edge.from] < lowlink[edge.to]) res.push_back(edge);
          }
          return res;
      }/*}}}*/
  
      vector<Edge> kruskal_tree() {/*{{{*/
          // 使用される辺のvectorを返す
          vector<Edge> res(n - 1);
          sort(all(edges), [&](auto l, auto r) { return l.cost < r.cost; });
          UnionFind uf(n);
  
          Cost total_cost = zerocost;
          int idx = 0;
          each(e, edges) {
              if (uf.same(e.from, e.to)) continue;
              uf.merge(e.from, e.to);
              total_cost = total_cost + e.cost;
              res[idx] = e;
              idx++;
          }
          assert(idx == n - 1);
  
          return res;
      }/*}}}*/
  
      vector<Cost> dijkstra(vector<Pos> starts) {  // 多点スタート{{{
          vector<Cost> dist(n, infcost);           // 最短距離
          PQ<pair<Cost, Pos>> pq;
          each(start, starts) {
              dist[start] = zerocost;
              pq.push(make_pair(zerocost, start));
          }
          while (!pq.empty()) {
              auto cp = pq.top();
              pq.pop();
              auto [cost, u] = cp;
              for (const auto& edge : adj_list[u]) {
                  Cost new_cost = cost + edge.cost;  // TODO: 問題によってはここが変更の必要あり
                  if (new_cost < dist[edge.to]) {
                      dist[edge.to] = new_cost;
                      pq.push(make_pair(new_cost, edge.to));
                  }
              }
          }
          return dist;
      };/*}}}*/
  
      vector<Cost> dijkstra(Pos start) {  // 1点スタート{{{
          vector<Pos> starts = {start};
          return dijkstra(starts);
      };/*}}}*/
  };
  // snippet:Graph }}}
  
  // snippet:StronglyConnectedComponents {{{
  struct StronglyConnectedComponents {
      const Graph<> &g;  //{{{
      vector<int> comp;  // comp[i]: iが属する強連結成分が何番目の成分か
      Graph<> dag;  // 縮約されたDAG graph. sizeをとれば強連結成分の個数が分かる。
      Graph<> _rg;  // reversed graph
      vector<int> _order;  // order[i]: 帰りがけ順
      vector<int> _used;
  
      StronglyConnectedComponents(Graph<> &_g)
          : g(_g), comp(_g.n, -1), _rg(_g.n), _used(_g.n) {
          for (int i = 0; i < g.n; i++) {
              for (auto e : g[i]) {
                  _rg.add_edge(e.to, e.from, e.cost, e.idx);
              }
          }
      }
  
      int operator[](int k) { return comp[k]; }
  
      void build() {
          for (int i = 0; i < g.n; i++) _dfs(i);
          reverse(begin(_order), end(_order));
          int cnt = 0;
          for (int u : _order)
              if (comp[u] == -1) _rdfs(u, cnt), cnt++;
  
          dag = Graph(cnt);
          for (int u = 0; u < g.n; u++) {
              for (auto &e : g[u]) {
                  if (comp[u] == comp[e.to]) continue;
                  dag.add_edge(comp[u], comp[e.to]);
              }
          }
      }
  
      void _dfs(int idx) {
          if (_used[idx]) return;
          _used[idx] = true;
          for (auto &e : g[idx]) _dfs(e.to);
          _order.push_back(idx);
      }
  
      void _rdfs(int idx, int cnt) {
          if (comp[idx] != -1) return;
          comp[idx] = cnt;
          for (auto e : _rg[idx]) _rdfs(e.to, cnt);
      }  //}}}
  };
  // how to use
  // StronglyConnectedComponents scc(g); // g: Graph
  // scc.build();
  // dump(scc.comp, scc.dag);
  // snippet:StronglyConnectedComponents }}}
  


snippet UnionFind
  // snippet:UnionFind {{{
  struct UnionFind {
      vector<int> data;  // size defined only for root node
      int count;         // count of groups
  
      UnionFind() {}
      UnionFind(int size) : data(size, -1), count(size) {}
      bool merge(int x, int y) { /*{{{*/
          x = root(x);
          y = root(y);
          if (x != y) {
              if (data[y] < data[x]) swap(x, y);
              data[x] += data[y];
              data[y] = x;
              count--;
          }
          return x != y;
      } /*}}}*/
      int root(int x) { return (data[x] < 0 ? x : data[x] = root(data[x])); }
      bool same(int x, int y) { return root(x) == root(y); }
      int size(int x) { return -data[root(x)]; }
  
  #if defined(PCM) || defined(LOCAL)  // {{{
      friend ostream& operator<<(ostream& os, UnionFind& uf) {
          map<int, vector<int>> group;
          rep(i, sz(uf.data)) { group[uf.root(i)].pb(i); }
          os << endl;
          each(g, group) { os << g << endl; }
          return os;
      }
  #endif  // }}}
  };
  // snippet:UnionFind }}}
  


snippet Graph
  // snippet:segment_tree {{{
  template <typename T> struct SegmentTree {  // {{{
      private:
          using F = function<T(T, T)>;
          int n;  // 元の配列のサイズ
          int N;  // n以上の最小の2冪
          vector<T> node;
          F merge;
          T identity;
  
      public:
          SegmentTree() {}
          SegmentTree(vector<T> a, F f, T id) : merge(f), identity(id) {
              n = a.size();
              N = 1;
              while (N < n) N *= 2;
              node.resize(2 * N - 1, identity);
              for (int i = 0; i < n; i++) node[i + N - 1] = a[i];
              for (int i = N - 2; i >= 0; i--)
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
          }
          SegmentTree(int n, F f, T id) : SegmentTree(vector<T>(n, id), f, id) {}
  
          T& operator[](int i) { return node[i + N - 1]; }
  
          void update(int i, T val) {
              i += (N - 1);
              node[i] = val;
              while (i > 0) {
                  i = (i - 1) / 2;
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
              }
          }
  
          void add(int i, T val) {
              i += (N - 1);
              node[i] += val;
              while (i > 0) {
                  i = (i - 1) / 2;
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
              }
          }
  
          // query for [l, r)
          T query(int a, int b, int k = 0, int l = 0, int r = -1) {
              if (r < 0) r = N;
              if (r <= a || b <= l) return identity;
              if (a <= l && r <= b) return node[k];
  
              T vl = query(a, b, 2 * k + 1, l, (l + r) / 2);
              T vr = query(a, b, 2 * k + 2, (l + r) / 2, r);
              return merge(vl, vr);
          }
  
          #if defined(PCM) || defined(LOCAL)
          friend ostream& operator<<(ostream& os, SegmentTree<T>& sg) {  //
              os << "[";
              for (int i = 0; i < sg.n; i++) {
                  os << sg[i] << (i == sg.n - 1 ? "]\n" : ", ");
              }
              return os;
          }
          #endif
  };/*}}}*/
  // sample of initialize SegmentTree:
  // -----------------------------------------------
  // auto mymin=[](auto a, auto b){return min(a,b);};
  // SegmentTree<ll> seg(a, mymin, 1e18);
  
  // auto mymax=[](auto a, auto b){return max(a,b);};
  // SegmentTree<ll> seg(a, mymax, -1e18);
  
  // auto add=[](auto a, auto b){return a+b;};
  // SegmentTree<ll> seg(a, add, 0);
  // -----------------------------------------------
  // snippet:segment_tree }}}
  
  // snippet:UnionFind {{{
  struct UnionFind {
      vector<int> data;  // size defined only for root node
      int count;         // count of groups
  
      UnionFind() {}
      UnionFind(int size) : data(size, -1), count(size) {}
      bool merge(int x, int y) { /*{{{*/
          x = root(x);
          y = root(y);
          if (x != y) {
              if (data[y] < data[x]) swap(x, y);
              data[x] += data[y];
              data[y] = x;
              count--;
          }
          return x != y;
      } /*}}}*/
      int root(int x) { return (data[x] < 0 ? x : data[x] = root(data[x])); }
      bool same(int x, int y) { return root(x) == root(y); }
      int size(int x) { return -data[root(x)]; }
  
  #if defined(PCM) || defined(LOCAL)  // {{{
      friend ostream& operator<<(ostream& os, UnionFind& uf) {
          map<int, vector<int>> group;
          rep(i, sz(uf.data)) { group[uf.root(i)].pb(i); }
          os << endl;
          each(g, group) { os << g << endl; }
          return os;
      }
  #endif  // }}}
  };
  // snippet:UnionFind }}}
  
  // snippet:tree {{{
  template<class Cost=ll>
  struct tree { 
      int n;
      vector<int> par;   // par[i]: dfs木における親
      vector<Cost> cost;  // par[i]: dfs木における親への辺のコスト
      vector<int> dfstrv;  // dfstrv[i]: dfs木でi番目に訪れるノード。dpはこれを逆順に回す
      vector<int> ord;    // ord[u]: uのdfs木における訪問順
      vector<int> end;    // end[u]: uのdfs終了時のカウンター
      vector<int> psize;  // psize[u]: uのpartial tree size
      // uの部分木は[ord[u], end[u])
      // ordとdfstrvは逆変換
      vector<int> depth;   // depth[i]: dfs木でのiの深さ
      vector<Cost> ldepth;  //  ldepth[i]: dfs木でのrootからの距離
      vector<vector<pair<int, Cost>>> g;  // 辺(隣接リスト)
      vector<vector<int>> adj;           // 辺(隣接リスト)
      vector<vector<int>> children;
      vector<int> euler_tour;
      vector<int> et_fpos;    // euler_tour first occurence position
      SegmentTree<int> _seg;  // seg(map(ord, euler_tour), mymin, 1e18)
      vector<int> head_of_comp;
      int _counter = 0;
  
      tree(){};/*{{{*/
      tree(int n)
          : n(n),
            par(n),
            cost(n),
            ord(n),
            end(n),
            psize(n),
            depth(n),
            ldepth(n),
            g(n),
            adj(n),
            children(n),
            et_fpos(n),
            head_of_comp(n){};/*}}}*/
      void add_edge(int u, int v, Cost cost) { /*{{{*/
          g[u].emplace_back(v, cost);
          g[v].emplace_back(u, cost);
          adj[u].emplace_back(v);
          adj[v].emplace_back(u);
      }                             /*}}}*/
      void add_edge(int u, int v) { /*{{{*/
          g[u].emplace_back(v, 1);
          g[v].emplace_back(u, 1);
          adj[u].emplace_back(v);
          adj[v].emplace_back(u);
      }                      /*}}}*/
      void build(int root) { /*{{{*/
          _counter = 0;
          // par[root] = -1;
          // cost[root] = -1;
          _dfs_psize(root, -1);
          _dfs_tree(root, -1, root);
          _dfs_et(root);
          vector<int> ini(2 * n - 1);
          rep(i, 2 * n - 1) ini[i] = ord[euler_tour[i]];
          _seg = SegmentTree<int>(
              ini, [](auto a, auto b) { return min(a, b); }, 1e18);
      }                                /*}}}*/
      int _dfs_psize(int u, int pre) { /*{{{*/
          psize[u] = 1;
          each(el, g[u]) {
              int v = el.first;
              if (v == pre) continue;
              psize[u] += _dfs_psize(v, u);
          }
          return psize[u];
      }                                               /*}}}*/
      void _dfs_tree(int u, int pre, int head_node) { /*{{{*/
          dfstrv.pb(u);
          ord[u] = _counter;
          if (pre != -1) {
              depth[u] = depth[pre] + 1;
              ldepth[u] = ldepth[pre] + cost[u];
          }
  
          _counter++;
          {
              // set most heavy child to top
              int max_psize = 0;
              int most_heavy_i = -1;
              rep(i, sz(g[u])) {
                  if (g[u][i].first == pre) continue;
                  if (psize[g[u][i].first] > max_psize) {
                      most_heavy_i = i;
                      max_psize = psize[g[u][i].first];
                  }
              }
              if (most_heavy_i != -1) swap(g[u][most_heavy_i], g[u][0]);
          }
  
          head_of_comp[u] = head_node;
          rep(i, sz(g[u])) {
              int v = g[u][i].first;
              if (v == pre) continue;
  
              children[u].pb(v);
              par[v] = u;
              cost[v] = g[u][i].second;
  
              if (i == 0)
                  _dfs_tree(v, u, head_node);  // continue components
              else
                  _dfs_tree(v, u, v);  // new
          }
          end[u] = _counter;
      }                     /*}}}*/
      void _dfs_et(int u) { /*{{{*/
          et_fpos[u] = euler_tour.size();
          euler_tour.pb(u);
          each(v, children[u]) {
              _dfs_et(v);
              euler_tour.pb(u);
          }
      }                       /*}}}*/
      int lca(int u, int v) { /*{{{*/
          if (u == v) return u;
          if (et_fpos[u] > et_fpos[v]) swap(u, v);
          return dfstrv[_seg.query(et_fpos[u], et_fpos[v])];
      }                        /*}}}*/
      int dist(int u, int v) { /*{{{*/
          int p = lca(u, v);
          return depth[u] + depth[v] - 2 * depth[p];
      }                          /*}}}*/
      Cost ldist(int u, int v) {  // length dist{{{
          int p = lca(u, v);
          return ldepth[u] + ldepth[v] - 2 * ldepth[p];
      }                           /*}}}*/
      pair<int, int> diameter() { /*{{{*/
          int u, v;
          Cost max_len = *max_element(all(ldepth));
          rep(i, n) {
              if (ldepth[i] == max_len) {
                  u = i;
                  break;
              }
          }
          Cost md = -1;
          rep(i, n) {
              Cost d = ldist(u, i);
              if (d > md) {
                  v = i;
                  md = d;
              }
          }
          return mp(u, v);
      }                                                /*}}}*/
      vector<pair<int, int>> hld_path(int u, int v) {  //{{{
          // 閉区間をvectorで返す
          vector<pair<int, int>> res;
          while (head_of_comp[u] != head_of_comp[v]) {
              if (depth[head_of_comp[u]] < depth[head_of_comp[v]]) {
                  res.push_back({ord[head_of_comp[v]], ord[v]});
                  v = par[head_of_comp[v]];
              } else {
                  res.push_back({ord[head_of_comp[u]], ord[u]});
                  u = par[head_of_comp[u]];
              }
          }
          res.push_back({min(ord[u], ord[v]), max(ord[u], ord[v])});
          return res;
      }                              //}}}
  #if defined(PCM) || defined(LOCAL) /*{{{*/
      friend ostream& operator<<(ostream& os, const tree& tr) {
          os << endl;
          os << "par:         " << tr.par << endl;
          os << "cost:        " << tr.cost << endl;
          os << "dfstrv:      " << tr.dfstrv << endl;
          os << "ord:         " << tr.ord << endl;
          os << "end:         " << tr.end << endl;
          os << "depth:       " << tr.depth << endl;
          os << "children:    " << tr.children << endl;
          os << "euler_tour:  " << tr.euler_tour << endl;
          os << "et_fpos:     " << tr.et_fpos << endl;
          os << "head_of_comp:" << tr.head_of_comp << endl;
          return os;
      }
  #endif /*}}}*/
  }; 
  // snippet:tree }}}
  
  // snippet:Graph {{{
  template<class Cost=ll>
  struct Graph {
      using Pos = int;  // int以外には対応しない。
      struct Edge {/*{{{*/
          Pos from, to;
          Cost cost;
          int idx;
          Edge(){};
          Edge(Pos from, Pos to, Cost cost, int idx)
              : from(from), to(to), cost(cost), idx(idx) {}
          friend ostream& operator<<(ostream& os, const Edge& e) {
              // os << "(f:" << e.from << ", t:" << e.to << ", c:" << e.cost << ", i" << e.idx << ")";  // detailed
              os << "(" << e.from << "," << e.to << ")";
              return os;
          }
      };/*}}}*/
  
      int n;  // 頂点数
      vector<vector<Edge>> adj_list;
      auto operator[](Pos pos) const { return adj_list[pos]; }
      vector<Edge> edges;
      tree<Cost> tr;
      Pos root;
      vector<int> _used_in_dfs;
      vector<int> lowlink;
      Cost zerocost;
      Cost infcost;
  
      Graph() {}
      Graph(int _n) : n(_n), adj_list(_n), tr(n), _used_in_dfs(n), zerocost(0LL), infcost(INF) { }
      Graph(int _n, Cost zc, Cost ic) : n(_n), adj_list(_n), tr(n), _used_in_dfs(n), zerocost(zc), infcost(ic) { }
  
      void add_edge(Pos from, Pos to, Cost cost, int idx=-1) {/*{{{*/
          adj_list[from].emplace_back(from, to, cost, idx);
          edges.emplace_back(from, to, cost, idx);
      }
      void add_edge(Pos from, Pos to) {  // for ll
          adj_list[from].emplace_back(from, to, 1, -1);
          edges.emplace_back(from, to, 1, -1);
      }/*}}}*/
  
      void build_tree(Pos _root) {/*{{{*/
          root = _root;
          _dfs_tree(root);
          tr.build(root);
          _make_lowlink();
      }/*}}}*/
  
      vector<int> make_bipartite() {/*{{{*/
          UnionFind buf(2 * n);
          rep(u, n) {
              each(e, adj_list[u]) {
                  buf.merge(u, e.to + n);
                  buf.merge(e.to, u + n);
              }
          }
  
          vector<int> res(n, -1);
          rep(u, n) {
              if (buf.same(u, u + n)) return res;
          }
          rep(u, n) {
              if (buf.same(0, u)) res[u] = 0;
              else res[u] = 1;
          }
          return res;
      }/*}}}*/
  
      void _dfs_tree(Pos u) {/*{{{*/
          _used_in_dfs[u] = 1;
          each(e, adj_list[u]) {
              if (_used_in_dfs[e.to]) continue;
              tr.add_edge(u, e.to, e.cost);
              _dfs_tree(e.to);
          }
      }/*}}}*/
  
      void _make_lowlink() {/*{{{*/
          lowlink = vector<Pos>(n, INF);
          r_rep(i, n) {
              Pos u = tr.dfstrv[i];
              chmin(lowlink[u], tr.ord[u]);
  
              each(e, adj_list[u]) {
                  if (e.to == tr.par[u])
                      continue;
                  else if (tr.ord[e.to] < tr.ord[u]) {
                      chmin(lowlink[u], tr.ord[e.to]);
                  } else {
                      chmin(lowlink[u], lowlink[e.to]);
                  }
              }
          }
      }/*}}}*/
  
      vector<Pos> get_articulation_points() {/*{{{*/
          if (sz(lowlink) == 0) throw("make_lowlik() beforehand");
  
          vector<Pos> res;
          if (sz(tr.children[root]) > 1) {
              res.push_back(root);
          }
          rep(u, 0, n) {
              if (u == root) continue;
              bool is_kan = false;
              each(v, tr.children[u]) {
                  if (tr.ord[u] <= lowlink[v]) {
                      is_kan = true;
                  }
              }
              if (is_kan) res.push_back(u);
          }
          return res;
      }/*}}}*/
  
      vector<Edge> get_bridges() {/*{{{*/
          if (sz(lowlink) == 0) throw("make_lowlik() beforehand");
          vector<Edge> res;
          each(edge, edges){
              if (tr.ord[edge.from] < lowlink[edge.to]) res.push_back(edge);
          }
          return res;
      }/*}}}*/
  
      vector<Edge> kruskal_tree() {/*{{{*/
          // 使用される辺のvectorを返す
          vector<Edge> res(n - 1);
          sort(all(edges), [&](auto l, auto r) { return l.cost < r.cost; });
          UnionFind uf(n);
  
          Cost total_cost = zerocost;
          int idx = 0;
          each(e, edges) {
              if (uf.same(e.from, e.to)) continue;
              uf.merge(e.from, e.to);
              total_cost = total_cost + e.cost;
              res[idx] = e;
              idx++;
          }
          assert(idx == n - 1);
  
          return res;
      }/*}}}*/
  
      vector<Cost> dijkstra(vector<Pos> starts) {  // 多点スタート{{{
          vector<Cost> dist(n, infcost);           // 最短距離
          PQ<pair<Cost, Pos>> pq;
          each(start, starts) {
              dist[start] = zerocost;
              pq.push(make_pair(zerocost, start));
          }
          while (!pq.empty()) {
              auto cp = pq.top();
              pq.pop();
              auto [cost, u] = cp;
              for (const auto& edge : adj_list[u]) {
                  Cost new_cost = cost + edge.cost;  // TODO: 問題によってはここが変更の必要あり
                  if (new_cost < dist[edge.to]) {
                      dist[edge.to] = new_cost;
                      pq.push(make_pair(new_cost, edge.to));
                  }
              }
          }
          return dist;
      };/*}}}*/
  
      vector<Cost> dijkstra(Pos start) {  // 1点スタート{{{
          vector<Pos> starts = {start};
          return dijkstra(starts);
      };/*}}}*/
  };
  // snippet:Graph }}}
  


snippet bellman_ford
  // snippet:segment_tree {{{
  template <typename T> struct SegmentTree {  // {{{
      private:
          using F = function<T(T, T)>;
          int n;  // 元の配列のサイズ
          int N;  // n以上の最小の2冪
          vector<T> node;
          F merge;
          T identity;
  
      public:
          SegmentTree() {}
          SegmentTree(vector<T> a, F f, T id) : merge(f), identity(id) {
              n = a.size();
              N = 1;
              while (N < n) N *= 2;
              node.resize(2 * N - 1, identity);
              for (int i = 0; i < n; i++) node[i + N - 1] = a[i];
              for (int i = N - 2; i >= 0; i--)
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
          }
          SegmentTree(int n, F f, T id) : SegmentTree(vector<T>(n, id), f, id) {}
  
          T& operator[](int i) { return node[i + N - 1]; }
  
          void update(int i, T val) {
              i += (N - 1);
              node[i] = val;
              while (i > 0) {
                  i = (i - 1) / 2;
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
              }
          }
  
          void add(int i, T val) {
              i += (N - 1);
              node[i] += val;
              while (i > 0) {
                  i = (i - 1) / 2;
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
              }
          }
  
          // query for [l, r)
          T query(int a, int b, int k = 0, int l = 0, int r = -1) {
              if (r < 0) r = N;
              if (r <= a || b <= l) return identity;
              if (a <= l && r <= b) return node[k];
  
              T vl = query(a, b, 2 * k + 1, l, (l + r) / 2);
              T vr = query(a, b, 2 * k + 2, (l + r) / 2, r);
              return merge(vl, vr);
          }
  
          #if defined(PCM) || defined(LOCAL)
          friend ostream& operator<<(ostream& os, SegmentTree<T>& sg) {  //
              os << "[";
              for (int i = 0; i < sg.n; i++) {
                  os << sg[i] << (i == sg.n - 1 ? "]\n" : ", ");
              }
              return os;
          }
          #endif
  };/*}}}*/
  // sample of initialize SegmentTree:
  // -----------------------------------------------
  // auto mymin=[](auto a, auto b){return min(a,b);};
  // SegmentTree<ll> seg(a, mymin, 1e18);
  
  // auto mymax=[](auto a, auto b){return max(a,b);};
  // SegmentTree<ll> seg(a, mymax, -1e18);
  
  // auto add=[](auto a, auto b){return a+b;};
  // SegmentTree<ll> seg(a, add, 0);
  // -----------------------------------------------
  // snippet:segment_tree }}}
  
  // snippet:UnionFind {{{
  struct UnionFind {
      vector<int> data;  // size defined only for root node
      int count;         // count of groups
  
      UnionFind() {}
      UnionFind(int size) : data(size, -1), count(size) {}
      bool merge(int x, int y) { /*{{{*/
          x = root(x);
          y = root(y);
          if (x != y) {
              if (data[y] < data[x]) swap(x, y);
              data[x] += data[y];
              data[y] = x;
              count--;
          }
          return x != y;
      } /*}}}*/
      int root(int x) { return (data[x] < 0 ? x : data[x] = root(data[x])); }
      bool same(int x, int y) { return root(x) == root(y); }
      int size(int x) { return -data[root(x)]; }
  
  #if defined(PCM) || defined(LOCAL)  // {{{
      friend ostream& operator<<(ostream& os, UnionFind& uf) {
          map<int, vector<int>> group;
          rep(i, sz(uf.data)) { group[uf.root(i)].pb(i); }
          os << endl;
          each(g, group) { os << g << endl; }
          return os;
      }
  #endif  // }}}
  };
  // snippet:UnionFind }}}
  
  // snippet:tree {{{
  template<class Cost=ll>
  struct tree { 
      int n;
      vector<int> par;   // par[i]: dfs木における親
      vector<Cost> cost;  // par[i]: dfs木における親への辺のコスト
      vector<int> dfstrv;  // dfstrv[i]: dfs木でi番目に訪れるノード。dpはこれを逆順に回す
      vector<int> ord;    // ord[u]: uのdfs木における訪問順
      vector<int> end;    // end[u]: uのdfs終了時のカウンター
      vector<int> psize;  // psize[u]: uのpartial tree size
      // uの部分木は[ord[u], end[u])
      // ordとdfstrvは逆変換
      vector<int> depth;   // depth[i]: dfs木でのiの深さ
      vector<Cost> ldepth;  //  ldepth[i]: dfs木でのrootからの距離
      vector<vector<pair<int, Cost>>> g;  // 辺(隣接リスト)
      vector<vector<int>> adj;           // 辺(隣接リスト)
      vector<vector<int>> children;
      vector<int> euler_tour;
      vector<int> et_fpos;    // euler_tour first occurence position
      SegmentTree<int> _seg;  // seg(map(ord, euler_tour), mymin, 1e18)
      vector<int> head_of_comp;
      int _counter = 0;
  
      tree(){};/*{{{*/
      tree(int n)
          : n(n),
            par(n),
            cost(n),
            ord(n),
            end(n),
            psize(n),
            depth(n),
            ldepth(n),
            g(n),
            adj(n),
            children(n),
            et_fpos(n),
            head_of_comp(n){};/*}}}*/
      void add_edge(int u, int v, Cost cost) { /*{{{*/
          g[u].emplace_back(v, cost);
          g[v].emplace_back(u, cost);
          adj[u].emplace_back(v);
          adj[v].emplace_back(u);
      }                             /*}}}*/
      void add_edge(int u, int v) { /*{{{*/
          g[u].emplace_back(v, 1);
          g[v].emplace_back(u, 1);
          adj[u].emplace_back(v);
          adj[v].emplace_back(u);
      }                      /*}}}*/
      void build(int root) { /*{{{*/
          _counter = 0;
          // par[root] = -1;
          // cost[root] = -1;
          _dfs_psize(root, -1);
          _dfs_tree(root, -1, root);
          _dfs_et(root);
          vector<int> ini(2 * n - 1);
          rep(i, 2 * n - 1) ini[i] = ord[euler_tour[i]];
          _seg = SegmentTree<int>(
              ini, [](auto a, auto b) { return min(a, b); }, 1e18);
      }                                /*}}}*/
      int _dfs_psize(int u, int pre) { /*{{{*/
          psize[u] = 1;
          each(el, g[u]) {
              int v = el.first;
              if (v == pre) continue;
              psize[u] += _dfs_psize(v, u);
          }
          return psize[u];
      }                                               /*}}}*/
      void _dfs_tree(int u, int pre, int head_node) { /*{{{*/
          dfstrv.pb(u);
          ord[u] = _counter;
          if (pre != -1) {
              depth[u] = depth[pre] + 1;
              ldepth[u] = ldepth[pre] + cost[u];
          }
  
          _counter++;
          {
              // set most heavy child to top
              int max_psize = 0;
              int most_heavy_i = -1;
              rep(i, sz(g[u])) {
                  if (g[u][i].first == pre) continue;
                  if (psize[g[u][i].first] > max_psize) {
                      most_heavy_i = i;
                      max_psize = psize[g[u][i].first];
                  }
              }
              if (most_heavy_i != -1) swap(g[u][most_heavy_i], g[u][0]);
          }
  
          head_of_comp[u] = head_node;
          rep(i, sz(g[u])) {
              int v = g[u][i].first;
              if (v == pre) continue;
  
              children[u].pb(v);
              par[v] = u;
              cost[v] = g[u][i].second;
  
              if (i == 0)
                  _dfs_tree(v, u, head_node);  // continue components
              else
                  _dfs_tree(v, u, v);  // new
          }
          end[u] = _counter;
      }                     /*}}}*/
      void _dfs_et(int u) { /*{{{*/
          et_fpos[u] = euler_tour.size();
          euler_tour.pb(u);
          each(v, children[u]) {
              _dfs_et(v);
              euler_tour.pb(u);
          }
      }                       /*}}}*/
      int lca(int u, int v) { /*{{{*/
          if (u == v) return u;
          if (et_fpos[u] > et_fpos[v]) swap(u, v);
          return dfstrv[_seg.query(et_fpos[u], et_fpos[v])];
      }                        /*}}}*/
      int dist(int u, int v) { /*{{{*/
          int p = lca(u, v);
          return depth[u] + depth[v] - 2 * depth[p];
      }                          /*}}}*/
      Cost ldist(int u, int v) {  // length dist{{{
          int p = lca(u, v);
          return ldepth[u] + ldepth[v] - 2 * ldepth[p];
      }                           /*}}}*/
      pair<int, int> diameter() { /*{{{*/
          int u, v;
          Cost max_len = *max_element(all(ldepth));
          rep(i, n) {
              if (ldepth[i] == max_len) {
                  u = i;
                  break;
              }
          }
          Cost md = -1;
          rep(i, n) {
              Cost d = ldist(u, i);
              if (d > md) {
                  v = i;
                  md = d;
              }
          }
          return mp(u, v);
      }                                                /*}}}*/
      vector<pair<int, int>> hld_path(int u, int v) {  //{{{
          // 閉区間をvectorで返す
          vector<pair<int, int>> res;
          while (head_of_comp[u] != head_of_comp[v]) {
              if (depth[head_of_comp[u]] < depth[head_of_comp[v]]) {
                  res.push_back({ord[head_of_comp[v]], ord[v]});
                  v = par[head_of_comp[v]];
              } else {
                  res.push_back({ord[head_of_comp[u]], ord[u]});
                  u = par[head_of_comp[u]];
              }
          }
          res.push_back({min(ord[u], ord[v]), max(ord[u], ord[v])});
          return res;
      }                              //}}}
  #if defined(PCM) || defined(LOCAL) /*{{{*/
      friend ostream& operator<<(ostream& os, const tree& tr) {
          os << endl;
          os << "par:         " << tr.par << endl;
          os << "cost:        " << tr.cost << endl;
          os << "dfstrv:      " << tr.dfstrv << endl;
          os << "ord:         " << tr.ord << endl;
          os << "end:         " << tr.end << endl;
          os << "depth:       " << tr.depth << endl;
          os << "children:    " << tr.children << endl;
          os << "euler_tour:  " << tr.euler_tour << endl;
          os << "et_fpos:     " << tr.et_fpos << endl;
          os << "head_of_comp:" << tr.head_of_comp << endl;
          return os;
      }
  #endif /*}}}*/
  }; 
  // snippet:tree }}}
  
  // snippet:Graph {{{
  template<class Cost=ll>
  struct Graph {
      using Pos = int;  // int以外には対応しない。
      struct Edge {/*{{{*/
          Pos from, to;
          Cost cost;
          int idx;
          Edge(){};
          Edge(Pos from, Pos to, Cost cost, int idx)
              : from(from), to(to), cost(cost), idx(idx) {}
          friend ostream& operator<<(ostream& os, const Edge& e) {
              // os << "(f:" << e.from << ", t:" << e.to << ", c:" << e.cost << ", i" << e.idx << ")";  // detailed
              os << "(" << e.from << "," << e.to << ")";
              return os;
          }
      };/*}}}*/
  
      int n;  // 頂点数
      vector<vector<Edge>> adj_list;
      auto operator[](Pos pos) const { return adj_list[pos]; }
      vector<Edge> edges;
      tree<Cost> tr;
      Pos root;
      vector<int> _used_in_dfs;
      vector<int> lowlink;
      Cost zerocost;
      Cost infcost;
  
      Graph() {}
      Graph(int _n) : n(_n), adj_list(_n), tr(n), _used_in_dfs(n), zerocost(0LL), infcost(INF) { }
      Graph(int _n, Cost zc, Cost ic) : n(_n), adj_list(_n), tr(n), _used_in_dfs(n), zerocost(zc), infcost(ic) { }
  
      void add_edge(Pos from, Pos to, Cost cost, int idx=-1) {/*{{{*/
          adj_list[from].emplace_back(from, to, cost, idx);
          edges.emplace_back(from, to, cost, idx);
      }
      void add_edge(Pos from, Pos to) {  // for ll
          adj_list[from].emplace_back(from, to, 1, -1);
          edges.emplace_back(from, to, 1, -1);
      }/*}}}*/
  
      void build_tree(Pos _root) {/*{{{*/
          root = _root;
          _dfs_tree(root);
          tr.build(root);
          _make_lowlink();
      }/*}}}*/
  
      vector<int> make_bipartite() {/*{{{*/
          UnionFind buf(2 * n);
          rep(u, n) {
              each(e, adj_list[u]) {
                  buf.merge(u, e.to + n);
                  buf.merge(e.to, u + n);
              }
          }
  
          vector<int> res(n, -1);
          rep(u, n) {
              if (buf.same(u, u + n)) return res;
          }
          rep(u, n) {
              if (buf.same(0, u)) res[u] = 0;
              else res[u] = 1;
          }
          return res;
      }/*}}}*/
  
      void _dfs_tree(Pos u) {/*{{{*/
          _used_in_dfs[u] = 1;
          each(e, adj_list[u]) {
              if (_used_in_dfs[e.to]) continue;
              tr.add_edge(u, e.to, e.cost);
              _dfs_tree(e.to);
          }
      }/*}}}*/
  
      void _make_lowlink() {/*{{{*/
          lowlink = vector<Pos>(n, INF);
          r_rep(i, n) {
              Pos u = tr.dfstrv[i];
              chmin(lowlink[u], tr.ord[u]);
  
              each(e, adj_list[u]) {
                  if (e.to == tr.par[u])
                      continue;
                  else if (tr.ord[e.to] < tr.ord[u]) {
                      chmin(lowlink[u], tr.ord[e.to]);
                  } else {
                      chmin(lowlink[u], lowlink[e.to]);
                  }
              }
          }
      }/*}}}*/
  
      vector<Pos> get_articulation_points() {/*{{{*/
          if (sz(lowlink) == 0) throw("make_lowlik() beforehand");
  
          vector<Pos> res;
          if (sz(tr.children[root]) > 1) {
              res.push_back(root);
          }
          rep(u, 0, n) {
              if (u == root) continue;
              bool is_kan = false;
              each(v, tr.children[u]) {
                  if (tr.ord[u] <= lowlink[v]) {
                      is_kan = true;
                  }
              }
              if (is_kan) res.push_back(u);
          }
          return res;
      }/*}}}*/
  
      vector<Edge> get_bridges() {/*{{{*/
          if (sz(lowlink) == 0) throw("make_lowlik() beforehand");
          vector<Edge> res;
          each(edge, edges){
              if (tr.ord[edge.from] < lowlink[edge.to]) res.push_back(edge);
          }
          return res;
      }/*}}}*/
  
      vector<Edge> kruskal_tree() {/*{{{*/
          // 使用される辺のvectorを返す
          vector<Edge> res(n - 1);
          sort(all(edges), [&](auto l, auto r) { return l.cost < r.cost; });
          UnionFind uf(n);
  
          Cost total_cost = zerocost;
          int idx = 0;
          each(e, edges) {
              if (uf.same(e.from, e.to)) continue;
              uf.merge(e.from, e.to);
              total_cost = total_cost + e.cost;
              res[idx] = e;
              idx++;
          }
          assert(idx == n - 1);
  
          return res;
      }/*}}}*/
  
      vector<Cost> dijkstra(vector<Pos> starts) {  // 多点スタート{{{
          vector<Cost> dist(n, infcost);           // 最短距離
          PQ<pair<Cost, Pos>> pq;
          each(start, starts) {
              dist[start] = zerocost;
              pq.push(make_pair(zerocost, start));
          }
          while (!pq.empty()) {
              auto cp = pq.top();
              pq.pop();
              auto [cost, u] = cp;
              for (const auto& edge : adj_list[u]) {
                  Cost new_cost = cost + edge.cost;  // TODO: 問題によってはここが変更の必要あり
                  if (new_cost < dist[edge.to]) {
                      dist[edge.to] = new_cost;
                      pq.push(make_pair(new_cost, edge.to));
                  }
              }
          }
          return dist;
      };/*}}}*/
  
      vector<Cost> dijkstra(Pos start) {  // 1点スタート{{{
          vector<Pos> starts = {start};
          return dijkstra(starts);
      };/*}}}*/
  };
  // snippet:Graph }}}
  
  // snippet:bellman_ford {{{
  auto bellman_ford(const Graph<>& g, int start) { // 負閉路検出
      vector<decltype(g.infcost)> dist(g.n, g.infcost);  // 最短距離
      dist[start] = g.zerocost;
      for (int i = 0; i < g.n; i++) {
          each(edge, g.edges){
              if (dist[edge.from] != INF && dist[edge.to] > dist[edge.from] + edge.cost) {
                  dist[edge.to] = dist[edge.from] + edge.cost;
                  if (i == g.n - 1)
                      return make_pair(true, dist);  // n回目にも更新があるなら負の閉路が存在
              }
          }
      }
      return make_pair(false, dist);
  }
  // snippet:bellman_ford }}}
  


snippet tree
  // snippet:segment_tree {{{
  template <typename T> struct SegmentTree {  // {{{
      private:
          using F = function<T(T, T)>;
          int n;  // 元の配列のサイズ
          int N;  // n以上の最小の2冪
          vector<T> node;
          F merge;
          T identity;
  
      public:
          SegmentTree() {}
          SegmentTree(vector<T> a, F f, T id) : merge(f), identity(id) {
              n = a.size();
              N = 1;
              while (N < n) N *= 2;
              node.resize(2 * N - 1, identity);
              for (int i = 0; i < n; i++) node[i + N - 1] = a[i];
              for (int i = N - 2; i >= 0; i--)
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
          }
          SegmentTree(int n, F f, T id) : SegmentTree(vector<T>(n, id), f, id) {}
  
          T& operator[](int i) { return node[i + N - 1]; }
  
          void update(int i, T val) {
              i += (N - 1);
              node[i] = val;
              while (i > 0) {
                  i = (i - 1) / 2;
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
              }
          }
  
          void add(int i, T val) {
              i += (N - 1);
              node[i] += val;
              while (i > 0) {
                  i = (i - 1) / 2;
                  node[i] = merge(node[2 * i + 1], node[2 * i + 2]);
              }
          }
  
          // query for [l, r)
          T query(int a, int b, int k = 0, int l = 0, int r = -1) {
              if (r < 0) r = N;
              if (r <= a || b <= l) return identity;
              if (a <= l && r <= b) return node[k];
  
              T vl = query(a, b, 2 * k + 1, l, (l + r) / 2);
              T vr = query(a, b, 2 * k + 2, (l + r) / 2, r);
              return merge(vl, vr);
          }
  
          #if defined(PCM) || defined(LOCAL)
          friend ostream& operator<<(ostream& os, SegmentTree<T>& sg) {  //
              os << "[";
              for (int i = 0; i < sg.n; i++) {
                  os << sg[i] << (i == sg.n - 1 ? "]\n" : ", ");
              }
              return os;
          }
          #endif
  };/*}}}*/
  // sample of initialize SegmentTree:
  // -----------------------------------------------
  // auto mymin=[](auto a, auto b){return min(a,b);};
  // SegmentTree<ll> seg(a, mymin, 1e18);
  
  // auto mymax=[](auto a, auto b){return max(a,b);};
  // SegmentTree<ll> seg(a, mymax, -1e18);
  
  // auto add=[](auto a, auto b){return a+b;};
  // SegmentTree<ll> seg(a, add, 0);
  // -----------------------------------------------
  // snippet:segment_tree }}}
  
  // snippet:tree {{{
  template<class Cost=ll>
  struct tree { 
      int n;
      vector<int> par;   // par[i]: dfs木における親
      vector<Cost> cost;  // par[i]: dfs木における親への辺のコスト
      vector<int> dfstrv;  // dfstrv[i]: dfs木でi番目に訪れるノード。dpはこれを逆順に回す
      vector<int> ord;    // ord[u]: uのdfs木における訪問順
      vector<int> end;    // end[u]: uのdfs終了時のカウンター
      vector<int> psize;  // psize[u]: uのpartial tree size
      // uの部分木は[ord[u], end[u])
      // ordとdfstrvは逆変換
      vector<int> depth;   // depth[i]: dfs木でのiの深さ
      vector<Cost> ldepth;  //  ldepth[i]: dfs木でのrootからの距離
      vector<vector<pair<int, Cost>>> g;  // 辺(隣接リスト)
      vector<vector<int>> adj;           // 辺(隣接リスト)
      vector<vector<int>> children;
      vector<int> euler_tour;
      vector<int> et_fpos;    // euler_tour first occurence position
      SegmentTree<int> _seg;  // seg(map(ord, euler_tour), mymin, 1e18)
      vector<int> head_of_comp;
      int _counter = 0;
  
      tree(){};/*{{{*/
      tree(int n)
          : n(n),
            par(n),
            cost(n),
            ord(n),
            end(n),
            psize(n),
            depth(n),
            ldepth(n),
            g(n),
            adj(n),
            children(n),
            et_fpos(n),
            head_of_comp(n){};/*}}}*/
      void add_edge(int u, int v, Cost cost) { /*{{{*/
          g[u].emplace_back(v, cost);
          g[v].emplace_back(u, cost);
          adj[u].emplace_back(v);
          adj[v].emplace_back(u);
      }                             /*}}}*/
      void add_edge(int u, int v) { /*{{{*/
          g[u].emplace_back(v, 1);
          g[v].emplace_back(u, 1);
          adj[u].emplace_back(v);
          adj[v].emplace_back(u);
      }                      /*}}}*/
      void build(int root) { /*{{{*/
          _counter = 0;
          // par[root] = -1;
          // cost[root] = -1;
          _dfs_psize(root, -1);
          _dfs_tree(root, -1, root);
          _dfs_et(root);
          vector<int> ini(2 * n - 1);
          rep(i, 2 * n - 1) ini[i] = ord[euler_tour[i]];
          _seg = SegmentTree<int>(
              ini, [](auto a, auto b) { return min(a, b); }, 1e18);
      }                                /*}}}*/
      int _dfs_psize(int u, int pre) { /*{{{*/
          psize[u] = 1;
          each(el, g[u]) {
              int v = el.first;
              if (v == pre) continue;
              psize[u] += _dfs_psize(v, u);
          }
          return psize[u];
      }                                               /*}}}*/
      void _dfs_tree(int u, int pre, int head_node) { /*{{{*/
          dfstrv.pb(u);
          ord[u] = _counter;
          if (pre != -1) {
              depth[u] = depth[pre] + 1;
              ldepth[u] = ldepth[pre] + cost[u];
          }
  
          _counter++;
          {
              // set most heavy child to top
              int max_psize = 0;
              int most_heavy_i = -1;
              rep(i, sz(g[u])) {
                  if (g[u][i].first == pre) continue;
                  if (psize[g[u][i].first] > max_psize) {
                      most_heavy_i = i;
                      max_psize = psize[g[u][i].first];
                  }
              }
              if (most_heavy_i != -1) swap(g[u][most_heavy_i], g[u][0]);
          }
  
          head_of_comp[u] = head_node;
          rep(i, sz(g[u])) {
              int v = g[u][i].first;
              if (v == pre) continue;
  
              children[u].pb(v);
              par[v] = u;
              cost[v] = g[u][i].second;
  
              if (i == 0)
                  _dfs_tree(v, u, head_node);  // continue components
              else
                  _dfs_tree(v, u, v);  // new
          }
          end[u] = _counter;
      }                     /*}}}*/
      void _dfs_et(int u) { /*{{{*/
          et_fpos[u] = euler_tour.size();
          euler_tour.pb(u);
          each(v, children[u]) {
              _dfs_et(v);
              euler_tour.pb(u);
          }
      }                       /*}}}*/
      int lca(int u, int v) { /*{{{*/
          if (u == v) return u;
          if (et_fpos[u] > et_fpos[v]) swap(u, v);
          return dfstrv[_seg.query(et_fpos[u], et_fpos[v])];
      }                        /*}}}*/
      int dist(int u, int v) { /*{{{*/
          int p = lca(u, v);
          return depth[u] + depth[v] - 2 * depth[p];
      }                          /*}}}*/
      Cost ldist(int u, int v) {  // length dist{{{
          int p = lca(u, v);
          return ldepth[u] + ldepth[v] - 2 * ldepth[p];
      }                           /*}}}*/
      pair<int, int> diameter() { /*{{{*/
          int u, v;
          Cost max_len = *max_element(all(ldepth));
          rep(i, n) {
              if (ldepth[i] == max_len) {
                  u = i;
                  break;
              }
          }
          Cost md = -1;
          rep(i, n) {
              Cost d = ldist(u, i);
              if (d > md) {
                  v = i;
                  md = d;
              }
          }
          return mp(u, v);
      }                                                /*}}}*/
      vector<pair<int, int>> hld_path(int u, int v) {  //{{{
          // 閉区間をvectorで返す
          vector<pair<int, int>> res;
          while (head_of_comp[u] != head_of_comp[v]) {
              if (depth[head_of_comp[u]] < depth[head_of_comp[v]]) {
                  res.push_back({ord[head_of_comp[v]], ord[v]});
                  v = par[head_of_comp[v]];
              } else {
                  res.push_back({ord[head_of_comp[u]], ord[u]});
                  u = par[head_of_comp[u]];
              }
          }
          res.push_back({min(ord[u], ord[v]), max(ord[u], ord[v])});
          return res;
      }                              //}}}
  #if defined(PCM) || defined(LOCAL) /*{{{*/
      friend ostream& operator<<(ostream& os, const tree& tr) {
          os << endl;
          os << "par:         " << tr.par << endl;
          os << "cost:        " << tr.cost << endl;
          os << "dfstrv:      " << tr.dfstrv << endl;
          os << "ord:         " << tr.ord << endl;
          os << "end:         " << tr.end << endl;
          os << "depth:       " << tr.depth << endl;
          os << "children:    " << tr.children << endl;
          os << "euler_tour:  " << tr.euler_tour << endl;
          os << "et_fpos:     " << tr.et_fpos << endl;
          os << "head_of_comp:" << tr.head_of_comp << endl;
          return os;
      }
  #endif /*}}}*/
  }; 
  // snippet:tree }}}
  


